#include <stdlib.h>
#include <string>
#include <iostream>
#include "logger.h"
#include "ast.h"
#include "token.h"
#include "logger_decls.h"
#include "compiler.h"
#include <csignal>
#include "parse_state.h"
#include "parser.h"
#include "code_id.h"
#include "type_parser.h"

using namespace ast;


bool token_begins_type(const token_t &token) {
	switch (token.tk) {
	case tk_integer:
	case tk_string:
	case tk_times:
	case tk_lsquare:
	case tk_lcurly:
	case tk_identifier:
		return true;
	default:
		return false;
	};
}

ptr<var_decl_t> var_decl_t::parse(parse_state_t &ps, bool is_let) {
	expect_token(tk_identifier);

	auto var_decl = create<ast::var_decl_t>(ps.token);
	var_decl->is_let_var = is_let;
	eat_token();

	if (ps.token.tk != tk_assign) {
		var_decl->type = types::parse_type(ps, {} /*generics*/);
	} else {
		var_decl->type = type_variable(ps.prior_token.location);
	}

	if (ps.token.tk == tk_assign) {
		eat_token();
		var_decl->initializer = expression_t::parse(ps);
	}

	return var_decl;
}

ptr<var_decl_t> var_decl_t::parse_param(parse_state_t &ps) {
	expect_token(tk_identifier);

	auto var_decl = create<ast::var_decl_t>(ps.token);
	eat_token();

	if (ps.token.tk == tk_assign) {
		throw user_error(ps.token.location, "default values for function arguments are not a thing");
	} else if (ps.token.tk == tk_comma || ps.token.tk == tk_rparen) {
		/* ok, let's inject an autogenerated token */
		var_decl->type = type_variable(ps.token.location);
	} else {
		var_decl->type = types::parse_type(ps, {});
	}

	return var_decl;
}

ptr<return_statement_t> return_statement_t::parse(parse_state_t &ps) {
	auto return_statement = create<ast::return_statement_t>(ps.token);
	chomp_ident(K(return));
	if (!ps.line_broke() && ps.token.tk != tk_outdent) {
		return_statement->expr = expression_t::parse(ps);
	}
	return return_statement;
}

ptr<unreachable_t> unreachable_t::parse(parse_state_t &ps) {
	auto unreachable = create<ast::unreachable_t>(ps.token);
	chomp_ident(K(__unreachable__));
	return unreachable;
}

ptr<statement_t> get_statement_parse(parse_state_t &ps) {
	expect_ident(K(get));
	auto get_token = ps.token;
	ps.advance();

	auto module_decl = module_decl_t::parse(ps, true /*skip_module_token*/);
	auto link_statement = create<link_module_statement_t>(get_token);
	link_statement->extern_module = module_decl;

	if (ps.token.is_ident(K(as))) {
		/* get the local name for this module */
		ps.advance();
		expect_token(tk_identifier);
		link_statement->link_as_name = ps.token;
		ps.advance();
	}

	if (link_statement->link_as_name.tk == tk_none) {
		link_statement->link_as_name = module_decl->get_name();
	}

	if (link_statement->link_as_name.tk != tk_identifier) {
		throw user_error(ps.token.location, "expected an identifier for link module name (either implicit or explicit)");
	}

	return link_statement;
}

ptr<statement_t> link_statement_parse(parse_state_t &ps) {
	expect_ident(K(link));
	auto link_token = ps.token;
	ps.advance();

	if (ps.token.tk == tk_lsquare || ps.token.is_ident(K(def))) {
		auto link_function_statement = create<ast::link_function_statement_t>(link_token);
		auto function_decl = function_decl_t::parse(ps, false /*within_expression*/);
		if (ps.token.is_ident(K(to))) {
			ps.advance();
			if (ps.token.tk != tk_identifier && ps.token.tk != tk_string) {
				throw user_error(ps.token.location, "expected an identifier (or string) for the external name of the linked function (not %s)",
						ps.token.str().c_str());
			}
			expect_token(tk_identifier);
			function_decl->link_to_name = ps.token;
			ps.advance();
		}
		link_function_statement->extern_function = function_decl;

		return link_function_statement;
	} else if (ps.token.is_ident(K(var))) {
		ps.advance();
		// REVIEW: does it make sense to handle 'let' in this context?
		auto var_decl = var_decl_t::parse(ps, false /* is_let */);
		auto link_var = create<link_var_statement_t>(link_token);
		link_var->var_decl = var_decl;
		return link_var;
	} else if (ps.token.is_ident(K(in))) {
		ps.advance();
		expect_token(tk_string);
		if (ps.link_ins != nullptr) {
			ps.link_ins->insert(ps.token);
		}
		ps.advance();
		return nullptr;
	} else if (ps.token.tk == tk_identifier) {
		/*
		 * link name to some_module.something
		 *
		 * 1. Sets up a type parser macro "name" => "some_module.something"
		 * 2. Sets up a "scope link" from this module to the "some_module" for the
		 * "something" name so that if there is a call to "something" from
		 * within this module, we also search "some_module" when enumerating
		 * callables.
		 * 3. Start tracking whether the link is in use in the module
		 */
		auto name_token = ps.token;
		ps.advance();
		chomp_ident(K(to));

		auto link_name = create<ast::link_name_t>(link_token);
		link_name->local_name = name_token;
		link_name->extern_module = module_decl_t::parse(ps, true /* skip_module_token */);

			chomp_token(tk_dot);
			expect_token(tk_identifier);
			link_name->remote_name = ps.token;
			ps.advance();
			return link_name;
	} else {
		throw user_error(ps.token.location, "invalid link syntax (TODO: make this error better)");
	}
}

ptr<statement_t> statement_t::parse(parse_state_t &ps) {
	assert(ps.token.tk != tk_outdent);

	if (ps.token.is_ident(K(var))) {
		ps.advance();
		return var_decl_t::parse(ps, false /*is_let*/);
	} else if (ps.token.is_ident(K(let))) {
		ps.advance();
		return var_decl_t::parse(ps, true /*is_let*/);
	} else if (ps.token.is_ident(K(if))) {
		return if_block_t::parse(ps);
	} else if (ps.token.is_ident(K(while))) {
		return while_block_t::parse(ps);
	} else if (ps.token.is_ident(K(for))) {
		return for_block_t::parse(ps);
	} else if (ps.token.is_ident(K(when))) {
		return when_block_t::parse(ps);
	} else if (ps.token.is_ident(K(return))) {
		return return_statement_t::parse(ps);
	} else if (ps.token.is_ident(K(__unreachable__))) {
		return unreachable_t::parse(ps);
	} else if (ps.token.is_ident(K(type))) {
		return type_def_t::parse(ps);
	} else if (ps.token.is_ident(K(pass))) {
		auto pass_flow = create<ast::pass_flow_t>(ps.token);
		eat_token();
		return std::move(pass_flow);
	} else if (ps.token.is_ident(K(continue))) {
		auto continue_flow = create<ast::continue_flow_t>(ps.token);
		eat_token();
		return std::move(continue_flow);
	} else if (ps.token.is_ident(K(break))) {
		auto break_flow = create<ast::break_flow_t>(ps.token);
		eat_token();
		return std::move(break_flow);
	} else {
		return assignment_t::parse(ps);
	}
}

ptr<expression_t> reference_expr_t::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_identifier) {
		if (ps.token.text == "null") {
			auto token = ps.token;
			ps.advance();
			return create<ast::literal_expr_t>(token);
		}
		auto reference_expr = create<ast::reference_expr_t>(ps.token);
		ps.advance();
		return std::move(reference_expr);
	} else {
		throw user_error(ps.token.location, "expected an identifier");
	}
}

ptr<typeid_expr_t> typeid_expr_t::parse(parse_state_t &ps) {
	auto token = ps.token;
	chomp_ident(K(typeid));
	chomp_token(tk_lparen);

	auto value = expression_t::parse(ps);
	assert(value != nullptr);
	auto expr = ast::create<typeid_expr_t>(token, value);
	chomp_token(tk_rparen);
	return expr;
}

ptr<sizeof_expr_t> sizeof_expr_t::parse(parse_state_t &ps) {
	auto token = ps.token;
	chomp_ident(K(sizeof));
	chomp_token(tk_lparen);

	auto type = types::parse_type(ps, {});
	assert(type != nullptr);
	auto expr = ast::create<sizeof_expr_t>(token, type);
	chomp_token(tk_rparen);
	return expr;
}

ptr<expression_t> parse_cast_wrap(parse_state_t &ps, ptr<expression_t> expr) {
    if (ps.token.is_ident(K(as))) {
		auto token = ps.token;
		ps.advance();
		auto cast = ast::create<ast::cast_expr_t>(token);
		cast->lhs = expr;

		if (ps.token.tk == tk_bang) {
			if (token.location.line != ps.token.location.line || token.location.col + strlen(K(as)) != ps.token.location.col) {
				throw user_error(ps.token.location,
					   	"unsafe casts must not have any whitespace between \"as\" and \"!\". "
						"They must appear exactly like this: \"as!\". This is to enable "
						"searching over codebases for any misused unsafe casts.");
			}
			ps.advance();
			cast->force_cast = true;
		}
		cast->type_cast = types::parse_type(ps, {});
        return cast;
    } else {
        return expr;
    }
}

ptr<expression_t> base_expr::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_lparen) {
		return tuple_expr_t::parse(ps);
	} else if (ps.token.is_ident(K(typeid))) {
		return typeid_expr_t::parse(ps);
	} else if (ps.token.is_ident(K(sizeof))) {
		return sizeof_expr_t::parse(ps);
	} else if (ps.token.is_ident(K(def))) {
		return function_defn_t::parse(ps, true /*within_expression*/);
	} else if (ps.token.tk == tk_identifier) {
		// NB: this is last to ensure "special" builtins are in play above
		return reference_expr_t::parse(ps);
	} else {
		return literal_expr_t::parse(ps);
	}
}

ptr<expression_t> array_literal_expr_t::parse(parse_state_t &ps) {
	chomp_token(tk_lsquare);
	auto array = create<array_literal_expr_t>(ps.token);
	auto &items = array->items;

	int i = 0;
	while (ps.token.tk != tk_rsquare && ps.token.tk != tk_none) {
		++i;
		items.push_back(expression_t::parse(ps));
		if (ps.token.tk == tk_comma) {
			ps.advance();
		} else if (ps.token.tk != tk_rsquare) {
			throw user_error(ps.token.location, "found something that does not make sense in an array literal");
		}
	}
	chomp_token(tk_rsquare);
	return array;
}

ptr<expression_t> literal_expr_t::parse(parse_state_t &ps) {
	switch (ps.token.tk) {
	case tk_integer:
	case tk_string:
	case tk_char:
	case tk_float:
		{
			auto literal_expr = create<ast::literal_expr_t>(ps.token);
			ps.advance();
			return std::move(literal_expr);
		}
	case tk_lsquare:
		return array_literal_expr_t::parse(ps);
	// case tk_lcurly:
	//	return assoc_array_expr_t::parse(ps);
	case tk_indent:
		throw user_error(ps.token.location, "unexpected indent");

	case tk_identifier:
		throw user_error(ps.token.location, "unexpected token found when parsing literal expression. '" c_error("%s") "'", ps.token.text.c_str());

	default:
		throw user_error(ps.token.location, "out of place token found when parsing literal expression. '" c_error("%s") "' (%s)",
			   	ps.token.text.c_str(),
				tkstr(ps.token.tk));
	}
}

ptr<typeinfo_expr_t> typeinfo_expr_t::parse(parse_state_t &ps) {
	expect_token(tk_lparen);
	auto typeinfo_expr = ast::create<typeinfo_expr_t>(ps.prior_token);
	ps.advance();
	typeinfo_expr->type = types::parse_type(ps, {});
	chomp_token(tk_comma);

	typeinfo_expr->underlying_type = types::parse_type(ps, {});

	chomp_token(tk_comma);
	expect_token(tk_identifier);
	typeinfo_expr->finalize_function = ps.token;
	ps.advance();
	chomp_token(tk_comma);
	expect_token(tk_identifier);
	typeinfo_expr->mark_function = ps.token;
	ps.advance();
	chomp_token(tk_rparen);
	return typeinfo_expr;
}

std::vector<ptr<expression_t>> parse_param_list(parse_state_t &ps) {
	std::vector<ptr<expression_t>> params;
	chomp_token(tk_lparen);
	int i = 0;
	while (ps.token.tk != tk_rparen) {
		++i;
		params.push_back(expression_t::parse(ps));
		if (ps.token.tk == tk_comma) {
			eat_token();
		} else if (ps.token.tk != tk_rparen) {
			throw user_error(ps.token.location, "unexpected %s in parameter list (" c_id("%s") ")", tkstr(ps.token.tk), ps.token.text.c_str());
		}
		// continue and read the next parameter
	}
	chomp_token(tk_rparen);

	return params;
}

namespace ast {
	namespace postfix_expr {
		ptr<expression_t> parse(parse_state_t &ps) {
			ptr<expression_t> expr = base_expr::parse(ps);

			while (!ps.line_broke() &&
					(ps.token.tk == tk_lsquare ||
					 ps.token.tk == tk_lparen ||
					 ps.token.tk == tk_dot ||
					 ps.token.tk == tk_bang))
			{
				switch (ps.token.tk) {
				case tk_lparen:
					{
						auto ref_expr = dyncast<reference_expr_t>(expr);

						if (ref_expr != nullptr && ref_expr->token.text == "typeinfo") {
							/* override the typeinfo keyword */
							expr = typeinfo_expr_t::parse(ps);
						} else {
							/* function call */
							auto callsite = create<callsite_expr_t>(ps.token);
							callsite->params = parse_param_list(ps);
							callsite->function_expr.swap(expr);
							assert(expr == nullptr);
							expr = callsite;
						}
						break;
					}
				case tk_dot:
					{
						auto dot_expr = create<ast::dot_expr_t>(ps.token);
						eat_token();
						expect_token(tk_identifier);
						dot_expr->rhs = ps.token;
						ps.advance();
						dot_expr->lhs.swap(expr);
						assert(expr == nullptr);
						expr = dot_expr;
						break;
					}
				case tk_lsquare:
					{
						eat_token();
						auto array_index_expr = create<ast::array_index_expr_t>(ps.token);

						array_index_expr->lhs = expr;
						array_index_expr->start = expression_t::parse(ps);
						if (ps.token.tk == tk_colon) {
							ps.advance();
							array_index_expr->stop = expression_t::parse(ps);
						}
						expr = array_index_expr;
						chomp_token(tk_rsquare);
						break;
					}
				case tk_bang:
					{
						auto bang = ast::create<ast::bang_expr_t>(ps.token);
						bang->lhs = expr;
						expr = bang;
						ps.advance();
						break;
					}
				default:
					break;
				}
			}

			return expr;
		}
	}
}

ptr<expression_t> prefix_expr_t::parse(parse_state_t &ps) {
	ptr<prefix_expr_t> prefix_expr;
	if (ps.token.tk == tk_ampersand
			|| ps.token.tk == tk_minus
			|| ps.token.tk == tk_plus
			|| ps.token.is_ident(K(not)))
	{
		prefix_expr = create<ast::prefix_expr_t>(ps.token);
		eat_token();
	}

	ptr<expression_t> rhs;
	if (ps.token.is_ident(K(not))
			|| ps.token.tk == tk_minus
			|| ps.token.tk == tk_plus) {
		/* recurse to find more prefix expressions */
		rhs = prefix_expr_t::parse(ps);
	} else {
		/* ok, we're done with prefix operators */
		rhs = postfix_expr::parse(ps);
	}

	if (prefix_expr) {
		prefix_expr->rhs = std::move(rhs);
		return parse_cast_wrap(ps, prefix_expr);
	} else {
		return parse_cast_wrap(ps, rhs);
	}
}


ptr<expression_t> times_expr_parse(parse_state_t &ps) {
	auto expr = prefix_expr_t::parse(ps);

	while (!ps.line_broke() && (ps.token.tk == tk_times
				|| ps.token.tk == tk_divide_by
				|| ps.token.tk == tk_mod)) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		switch (ps.token.tk) {
		case tk_times:
			binary_operator->function_name = "__times__";
			break;
		case tk_divide_by:
			binary_operator->function_name = "__divide__";
			break;
		case tk_mod:
			binary_operator->function_name = "__mod__";
			break;
		default:
			assert(false);
			break;
		}

		eat_token();

		auto rhs = prefix_expr_t::parse(ps);
		binary_operator->lhs = expr;
		binary_operator->rhs = rhs;
		expr = binary_operator;
	}

	return expr;
}

ptr<expression_t> plus_expr_parse(parse_state_t &ps) {
	auto expr = times_expr_parse(ps);

	while (!ps.line_broke() &&
			(ps.token.tk == tk_plus || ps.token.tk == tk_minus))
	{
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		switch (ps.token.tk) {
		case tk_plus:
			binary_operator->function_name = "__plus__";
			break;
		case tk_minus:
			binary_operator->function_name = "__minus__";
			break;
		default:
			assert(false);
			break;
		}

		eat_token();

		auto rhs = times_expr_parse(ps);
		binary_operator->lhs = expr;
		binary_operator->rhs = rhs;
		expr = binary_operator;
	}

	return expr;
}

ptr<expression_t> shift_expr_parse(parse_state_t &ps) {
	auto expr = plus_expr_parse(ps);

	while (!ps.line_broke() &&
		   	(ps.token.tk == tk_shift_left || ps.token.tk == tk_shift_right))
	{
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		switch (ps.token.tk) {
		case tk_shift_left:
			binary_operator->function_name = "__shl__";
			break;
		case tk_shift_right:
			binary_operator->function_name = "__shr__";
			break;
		default:
			assert(false);
			break;
		}

		eat_token();

		auto rhs = plus_expr_parse(ps);
		binary_operator->lhs = expr;
		binary_operator->rhs = rhs;
		expr = binary_operator;
	}

	return expr;
}

ptr<expression_t> binary_eq_expr_parse(parse_state_t &ps) {
	auto lhs = shift_expr_parse(ps);
	if (ps.line_broke()
			|| !(ps.token.tk == tk_binary_equal
				|| ps.token.tk == tk_binary_inequal))
	{
		/* there is no rhs */
		return lhs;
	}

	auto binary_operator = create<ast::binary_operator_t>(ps.token);
	switch (ps.token.tk) {
	case tk_binary_equal:
		binary_operator->function_name = "__binary_eq__";
		break;
	case tk_binary_inequal:
		binary_operator->function_name = "__binary_ineq__";
		break;
	default:
		assert(false);
		break;
	}

	eat_token();

	auto rhs = shift_expr_parse(ps);
	binary_operator->lhs = std::move(lhs);
	binary_operator->rhs = std::move(rhs);
	return std::move(binary_operator);
}

ptr<expression_t> ineq_expr_parse(parse_state_t &ps) {
	auto lhs = binary_eq_expr_parse(ps);
	if (ps.line_broke()
			|| !(ps.token.tk == tk_gt
				|| ps.token.tk == tk_gte
				|| ps.token.tk == tk_lt
				|| ps.token.tk == tk_lte)) {
		/* there is no rhs */
		return lhs;
	}

	auto binary_operator = create<ast::binary_operator_t>(ps.token);
	switch (ps.token.tk) {
	case tk_gt:
		binary_operator->function_name = "__gt__";
		break;
	case tk_gte:
		binary_operator->function_name = "__gte__";
		break;
	case tk_lt:
		binary_operator->function_name = "__lt__";
		break;
	case tk_lte:
		binary_operator->function_name = "__lte__";
		break;
	default:
		assert(false);
		break;
	}

	eat_token();

	auto rhs = binary_eq_expr_parse(ps);
	binary_operator->lhs = std::move(lhs);
	binary_operator->rhs = std::move(rhs);
	return std::move(binary_operator);
}

ptr<expression_t> eq_expr_parse(parse_state_t &ps) {
	auto lhs = ineq_expr_parse(ps);
	bool not_in = false;
	if (ps.token.is_ident(K(not))) {
		eat_token();
		expect_ident(K(in));
		not_in = true;
	}

	if (ps.line_broke() ||
			!(ps.token.is_ident(K(in))
				|| ps.token.tk == tk_equal
				|| ps.token.tk == tk_inequal)) {
		/* there is no rhs */
		return lhs;
	}

	auto binary_operator = create<ast::binary_operator_t>(ps.token);
	if (ps.token.is_ident(K(in))) {
		binary_operator->function_name = "__in__";
	} else if (ps.token.tk == tk_equal) {
		binary_operator->function_name = "__eq__";
	} else if (ps.token.tk == tk_inequal) {
		binary_operator->function_name = "__ineq__";
	} else {
		assert(false);
	}

	eat_token();

	if (not_in) {
		binary_operator->function_name = "__not_in__";
	}

	auto rhs = ineq_expr_parse(ps);
	binary_operator->lhs = lhs;
	binary_operator->rhs = rhs;
	return binary_operator;
}

ptr<expression_t> bitwise_and_parse(parse_state_t &ps) {
	auto expr = eq_expr_parse(ps);

	while (!ps.line_broke() && ps.token.tk == tk_ampersand) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		binary_operator->function_name = "__bitwise_and__";

		eat_token();

		auto rhs = eq_expr_parse(ps);
		binary_operator->lhs = expr;
		binary_operator->rhs = rhs;
		expr = binary_operator;
	}

	return expr;
}

ptr<expression_t> bitwise_xor_parse(parse_state_t &ps) {
	auto expr = bitwise_and_parse(ps);

	while (!ps.line_broke() && ps.token.tk == tk_hat) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		binary_operator->function_name = "__xor__";

		eat_token();

		auto rhs = bitwise_and_parse(ps);
		binary_operator->lhs = expr;
		binary_operator->rhs = rhs;
		expr = binary_operator;
	}
	return expr;
}

ptr<expression_t> bitwise_or_parse(parse_state_t &ps) {
	auto expr = bitwise_xor_parse(ps);

	while (!ps.line_broke() && ps.token.tk == tk_pipe) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		binary_operator->function_name = "__bitwise_or__";

		eat_token();

		auto rhs = bitwise_xor_parse(ps);
		binary_operator->lhs = expr;
		binary_operator->rhs = rhs;
		expr = binary_operator;
	}

	return expr;
}

ptr<expression_t> and_expr_t::parse(parse_state_t &ps) {
	auto expr = bitwise_or_parse(ps);

	while (!ps.line_broke() && (ps.token.is_ident(K(and)))) {
		auto and_expr = create<ast::and_expr_t>(ps.token);

		eat_token();

		auto rhs = bitwise_or_parse(ps);
		and_expr->lhs = expr;
		and_expr->rhs = rhs;
		expr = and_expr;
	}

	return expr;
}

ptr<expression_t> tuple_expr_t::parse(parse_state_t &ps) {
	auto start_token = ps.token;
	chomp_token(tk_lparen);
	auto expr = expression_t::parse(ps);
	if (ps.token.tk != tk_comma) {
		chomp_token(tk_rparen);
		return expr;
	} else {
		ps.advance();

		/* we've got a tuple */
		auto tuple_expr = create<ast::tuple_expr_t>(start_token);

		/* add the first value */
		tuple_expr->values.push_back(expr);

		/* now let's find the rest of the values */
		while (ps.token.tk != tk_rparen) {
			expr = expression_t::parse(ps);
			tuple_expr->values.push_back(expr);
			if (ps.token.tk == tk_comma) {
				eat_token();
			} else if (ps.token.tk != tk_rparen) {
				throw user_error(ps.token.location, 
						"unexpected token " c_id("%s") " in tuple. expected comma or right-paren",
						ps.token.text.c_str());
			}
			// continue and read the next parameter
		}
		chomp_token(tk_rparen);
		return tuple_expr;
	}
}

ptr<expression_t> or_expr_t::parse(parse_state_t &ps) {
	auto expr = and_expr_t::parse(ps);

	while (!ps.line_broke() && (ps.token.is_ident(K(or)))) {
		auto or_expr = create<ast::or_expr_t>(ps.token);

		eat_token();

		auto rhs = and_expr_t::parse(ps);
		or_expr->lhs = std::move(expr);
		or_expr->rhs = std::move(rhs);
		expr = std::move(or_expr);
	}

	return expr;
}

ptr<expression_t> ternary_expr_t::parse(parse_state_t &ps) {
	auto condition = or_expr_t::parse(ps);
	if (ps.token.tk == tk_maybe) {
		ps.advance();
		// TODO: handle a ?? b form

		auto truthy_expr = or_expr_t::parse(ps);
		expect_token(tk_colon);
		ps.advance();
		auto falsey_expr = expression_t::parse(ps);
		auto ternary = ast::create<ternary_expr_t>(condition->token);
		ternary->condition = condition;
		ternary->when_true = truthy_expr;
		ternary->when_false = falsey_expr;
		return ternary;
	} else {
		return condition;
	}
}

ptr<expression_t> expression_t::parse(parse_state_t &ps) {
	return ternary_expr_t::parse(ps);
}

ptr<statement_t> assignment_t::parse(parse_state_t &ps) {
	auto lhs = expression_t::parse(ps);

#define handle_assign(tk_, type) \
	if (!ps.line_broke() && ps.token.tk == tk_) { \
		auto assignment = create<type>(ps.token); \
		chomp_token(tk_); \
		auto rhs = expression_t::parse(ps); \
		assignment->lhs = std::move(lhs); \
		assignment->rhs = std::move(rhs); \
		return std::move(assignment); \
	}

	handle_assign(tk_assign, ast::assignment_t);
	handle_assign(tk_plus_eq, ast::plus_assignment_t);
	// handle_assign(tk_maybe_eq, ast::maybe_assignment_t);
	handle_assign(tk_minus_eq, ast::minus_assignment_t);
	handle_assign(tk_divide_by_eq, ast::divide_assignment_t);
	handle_assign(tk_times_eq, ast::times_assignment_t);
	handle_assign(tk_mod_eq, ast::mod_assignment_t);

	if (!ps.line_broke() && ps.token.tk == tk_becomes) {
		if (lhs->sk == sk_reference_expr) {
			auto var_decl = create<ast::var_decl_t>(lhs->token);
			var_decl->is_let_var = true;
			var_decl->type = type_variable(lhs->token.location);
			chomp_token(tk_becomes);
			auto initializer = expression_t::parse(ps);
			var_decl->initializer.swap(initializer);
			return var_decl;
		} else {
			throw user_error(ps.token.location, ":= may only come after a new symbol name");
		}
	} else {
		return lhs;
	}
}

ptr<param_list_decl_t> param_list_decl_t::parse(parse_state_t &ps) {
	/* reset the argument index */
	ps.argument_index = 0;

	auto param_list_decl = create<ast::param_list_decl_t>(ps.token);
	while (ps.token.tk != tk_rparen) {
		param_list_decl->params.push_back(var_decl_t::parse_param(ps));
		if (ps.token.tk == tk_comma) {
			eat_token();
		} else if (ps.token.tk != tk_rparen) {
			throw user_error(ps.token.location, "unexpected token in param_list_decl");
		}
	}
	return param_list_decl;
}

ptr<block_t> block_t::parse(parse_state_t &ps) {
	auto block = create<ast::block_t>(ps.token);
	chomp_token(tk_indent);
	if (ps.token.tk == tk_outdent) {
		throw user_error(block->token.location, "empty blocks are not allowed, sorry. use pass.");
	}

	while (ps.token.tk != tk_outdent) {
		assert(ps.token.tk != tk_none);
		while (ps.token.tk == tk_semicolon) {
			ps.advance();
		}
		if (!ps.line_broke()
				&& !(ps.prior_token.tk == tk_indent
					|| ps.prior_token.tk == tk_outdent)) {
			throw user_error(ps.token.location, "statements must be separated by a newline (or a semicolon)");
		}
		block->statements.push_back(statement_t::parse(ps));
	}

	expect_token(tk_outdent);
	ps.advance();
	return block;
}

ptr<if_block_t> if_block_t::parse(parse_state_t &ps) {
	auto if_block = create<ast::if_block_t>(ps.token);
	if (ps.token.is_ident(K(if)) || ps.token.is_ident(K(elif))) {
		ps.advance();
	} else {
		throw user_error(ps.token.location, "expected if or elif");
	}

	token_t condition_token = ps.token;
	auto expression = expression_t::parse(ps);
	if (auto condition = dyncast<const expression_t>(expression)) {
		if_block->condition = condition;
	} else if (auto var_decl = dyncast<const var_decl_t>(expression)) {
		if_block->condition = var_decl;
	} else {
		throw user_error(condition_token.location,
				"if conditions are limited to expressions or variable definitions");
	}

	if_block->block = block_t::parse(ps);

	if (ps.prior_token.tk == tk_outdent) {
		/* check the successive instructions for elif or else */
		if (ps.token.is_ident(K(elif))) {
			if_block->else_ = if_block_t::parse(ps);
		} else if (ps.token.is_ident(K(else))) {
			ps.advance();
			if_block->else_ = block_t::parse(ps);
		}
	}

	return if_block;
}

ptr<while_block_t> while_block_t::parse(parse_state_t &ps) {
	auto while_block = create<ast::while_block_t>(ps.token);
	chomp_ident(K(while));
	token_t condition_token = ps.token;
	auto expr = expression_t::parse(ps);
	if (auto condition = dyncast<const expression_t>(expr)) {
		while_block->condition = condition;
	} else if (auto var_decl = dyncast<const var_decl_t>(expr)) {
		while_block->condition = var_decl;
	} else {
		throw user_error(condition_token.location,
				"while conditions are limited to expressions or variable definitions");
	}

	auto block = block_t::parse(ps);
	while_block->block = block;
	return while_block;
}

ptr<for_block_t> for_block_t::parse(parse_state_t &ps) {
	auto for_block = create<ast::for_block_t>(ps.token);
	chomp_ident(K(for));
	expect_token(tk_identifier);
	for_block->var_token = ps.token;
	ps.advance();
	expect_ident(K(in));
	for_block->in_token = ps.token;
	ps.advance();
	for_block->iterable = expression_t::parse(ps);
	for_block->block = block_t::parse(ps);
	return for_block;
}

ast::predicate_t::ref ctor_predicate_t::parse(parse_state_t &ps) {
	assert(ps.token.tk == tk_identifier && isupper(ps.token.text[0]));
	auto value_name = ps.token;

	ps.advance();
	
	std::vector<predicate_t::ref> params;
	if (ps.token.tk == tk_lparen) {
		ps.advance();
		bool expect_comma = false;
		while (ps.token.tk != tk_rparen) {
			if (expect_comma) {
				chomp_token(tk_comma);
			}

			auto predicate = predicate_t::parse(ps, false /*allow_else*/);
			params.push_back(predicate);
			expect_comma = true;
		}
		chomp_token(tk_rparen);
	}
	auto ctor = ast::create<ast::ctor_predicate_t>(value_name);
	std::swap(ctor->params, params);
	return ctor;
}

ast::predicate_t::ref predicate_t::parse(parse_state_t &ps, bool allow_else) {
	if (!allow_else && ps.token.is_ident(K(else))) {
		throw user_error(ps.token.location, "illegal keyword " c_type("%s") " in a pattern match context",
				ps.token.text.c_str());
	}

	if (ps.token.tk == tk_identifier) {
		if (isupper(ps.token.text[0])) {
			/* match a ctor */
			return ctor_predicate_t::parse(ps);
		} else {
			/* match anything */
			auto symbol = ps.token;
			ps.advance();
			return ast::create<ast::irrefutable_predicate_t>(symbol);
		}
	} else {
		switch (ps.token.tk) {
		case tk_integer:
		case tk_string:
		case tk_char:
		case tk_float:
			{
				/* match a literal */
				auto literal = create<ast::literal_expr_t>(ps.token);
				ps.advance();
				return literal;
			}
		default:
			throw user_error(ps.token.location, "unexpected token for pattern " c_warn("%s"),
					ps.token.text.c_str());
		}
		null_impl();
	}
}

ast::pattern_block_t::ref pattern_block_t::parse(parse_state_t &ps) {
	auto is_token = ps.token;

	auto pattern_block = ast::create<ast::pattern_block_t>(is_token);

	pattern_block->predicate = predicate_t::parse(ps, true /*allow_else*/);
	pattern_block->block = block_t::parse(ps);
	return pattern_block;
}

ptr<when_block_t> when_block_t::parse(parse_state_t &ps) {
	auto when_block = create<ast::when_block_t>(ps.token);
	chomp_ident(K(when));
	when_block->value = expression_t::parse(ps);
	chomp_ident(K(is));
	chomp_token(tk_indent);
	while (ps.token.tk != tk_outdent) {
		when_block->pattern_blocks.push_back(pattern_block_t::parse(ps));
	}
	chomp_token(tk_outdent);

	if (when_block->pattern_blocks.size() == 0) {
		throw user_error(ps.token.location, "when block did not have subsequent patterns to match");
	}

	return when_block;
}

ptr<function_decl_t> function_decl_t::parse(parse_state_t &ps, bool within_expression) {
	location_t attributes_location;
	identifier::ref extends_module;

	if (ps.token.tk == tk_lsquare) {
		if (within_expression) {
			throw user_error(ps.token.location, "attributes are not supported within function expression forms");
		}

		attributes_location = ps.token.location;
		ps.advance();
		if (ps.token.is_ident(K(global))) {
			extends_module = make_iid_impl(GLOBAL_SCOPE_NAME, ps.token.location);
			ps.advance();
			chomp_token(tk_rsquare);
		} else if (ps.token.is_ident(K(module))) {
			ps.advance();
			expect_token(tk_identifier);
			extends_module = make_code_id(ps.token);
			ps.advance();
			chomp_token(tk_rsquare);
		} else {
			throw user_error(ps.token.location, "expected module injection");
		}
	}

	expect_ident(K(def));
	location_t location = ps.token.location;

	identifier::ref function_name;
	auto parsed_type = types::parse_function_type(ps, {}, function_name);
	debug_above(6, log("parsed function type %s", parsed_type->str().c_str()));
	types::type_function_t::ref function_type = dyncast<const types::type_function_t>(parsed_type);
	assert_implies(!within_expression, function_type != nullptr);

	std::string name;
	if (function_name != nullptr) {
		name = function_name->get_name();
	} else if (!within_expression) {
		throw user_error(function_type->get_location(), "function is missing a name");
	}

	if (name == "main") {
		if (extends_module == nullptr) {
			extends_module = make_iid_impl(GLOBAL_SCOPE_NAME, ps.token.location);
		} else {
			throw user_error(attributes_location,
					"the main function may not specify a scope injection module");
		}
	}

	if (name == "__finalize__") {
		if (auto args = dyncast<const types::type_args_t>(function_type->args)) {
			if (args->args.size() != 1) {
				throw user_error(function_name->get_location(),
						"finalizers must only take one parameter");
			}
		} else {
			panic("we should have a type_args_t here");
		}

		if (!types::is_type_id(function_type->return_type, VOID_TYPE, nullptr)) {
			throw user_error(function_name->get_location(),
					"finalizers must return " c_type("void"));
		}
	}

	auto name_token = 
		function_name != nullptr
		? token_t(
				function_name->get_location(),
				tk_identifier,
				name)
		: token_t(
				parsed_type->get_location(),
				tk_identifier,
				"");

	auto function_decl = create<ast::function_decl_t>(name_token);
	function_decl->function_type = parsed_type;
	function_decl->extends_module = extends_module;
	function_decl->link_to_name = name_token;
	return function_decl;
}

ptr<function_defn_t> function_defn_t::parse(parse_state_t &ps, bool within_expression) {
	auto function_decl = function_decl_t::parse(ps, within_expression);

	assert(function_decl != nullptr);
	type_macros_restorer_t type_macros_restorer(ps.type_macros);

	/* temporarily inject free type variables from function declaration into the function parsing context.
	 * T -> any T parser macros. */
	for (auto ftv : function_decl->function_type->get_ftvs()) {
		ps.type_macros[ftv] = type_variable(
				make_iid_impl(ftv,
					function_decl->function_type->get_location()));
	}

	auto function_defn = create<ast::function_defn_t>(function_decl->token);
	function_defn->decl = function_decl;
	function_defn->block = block_t::parse(ps);
	return function_defn;
}

ptr<module_decl_t> module_decl_t::parse(parse_state_t &ps, bool skip_module_token) {
	bool global = false;
	if (!skip_module_token) {
		if (ps.token.is_ident(K(global))) {
			global = true;
			ps.advance();
		} else {
			chomp_ident(K(module));
		}
	}

	/* we've skipped the check for the 'module' token */
	auto module_decl = create<ast::module_decl_t>(ps.token);
	module_decl->global = global;

	if (!global) {
		expect_token(tk_identifier);
		module_decl->name = ps.token;
		eat_token();
	}

	if (ps.token.tk == tk_version) {
		auto semver = semver_t::parse(ps);
		if (semver) {
			module_decl->semver.swap(semver);
		} else {
			/* ok for now */
		}
	}
	return module_decl;
}

ptr<semver_t> semver_t::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_version) {
		auto semver = create<ast::semver_t>(ps.token);
		eat_token();
		return semver;
	} else {
		return nullptr;
	}
}

void parse_maybe_type_decl(parse_state_t &ps, identifier::refs &type_variables) {
	while (!ps.line_broke() && ps.token.tk == tk_identifier) {
		if (token_is_illegal_in_type(ps.token)) {
			if (ps.token.is_ident(K(any))) {
				throw user_error(ps.token.location, "`any` is unnecessary within type parameters of type declarations");
			}

			break;
		}

		/* we found a type variable, let's stash it */
		type_variables.push_back(make_code_id(ps.token));
		ps.advance();
	}
}

identifier::ref make_code_id(const token_t &token) {
	return make_ptr<code_id>(token);
}

identifier::ref make_type_id_code_id(const location_t location, std::string var_name) {
	return make_ptr<type_id_code_id>(location, var_name);
}

type_decl_t::ref type_decl_t::parse(parse_state_t &ps, token_t name_token) {
	identifier::refs type_variables;
	parse_maybe_type_decl(ps, type_variables);

	return create<ast::type_decl_t>(name_token, type_variables);
}

ptr<type_def_t> type_def_t::parse(parse_state_t &ps) {
	chomp_ident(K(type));
	expect_token(tk_identifier);
	auto type_name_token = ps.token;
	ps.advance();

	auto type_def = create<ast::type_def_t>(type_name_token);
	type_def->type_decl = type_decl_t::parse(ps, type_name_token);
	type_def->type_algebra = ast::type_algebra_t::parse(ps, type_def->type_decl);
	return type_def;
}

type_algebra_t::ref type_algebra_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl)
{
    indent_logger indent(type_decl->token.location, 8, string_format("parsing type algebra for %s",
                type_decl->token.text.c_str()));

	if (ps.token.is_ident(K(is))) {
		return data_type_t::parse(ps, type_decl, type_decl->type_variables);
	} else if (ps.token.is_ident(K(has))) {
		return type_product_t::parse(ps, type_decl, type_decl->type_variables, false /*native*/);
	} else if (ps.token.is_ident(K(link))) {
		return type_link_t::parse(ps, type_decl, type_decl->type_variables);
	} else if (ps.token.tk == tk_assign) {
		return type_alias_t::parse(ps, type_decl, type_decl->type_variables);
	} else if (ps.token.is_ident(K(struct))) {
		return type_product_t::parse(ps, type_decl, type_decl->type_variables, true /*native*/);
	} else {
		throw user_error(ps.token.location, 
				"type descriptions must begin with "
			   	c_id("is") ", " c_id("has") ", or " c_id("=") ". (Found %s)",
				ps.token.str().c_str());
	}
}

std::pair<token_t, types::type_args_t::ref> parse_ctor(
		parse_state_t &ps,
	   	identifier::refs type_variables_list)
{
	expect_token(tk_identifier);
	auto name = ps.token;
	if (!isupper(name.text[0])) {
		throw user_error(name.location, "constructors first letter must be uppercase");
	}

	ps.advance();
	return {name, types::parse_data_ctor_type(ps, to_set(type_variables_list))};
}

data_type_t::ref data_type_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
		identifier::refs type_variables_list)
{
	identifier::set type_variables = to_set(type_variables_list);
	auto is_token = ps.token;
	chomp_ident(K(is));
	bool expect_outdent = false;
	if (ps.token.tk == tk_indent) {
		/* take note of whether the user has indented or not */
		expect_outdent = true;
		ps.advance();
	}

	auto data_type = create<data_type_t>(type_decl->token);
	while (ps.token.tk == tk_identifier && (!expect_outdent ? !ps.line_broke() : true)) {
		auto ctor_pair = parse_ctor(ps, type_variables_list);
		for (auto x : data_type->ctor_pairs) {
			if (x.first.text == ctor_pair.first.text) {
				auto error = user_error(ctor_pair.first.location, "duplicated data constructor name");
				error.add_info(x.first.location, "see initial declaration here");
				throw error;
			}
		}
		debug_above(8, log("parsed ctor %s for type " c_type("%s"), ctor_pair.first.str().c_str(), data_type->token.text.c_str()));
		data_type->ctor_pairs.push_back(ctor_pair);
	}

	if (expect_outdent) {
		chomp_token(tk_outdent);
	}

	return data_type;
}

type_product_t::ref type_product_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
	   	identifier::refs type_variables,
		bool native)
{
	identifier::set generics = to_identifier_set(type_variables);
	if (native) {
		expect_ident(K(struct));
	} else {
		expect_ident(K(has));
	}
	auto type = types::parse_product_type(ps, generics);
	return create<type_product_t>(type_decl->token, native, type, generics);
}

type_link_t::ref type_link_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
		identifier::refs type_variables)
{
	identifier::set generics = to_identifier_set(type_variables);
	chomp_ident(K(link));
	return create<type_link_t>(type_decl->token);

}

type_alias_t::ref type_alias_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
	   	identifier::refs type_variables)
{
	chomp_token(tk_assign);

	identifier::set generics = to_identifier_set(type_variables);
	types::type_t::ref type = types::parse_type(ps, generics);

	auto type_alias = ast::create<ast::type_alias_t>(type_decl->token);
	assert(type_alias->token.text != "");

	type_alias->type = type;
	type_alias->type_variables = generics;
	return type_alias;
}

dimension_t::ref dimension_t::parse(parse_state_t &ps, identifier::set generics) {
	token_t primary_token;
	std::string name;
	if (ps.token.is_ident(K(var))) {
		ps.advance();
		expect_token(tk_identifier);
		primary_token = ps.token;
		name = primary_token.text;
		ps.advance();
	} else {
		throw user_error(ps.token.location, "not sure what's going on here");
	}

	types::type_t::ref type = types::parse_type(ps, generics);
	return ast::create<ast::dimension_t>(primary_token, name, type);
}

void add_type_macros_to_parser(
		parse_state_t &ps,
		std::vector<ptr<const ast::link_name_t>> linked_names)
{
	std::set<std::string> names_seen;
	for (auto link_name : linked_names) {
		std::string local_name = {link_name->local_name.text};
		if (in(local_name, ps.type_macros)) {
			throw user_error(link_name->local_name.location,
					"you may not import multiple instances of the same name: " c_id("%s"),
					link_name->local_name.text.c_str());
		}

		std::list<identifier::ref> ids;
		ids.push_back(make_code_id(link_name->extern_module->get_name()));
		ids.push_back(make_code_id(link_name->remote_name));
		auto type_macro_expansion = type_id(types::reduce_ids(ids, link_name->remote_name.location));

		debug_above(4, log("creating type macro " c_id("%s") " => %s",
					local_name.c_str(),
					type_macro_expansion->str().c_str()));
		ps.type_macros.insert({local_name, type_macro_expansion});
	}
}

ptr<module_t> module_t::parse(parse_state_t &ps) {
	debug_above(6, log("about to parse %s with type_macros: [%s]",
				ps.filename.c_str(),
				join_with(ps.type_macros, ", ", [] (type_macros_t::value_type v) -> std::string {
					return v.first + ": " + v.second->str();
					}).c_str()));

	auto module_decl = module_decl_t::parse(ps);

	assert(module_decl != nullptr);
	std::string module_name = strip_zion_extension(ps.filename);
	ps.module_id = make_iid(module_decl->get_canonical_name());
	assert(ps.module_id != nullptr);

	auto module = create<ast::module_t>(module_decl->token, ps.filename, module_decl->global);
	module->decl.swap(module_decl);

	while (ps.token.is_ident(K(get))) {
		auto get_statement = get_statement_parse(ps);
		if (auto linked_module = dyncast<link_module_statement_t>(get_statement)) {
			module->linked_modules.push_back(linked_module);
		}
	}
	// Get links
	while (ps.token.is_ident(K(link))) {
		auto link_statement = link_statement_parse(ps);
		if (auto linked_function = dyncast<link_function_statement_t>(link_statement)) {
			module->linked_functions.push_back(linked_function);
		} else if (auto linked_var = dyncast<link_var_statement_t>(link_statement)) {
			module->linked_vars.push_back(linked_var);
		} else if (auto linked_name = dyncast<link_name_t>(link_statement)) {
			module->linked_names.push_back(linked_name);
		}
	}

	/* TODO: update the parser to contain the type maps from the link_names */
	add_type_macros_to_parser(ps, module->linked_names);

	/* Get vars, functions or type defs */
	while (true) {
		if (ps.token.is_ident(K(var)) || ps.token.is_ident(K(let))) {
			bool is_let = ps.token.is_ident(K(let));
			if (is_let) {
				throw user_error(ps.token.location, "let variables are not yet supported at the module level");
			} else {
				ps.advance();
				auto var = var_decl_t::parse(ps, is_let);
				module->var_decls.push_back(var);
			}
		} else if (ps.token.tk == tk_lsquare || ps.token.is_ident(K(def))) {
			/* function definitions */
			auto function = function_defn_t::parse(ps, false /*within_expression*/);
			if (function->token.text == "main") {
				bool have_linked_main = false;
				for (auto linked_module : module->linked_modules) {
					if (linked_module->token.text == "main") {
						have_linked_main = true;
						break;
					}
				}
				if (!have_linked_main) {
					ptr<link_module_statement_t> linked_module = create<link_module_statement_t>(ps.token);
					linked_module->link_as_name = token_t(
							function->decl->token.location,
							tk_identifier,
							types::gensym()->get_name());
					linked_module->extern_module = create<ast::module_decl_t>(token_t(
								function->decl->token.location,
								tk_identifier,
								"main"));
					linked_module->extern_module->name = linked_module->extern_module->token;
					module->linked_modules.push_back(linked_module);
				}
			}
			module->functions.push_back(std::move(function));
		} else if (ps.token.is_ident(K(type))) {
			/* type definitions */
			auto type_def = type_def_t::parse(ps);
			module->type_defs.push_back(type_def);
			if (module->global) {
				auto id = make_code_id(type_def->token);
				ps.type_macros.insert({type_def->token.text, type_id(id)});
				ps.global_type_macros.insert({type_def->token.text, type_id(id)});
			}
		} else {
			break;
		}
	}

	if (ps.token.is_ident(K(link))) {
		throw user_error(ps.token.location, C_MODULE "link" C_RESET " directives must come before types, variables, and functions");
	} else if (ps.token.tk != tk_none) {
		throw user_error(ps.token.location, "unexpected '" c_id("%s") "' at top-level module scope (%s)",
				ps.token.text.c_str(), tkstr(ps.token.tk));
	}

	return module;
}
