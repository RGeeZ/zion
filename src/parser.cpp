#include <stdlib.h>
#include <string>
#include <iostream>
#include "logger.h"
#include "ast.h"
#include "token.h"
#include "logger_decls.h"
#include "compiler.h"
#include <csignal>
#include "parse_state.h"
#include "parser.h"
#include "code_id.h"
#include "type_parser.h"

using namespace ast;


bool token_begins_type(const token_t &token) {
	switch (token.tk) {
	case tk_integer:
	case tk_string:
	case tk_times:
	case tk_lsquare:
	case tk_lcurly:
	case tk_identifier:
		return true;
	default:
		return false;
	};
}

ptr<var_decl_t> var_decl_t::parse(parse_state_t &ps, bool is_let) {
	expect_token(tk_identifier);

	auto var_decl = create<ast::var_decl_t>(ps.token);
	var_decl->is_let_var = is_let;
	eat_token();

	if (ps.token.tk != tk_assign) {
		var_decl->type = types::parse_type(ps, {} /*generics*/);
	} else {
		var_decl->type = type_variable(ps.prior_token.location);
	}

	if (!!ps.status) {
		if (ps.token.tk == tk_assign) {
			eat_token();
			var_decl->initializer = expression_t::parse(ps);
		}

		return var_decl;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<var_decl_t> var_decl_t::parse_param(parse_state_t &ps) {
	expect_token(tk_identifier);

	auto var_decl = create<ast::var_decl_t>(ps.token);
	eat_token();

	if (ps.token.tk == tk_assign) {
		ps.error("default values for function arguments are not a thing");
		return nullptr;
	} else if (ps.token.tk == tk_comma || ps.token.tk == tk_rparen) {
		/* ok, let's inject an autogenerated token */
		var_decl->type = type_variable(ps.token.location);
	} else {
		var_decl->type = types::parse_type(ps, {});
	}

	return var_decl;
}

ptr<return_statement_t> return_statement_t::parse(parse_state_t &ps) {
	auto return_statement = create<ast::return_statement_t>(ps.token);
	chomp_ident(K(return));
	if (!ps.line_broke() && ps.token.tk != tk_outdent) {
		return_statement->expr = expression_t::parse(ps);
		if (!return_statement->expr) {
			assert(!ps.status);
			return nullptr;
		}
	}
	return return_statement;
}

ptr<unreachable_t> unreachable_t::parse(parse_state_t &ps) {
	auto unreachable = create<ast::unreachable_t>(ps.token);
	chomp_ident(K(__unreachable__));
	return unreachable;
}

ptr<statement_t> get_statement_parse(parse_state_t &ps) {
	expect_ident(K(get));
	auto get_token = ps.token;
	ps.advance();

	auto module_decl = module_decl_t::parse(ps, true /*skip_module_token*/);
	if (!!ps.status) {
		auto link_statement = create<link_module_statement_t>(get_token);
		link_statement->extern_module = module_decl;

		if (ps.token.is_ident(K(as))) {
			/* get the local name for this module */
			ps.advance();
			expect_token(tk_identifier);
			link_statement->link_as_name = ps.token;
			ps.advance();
		}

		if (link_statement->link_as_name.tk == tk_none) {
			link_statement->link_as_name = module_decl->get_name();
		}

		if (link_statement->link_as_name.tk != tk_identifier) {
			ps.error("expected an identifier for link module name (either implicit or explicit)");
		}

		if (!!ps.status) {
			return link_statement;
		}
	}
	assert(!ps.status);
	return nullptr;
}

ptr<statement_t> link_statement_parse(parse_state_t &ps) {
	expect_ident(K(link));
	auto link_token = ps.token;
	ps.advance();

	if (ps.token.tk == tk_lsquare || ps.token.is_ident(K(def))) {
		auto link_function_statement = create<ast::link_function_statement_t>(link_token);
		auto function_decl = function_decl_t::parse(ps);
		if (function_decl) {
			if (ps.token.is_ident(K(to))) {
				ps.advance();
				if (ps.token.tk != tk_identifier && ps.token.tk != tk_string) {
					ps.error("expected an identifier (or string) for the external name of the linked function (not %s)",
							ps.token.str().c_str());
				}
				if (!!ps.status) {
					expect_token(tk_identifier);
					function_decl->link_to_name = ps.token;
					ps.advance();
				}
			}
			link_function_statement->extern_function = function_decl;
		} else {
			assert(!ps.status);
		}

		if (!!ps.status) {
			return link_function_statement;
		}
	} else if (ps.token.is_ident(K(var))) {
		ps.advance();
		// REVIEW: does it make sense to handle 'let' in this context?
		auto var_decl = var_decl_t::parse(ps, false /* is_let */);
		if (!!ps.status) {
			auto link_var = create<link_var_statement_t>(link_token);
			link_var->var_decl = var_decl;
			return link_var;
		}
	} else if (ps.token.is_ident(K(in))) {
		ps.advance();
		expect_token(tk_string);
		if (ps.link_ins != nullptr) {
			ps.link_ins->insert(ps.token);
		}
		ps.advance();
		return nullptr;
	} else if (ps.token.tk == tk_identifier) {
		/*
		 * link name to some_module.something
		 *
		 * 1. Sets up a type parser macro "name" => "some_module.something"
		 * 2. Sets up a "scope link" from this module to the "some_module" for the
		 * "something" name so that if there is a call to "something" from
		 * within this module, we also search "some_module" when enumerating
		 * callables.
		 * 3. Start tracking whether the link is in use in the module
		 */
		auto name_token = ps.token;
		ps.advance();
		chomp_ident(K(to));

		auto link_name = create<ast::link_name_t>(link_token);
		link_name->local_name = name_token;
		link_name->extern_module = module_decl_t::parse(ps, true /* skip_module_token */);

		if (!!ps.status) {
			chomp_token(tk_dot);
			expect_token(tk_identifier);
			link_name->remote_name = ps.token;
			ps.advance();
			return link_name;
		}
	} else {
		ps.error("invalid link syntax (TODO: make this error better)");
	}

	assert(!ps.status);
	return nullptr;
}

ptr<statement_t> statement_t::parse(parse_state_t &ps) {
	assert(ps.token.tk != tk_outdent);

	if (ps.token.is_ident(K(var))) {
		ps.advance();
		return var_decl_t::parse(ps, false /*is_let*/);
	} else if (ps.token.is_ident(K(let))) {
		ps.advance();
		return var_decl_t::parse(ps, true /*is_let*/);
	} else if (ps.token.is_ident(K(if))) {
		return if_block_t::parse(ps);
	} else if (ps.token.is_ident(K(while))) {
		return while_block_t::parse(ps);
	} else if (ps.token.is_ident(K(for))) {
		return for_block_t::parse(ps);
	} else if (ps.token.is_ident(K(when))) {
		return when_block_t::parse(ps);
	} else if (ps.token.is_ident(K(return))) {
		return return_statement_t::parse(ps);
	} else if (ps.token.is_ident(K(__unreachable__))) {
		return unreachable_t::parse(ps);
	} else if (ps.token.is_ident(K(type))) {
		return type_def_t::parse(ps);
	} else if (ps.token.is_ident(K(pass))) {
		auto pass_flow = create<ast::pass_flow_t>(ps.token);
		eat_token();
		return std::move(pass_flow);
	} else if (ps.token.is_ident(K(continue))) {
		auto continue_flow = create<ast::continue_flow_t>(ps.token);
		eat_token();
		return std::move(continue_flow);
	} else if (ps.token.is_ident(K(def))) {
		return function_defn_t::parse(ps);
	} else if (ps.token.is_ident(K(break))) {
		auto break_flow = create<ast::break_flow_t>(ps.token);
		eat_token();
		return std::move(break_flow);
	} else {
		return assignment_t::parse(ps);
	}
}

ptr<expression_t> reference_expr_t::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_identifier) {
		if (ps.token.text == "null") {
			auto token = ps.token;
			ps.advance();
			return create<ast::literal_expr_t>(token);
		}
		auto reference_expr = create<ast::reference_expr_t>(ps.token);
		ps.advance();
		return std::move(reference_expr);
	} else {
		ps.error("expected an identifier");
		return nullptr;
	}
}

ptr<typeid_expr_t> typeid_expr_t::parse(parse_state_t &ps) {
	auto token = ps.token;
	chomp_ident(K(__get_typeid__));
	chomp_token(tk_lparen);

	auto value = expression_t::parse(ps);
	if (!!ps.status) {
		assert(value != nullptr);
		auto expr = ast::create<typeid_expr_t>(token, value);
		chomp_token(tk_rparen);
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<sizeof_expr_t> sizeof_expr_t::parse(parse_state_t &ps) {
	auto token = ps.token;
	chomp_ident(K(sizeof));
	chomp_token(tk_lparen);

	auto type = types::parse_type(ps, {});
	if (!!ps.status) {
		assert(type != nullptr);
		auto expr = ast::create<sizeof_expr_t>(token, type);
		chomp_token(tk_rparen);
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> parse_bang_wrap(parse_state_t &ps, ptr<expression_t> expr) {
    if (ps.token.tk == tk_bang) {
        auto bang = ast::create<ast::bang_expr_t>(ps.token);
        bang->lhs = expr;
        ps.advance();
        return bang;
    } else {
        return expr;
    }
}

ptr<expression_t> parse_cast_wrap(parse_state_t &ps, ptr<expression_t> expr) {
    if (ps.token.is_ident(K(as))) {
		auto token = ps.token;
		ps.advance();
		auto cast = ast::create<ast::cast_expr_t>(token);
		cast->lhs = expr;

		if (ps.token.tk == tk_bang) {
			ps.advance();
			cast->force_cast = true;
		}
		cast->type_cast = types::parse_type(ps, {});
        return cast;
    } else {
        return expr;
    }
}

ptr<expression_t> base_expr::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_lparen) {
		return tuple_expr_t::parse(ps);
	} else if (ps.token.is_ident(K(__get_typeid__))) {
		return typeid_expr_t::parse(ps);
	} else if (ps.token.is_ident(K(sizeof))) {
		return sizeof_expr_t::parse(ps);
	} else if (ps.token.tk == tk_identifier) {
		// NB: this is last to ensure "special" builtins are in play above
		return reference_expr_t::parse(ps);
	} else {
		return literal_expr_t::parse(ps);
	}
}

ptr<expression_t> array_literal_expr_t::parse(parse_state_t &ps) {
	chomp_token(tk_lsquare);
	auto array = create<array_literal_expr_t>(ps.token);
	auto &items = array->items;

	int i = 0;
	while (ps.token.tk != tk_rsquare && ps.token.tk != tk_none) {
		++i;
		auto item = expression_t::parse(ps);
		if (item) {
			items.push_back(item);
		} else {
			assert(!ps.status);
		}
		if (ps.token.tk == tk_comma) {
			ps.advance();
		} else if (ps.token.tk != tk_rsquare) {
			ps.error("found something that does not make sense in an array literal");
			break;
		}
	}
	chomp_token(tk_rsquare);
	return array;
}

ptr<expression_t> literal_expr_t::parse(parse_state_t &ps) {
	switch (ps.token.tk) {
	case tk_integer:
	case tk_string:
	case tk_char:
	case tk_float:
		{
			auto literal_expr = create<ast::literal_expr_t>(ps.token);
			ps.advance();
			return std::move(literal_expr);
		}
	case tk_lsquare:
		return array_literal_expr_t::parse(ps);
	// case tk_lcurly:
	//	return assoc_array_expr_t::parse(ps);
	case tk_indent:
		ps.error("unexpected indent");
		return nullptr;

	case tk_identifier:
		if (ps.token.is_ident(K(def))) {
			return function_defn_t::parse(ps);
		}
		ps.error("unexpected token found when parsing literal expression. '" c_error("%s") "'", ps.token.text.c_str());
		return nullptr;

	default:
		ps.error("out of place token found when parsing literal expression. '" c_error("%s") "' (%s)",
			   	ps.token.text.c_str(),
				tkstr(ps.token.tk));
		return nullptr;
	}
}

ptr<typeinfo_expr_t> typeinfo_expr_t::parse(parse_state_t &ps) {
	expect_token(tk_lparen);
	auto typeinfo_expr = ast::create<typeinfo_expr_t>(ps.prior_token);
	ps.advance();
	if (!!ps.status) {
		typeinfo_expr->type = types::parse_type(ps, {});
		if (!!ps.status) {
			chomp_token(tk_comma);

			typeinfo_expr->underlying_type = types::parse_type(ps, {});

			if (!!ps.status) {
				chomp_token(tk_comma);
				expect_token(tk_identifier);
				typeinfo_expr->finalize_function = ps.token;
				ps.advance();
				chomp_token(tk_comma);
				expect_token(tk_identifier);
				typeinfo_expr->mark_function = ps.token;
				ps.advance();
				chomp_token(tk_rparen);
				return typeinfo_expr;
			}
		}
	}

	assert(!ps.status);
	return nullptr;
}

std::vector<ptr<expression_t>> parse_param_list(parse_state_t &ps) {
	std::vector<ptr<expression_t>> params;
	chomp_token_or_return(tk_lparen, {});
	int i = 0;
	while (ps.token.tk != tk_rparen) {
		++i;
		auto expr = expression_t::parse(ps);
		if (expr) {
			params.push_back(std::move(expr));
			if (ps.token.tk == tk_comma) {
				eat_token();
			} else if (ps.token.tk != tk_rparen) {
				ps.error("unexpected %s in parameter list (" c_id("%s") ")", tkstr(ps.token.tk), ps.token.text.c_str());
				return {};
			}
			// continue and read the next parameter
		} else {
			assert(!ps.status);
			return {};
		}
	}
	chomp_token_or_return(tk_rparen, {});

	return params;
}

namespace ast {
	namespace postfix_expr {
		ptr<expression_t> parse(parse_state_t &ps) {
			ptr<expression_t> expr = base_expr::parse(ps);
			if (!expr) {
				assert(!ps.status);
				return nullptr;
			}

			while (!!ps.status &&
					!ps.line_broke() &&
					(ps.token.tk == tk_lsquare ||
					 ps.token.tk == tk_lparen ||
					 ps.token.tk == tk_dot))
			{
				if (ps.token.tk == tk_lparen) {
					auto ref_expr = dyncast<reference_expr_t>(expr);

					if (ref_expr != nullptr && ref_expr->token.text == "typeinfo") {
						/* override the typeinfo keyword */
						expr = typeinfo_expr_t::parse(ps);
					} else {
						/* function call */
						auto callsite = create<callsite_expr_t>(ps.token);
						callsite->params = parse_param_list(ps);
						if (!!ps.status) {
							callsite->function_expr.swap(expr);
							assert(expr == nullptr);
							expr = callsite;
						}
					}
				}

				if (!!ps.status) {
					if (ps.token.tk == tk_dot) {
						auto dot_expr = create<ast::dot_expr_t>(ps.token);
						eat_token();
						expect_token(tk_identifier);
						dot_expr->rhs = ps.token;
						ps.advance();
						dot_expr->lhs.swap(expr);
						assert(expr == nullptr);
						expr = dot_expr;
					}

					if (ps.token.tk == tk_lsquare) {
						eat_token();
						auto array_index_expr = create<ast::array_index_expr_t>(ps.token);

						auto index = expression_t::parse(ps);
						if (index) {
							array_index_expr->index.swap(index);
							array_index_expr->lhs.swap(expr);
							assert(expr == nullptr);
							expr = array_index_expr;
						} else {
							assert(!ps.status);
							return nullptr;
						}
						chomp_token(tk_rsquare);
					}
				}
			}

			if (!!ps.status) {
				expr = parse_bang_wrap(ps, expr);

				if (!!ps.status) {
					return expr;
				}
			}

			assert(!ps.status);
			return nullptr;
		}
	}
}

ptr<expression_t> prefix_expr_t::parse(parse_state_t &ps) {
	ptr<prefix_expr_t> prefix_expr;
	if (ps.token.tk == tk_ampersand
			|| ps.token.tk == tk_minus
			|| ps.token.tk == tk_plus
			|| ps.token.is_ident(K(not)))
	{
		prefix_expr = create<ast::prefix_expr_t>(ps.token);
		eat_token();
	}

	ptr<expression_t> rhs;
	if (ps.token.is_ident(K(not))
			|| ps.token.tk == tk_minus
			|| ps.token.tk == tk_plus) {
		/* recurse to find more prefix expressions */
		rhs = prefix_expr_t::parse(ps);
	} else {
		/* ok, we're done with prefix operators */
		rhs = postfix_expr::parse(ps);
	}

	if (rhs) {
		if (prefix_expr) {
			prefix_expr->rhs = std::move(rhs);
			return parse_cast_wrap(ps, prefix_expr);
		} else {
			return parse_cast_wrap(ps, rhs);
		}
	} else {
		assert(!ps.status);
		return nullptr;
	}
}


ptr<expression_t> times_expr_parse(parse_state_t &ps) {
	auto expr = prefix_expr_t::parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && (ps.token.tk == tk_times
			   	|| ps.token.tk == tk_divide_by
			   	|| ps.token.tk == tk_mod)) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		switch (ps.token.tk) {
		case tk_times:
			binary_operator->function_name = "__times__";
			break;
		case tk_divide_by:
			binary_operator->function_name = "__divide__";
			break;
		case tk_mod:
			binary_operator->function_name = "__mod__";
			break;
		default:
			assert(false);
			break;
		}

		eat_token();

		auto rhs = prefix_expr_t::parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	return expr;
}

ptr<expression_t> plus_expr_parse(parse_state_t &ps) {
	auto expr = times_expr_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() &&
		   	(ps.token.tk == tk_plus || ps.token.tk == tk_minus))
   	{
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		switch (ps.token.tk) {
		case tk_plus:
			binary_operator->function_name = "__plus__";
			break;
		case tk_minus:
			binary_operator->function_name = "__minus__";
			break;
		default:
			assert(false);
			break;
		}

		eat_token();

		auto rhs = times_expr_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	if (!!ps.status) {
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> shift_expr_parse(parse_state_t &ps) {
	auto expr = plus_expr_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() &&
		   	(ps.token.tk == tk_shift_left || ps.token.tk == tk_shift_right))
   	{
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		switch (ps.token.tk) {
		case tk_shift_left:
			binary_operator->function_name = "__shl__";
			break;
		case tk_shift_right:
			binary_operator->function_name = "__shr__";
			break;
		default:
			assert(false);
			break;
		}

		eat_token();

		auto rhs = plus_expr_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	if (!!ps.status) {
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> ineq_expr_parse(parse_state_t &ps) {
	auto lhs = shift_expr_parse(ps);
	if (lhs) {
		if (ps.line_broke()
				|| !(ps.token.tk == tk_gt
					|| ps.token.tk == tk_gte
					|| ps.token.tk == tk_lt
					|| ps.token.tk == tk_lte)) {
			/* there is no rhs */
			return lhs;
		}

		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		switch (ps.token.tk) {
		case tk_gt:
			binary_operator->function_name = "__gt__";
			break;
		case tk_gte:
			binary_operator->function_name = "__gte__";
			break;
		case tk_lt:
			binary_operator->function_name = "__lt__";
			break;
		case tk_lte:
			binary_operator->function_name = "__lte__";
			break;
		default:
			assert(false);
			break;
		}

		eat_token();

		auto rhs = shift_expr_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = std::move(lhs);
			binary_operator->rhs = std::move(rhs);
			return std::move(binary_operator);
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> eq_expr_parse(parse_state_t &ps) {
	auto lhs = ineq_expr_parse(ps);
	if (!!ps.status) {
		bool not_in = false;
		if (ps.token.is_ident(K(not))) {
			eat_token();
			expect_ident(K(in));
			not_in = true;
		}

		if (ps.line_broke() ||
				!(ps.token.is_ident(K(in))
					|| ps.token.tk == tk_equal
					|| ps.token.tk == tk_inequal
                    || ps.token.is_ident(K(is)))) {
			/* there is no rhs */
			return lhs;
		}

		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		if (ps.token.is_ident(K(in))) {
			binary_operator->function_name = "__in__";
		} else if (ps.token.tk == tk_equal) {
			binary_operator->function_name = "__eq__";
		} else if (ps.token.tk == tk_inequal) {
			binary_operator->function_name = "__ineq__";
		} else if (ps.token.is_ident(K(is))) {
			binary_operator->function_name = "__is__";
		} else {
			assert(false);
		}

		eat_token();

        if (ps.token.is_ident(K(not)) && binary_operator->token.is_ident(K(is))) {
			binary_operator->function_name = "__isnot__";
            ps.advance();
        } else if (not_in) {
			binary_operator->function_name = "__notin__";
		}

		auto rhs = ineq_expr_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = lhs;
			binary_operator->rhs = rhs;
			return binary_operator;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> bitwise_and_parse(parse_state_t &ps) {
	auto expr = eq_expr_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && ps.token.tk == tk_ampersand) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		binary_operator->function_name = "__bitwise_and__";

		eat_token();

		auto rhs = eq_expr_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	if (!!ps.status) {
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> bitwise_xor_parse(parse_state_t &ps) {
	auto expr = bitwise_and_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && ps.token.tk == tk_hat) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		binary_operator->function_name = "__xor__";

		eat_token();

		auto rhs = bitwise_and_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	if (!!ps.status) {
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> bitwise_or_parse(parse_state_t &ps) {
	auto expr = bitwise_xor_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && ps.token.tk == tk_pipe) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		binary_operator->function_name = "__bitwise_or__";

		eat_token();

		auto rhs = bitwise_xor_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	if (!!ps.status) {
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> and_expr_t::parse(parse_state_t &ps) {
	auto expr = bitwise_or_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && (ps.token.is_ident(K(and)))) {
		auto and_expr = create<ast::and_expr_t>(ps.token);

		eat_token();

		auto rhs = bitwise_or_parse(ps);
		if (!!ps.status) {
			and_expr->lhs = expr;
			and_expr->rhs = rhs;
			expr = and_expr;
		} else {
			ps.error("unable to parse right hand side of and_expr");
			return nullptr;
		}
	}

	return expr;
}

ptr<expression_t> tuple_expr_t::parse(parse_state_t &ps) {
	auto start_token = ps.token;
	chomp_token(tk_lparen);
	auto expr = expression_t::parse(ps);
	if (ps.token.tk != tk_comma) {
		chomp_token(tk_rparen);
		return expr;
	} else {
		ps.advance();

		/* we've got a tuple */
		auto tuple_expr = create<ast::tuple_expr_t>(start_token);

		/* add the first value */
		tuple_expr->values.push_back(expr);

		/* now let's find the rest of the values */
		while (ps.token.tk != tk_rparen) {
			expr = expression_t::parse(ps);
			if (expr) {
				tuple_expr->values.push_back(expr);
				if (ps.token.tk == tk_comma) {
					eat_token();
				} else if (ps.token.tk != tk_rparen) {
					ps.error(
						"unexpected token " c_id("%s") " in tuple. expected comma or right-paren",
						ps.token.text.c_str());
					return nullptr;
				}
				// continue and read the next parameter
			} else {
				assert(!ps.status);
				return nullptr;
			}
		}
		chomp_token(tk_rparen);
		return tuple_expr;
	}
}

ptr<expression_t> or_expr_t::parse(parse_state_t &ps) {
	auto expr = and_expr_t::parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && (ps.token.is_ident(K(or)))) {
		auto or_expr = create<ast::or_expr_t>(ps.token);

		eat_token();

		auto rhs = and_expr_t::parse(ps);
		if (rhs) {
			or_expr->lhs = std::move(expr);
			or_expr->rhs = std::move(rhs);
			expr = std::move(or_expr);
		} else {
			ps.error("unable to parse right hand side of or_expr");
			return nullptr;
		}
	}

	return expr;
}

ptr<expression_t> ternary_expr_t::parse(parse_state_t &ps) {
	auto condition = or_expr_t::parse(ps);
	if (!!ps.status) {
		if (ps.token.tk == tk_maybe) {
			ps.advance();
			// TODO: handle a ?? b form

			auto truthy_expr = or_expr_t::parse(ps);
			if (!!ps.status) {
				expect_token(tk_colon);
				ps.advance();
				auto falsey_expr = or_expr_t::parse(ps);
				if (!!ps.status) {
					auto ternary = ast::create<ternary_expr_t>(condition->token);
					ternary->condition = condition;
					ternary->when_true = truthy_expr;
					ternary->when_false = falsey_expr;
					return ternary;
				}
			}
		} else {
			return condition;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> expression_t::parse(parse_state_t &ps) {
	return ternary_expr_t::parse(ps);
}

ptr<statement_t> assignment_t::parse(parse_state_t &ps) {
	auto lhs = expression_t::parse(ps);
	if (lhs != nullptr) {

#define handle_assign(tk_, type) \
		if (!ps.line_broke() && ps.token.tk == tk_) { \
			auto assignment = create<type>(ps.token); \
			chomp_token(tk_); \
			auto rhs = expression_t::parse(ps); \
			if (rhs) { \
				assignment->lhs = std::move(lhs); \
				assignment->rhs = std::move(rhs); \
				return std::move(assignment); \
			} else { \
				assert(!ps.status); \
				return nullptr; \
			} \
		}

		handle_assign(tk_assign, ast::assignment_t);
		handle_assign(tk_plus_eq, ast::plus_assignment_t);
		// handle_assign(tk_maybe_eq, ast::maybe_assignment_t);
		handle_assign(tk_minus_eq, ast::minus_assignment_t);
		handle_assign(tk_divide_by_eq, ast::divide_assignment_t);
		handle_assign(tk_times_eq, ast::times_assignment_t);
		handle_assign(tk_mod_eq, ast::mod_assignment_t);

		if (!ps.line_broke() && ps.token.tk == tk_becomes) {
			if (lhs->sk == sk_reference_expr) {
				auto var_decl = create<ast::var_decl_t>(lhs->token);
				var_decl->type = type_variable(lhs->token.location);
				chomp_token(tk_becomes);
				auto initializer = expression_t::parse(ps);
				if (initializer) {
					var_decl->initializer.swap(initializer);
					return var_decl;
				} else {
					assert(!ps.status);
					return nullptr;
				}
			} else {
				ps.error(":= may only come after a new symbol name");
				return nullptr;
			}
		} else {
			return lhs;
		}
		return lhs;
	} else {
		assert(!ps.status);
	}

	return nullptr;
}

ptr<param_list_decl_t> param_list_decl_t::parse(parse_state_t &ps) {
	/* reset the argument index */
	ps.argument_index = 0;

	auto param_list_decl = create<ast::param_list_decl_t>(ps.token);
	while (ps.token.tk != tk_rparen) {
		param_list_decl->params.push_back(var_decl_t::parse_param(ps));
		if (ps.token.tk == tk_comma) {
			eat_token();
		} else if (ps.token.tk != tk_rparen) {
			ps.error("unexpected token in param_list_decl");
			return nullptr;
		}
	}
	return param_list_decl;
}

ptr<block_t> block_t::parse(parse_state_t &ps) {
	auto block = create<ast::block_t>(ps.token);
	chomp_token(tk_indent);
	if (ps.token.tk == tk_outdent) {
		user_error(ps.status, block->token.location, "empty blocks are not allowed, sorry. use pass.");
		return nullptr;
	}

	while (!!ps.status && ps.token.tk != tk_outdent) {
		assert(ps.token.tk != tk_none);
		while (ps.token.tk == tk_semicolon) {
			ps.advance();
		}
		if (!ps.line_broke()
				&& !(ps.prior_token.tk == tk_indent
					|| ps.prior_token.tk == tk_outdent)) {
			ps.error("statements must be separated by a newline (or a semicolon)");
		}
		auto statement = statement_t::parse(ps);
		if (statement) {
			block->statements.push_back(std::move(statement));
		} else {
			assert(!ps.status);
			return nullptr;
		}
	}

	expect_token(tk_outdent);
	ps.advance();
	return block;
}

ptr<if_block_t> if_block_t::parse(parse_state_t &ps) {
	auto if_block = create<ast::if_block_t>(ps.token);
	if (ps.token.is_ident(K(if)) || ps.token.is_ident(K(elif))) {
		ps.advance();
	} else {
		ps.error("expected if or elif");
		return nullptr;
	}

	token_t condition_token = ps.token;
	auto expression = expression_t::parse(ps);
	if (!!ps.status) {
		if (auto condition = dyncast<const expression_t>(expression)) {
			if_block->condition = condition;
		} else if (auto var_decl = dyncast<const var_decl_t>(expression)) {
			if_block->condition = var_decl;
		} else {
			user_error(ps.status, condition_token.location,
					"if conditions are limited to expressions or variable definitions");
		}

		if (!!ps.status) {
			auto block = block_t::parse(ps);
			if (!!ps.status) {
				if_block->block = block;

				if (ps.prior_token.tk == tk_outdent) {
					/* check the successive instructions for elif or else */
					if (ps.token.is_ident(K(elif))) {
						if_block->else_ = if_block_t::parse(ps);
					} else if (ps.token.is_ident(K(else))) {
						ps.advance();
						if_block->else_ = block_t::parse(ps);
					}
				}

				return if_block;
			} else {
				assert(!ps.status);
				return nullptr;
			}
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<while_block_t> while_block_t::parse(parse_state_t &ps) {
	auto while_block = create<ast::while_block_t>(ps.token);
	chomp_ident(K(while));
	token_t condition_token = ps.token;
	auto expr = expression_t::parse(ps);
	if (!!ps.status) {
		if (auto condition = dyncast<const expression_t>(expr)) {
			while_block->condition = condition;
		} else if (auto var_decl = dyncast<const var_decl_t>(expr)) {
			while_block->condition = var_decl;
		} else {
			user_error(ps.status, condition_token.location,
					"while conditions are limited to expressions or variable definitions");
		}

		auto block = block_t::parse(ps);
		if (!!ps.status) {
			while_block->block = block;
			return while_block;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<for_block_t> for_block_t::parse(parse_state_t &ps) {
	auto for_block = create<ast::for_block_t>(ps.token);
	chomp_ident(K(for));
	expect_token(tk_identifier);
	for_block->var_token = ps.token;
	ps.advance();
	expect_ident(K(in));
	for_block->in_token = ps.token;
	ps.advance();
	auto iterable = expression_t::parse(ps);
	if (!!ps.status) {
		for_block->iterable.swap(iterable);
		auto block = block_t::parse(ps);
		if (block != nullptr) {
			for_block->block.swap(block);
			return for_block;
		} else {
			assert(!ps.status);
			return nullptr;
		}
	}

	assert(!ps.status);
	return nullptr;
}

types::type_t::ref autoconvert_native_types(status_t &status, types::type_t::ref type) {
	if (type->is_zero()) {
		user_error(status, type->get_location(), "matching on zero is not possible");
	} else if (types::is_type_id(type, INT_TYPE)) {
		return type_id(make_iid_impl(MANAGED_INT, type->get_location()));
	} else if (types::is_type_id(type, FLOAT_TYPE)) {
		return type_id(make_iid_impl(MANAGED_FLOAT, type->get_location()));
	} else if (types::is_type_id(type, BOOL_TYPE)) {
		return type_id(make_iid_impl(MANAGED_BOOL, type->get_location()));
	} else if (types::is_type_id(type, TRUE_TYPE)) {
		return type_id(make_iid_impl(MANAGED_TRUE, type->get_location()));
	} else if (types::is_type_id(type, FALSE_TYPE)) {
		return type_id(make_iid_impl(MANAGED_FALSE, type->get_location()));
	} else {
		return type;
	}

	assert(!status);
	return nullptr;
}

ast::pattern_block_t::ref pattern_block_t::parse(parse_state_t &ps) {
	auto is_token = ps.token;
	chomp_ident(K(is));

	auto pattern_block = ast::create<ast::pattern_block_t>(is_token);
	auto pattern_type = types::parse_type(ps, {});

	if (!!ps.status) {
		pattern_block->type = autoconvert_native_types(ps.status, pattern_type);
		if (!!ps.status) {
			if (pattern_block->type->is_null()) {
				user_error(ps.status, is_token.location,
						"it is impossible to match null as a type-pattern since it has no runtime type information");
				user_info(ps.status, is_token.location,
						"check for null ahead of pattern matching");
			}

			if (!!ps.status) {
				auto block = block_t::parse(ps);
				if (block) {
					pattern_block->block.swap(block);
					return pattern_block;
				} else {
					assert(!ps.status);
					return nullptr;
				}
			}
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<when_block_t> when_block_t::parse(parse_state_t &ps) {
	auto when_block = create<ast::when_block_t>(ps.token);
	chomp_ident(K(when));
	auto value = expression_t::parse(ps);
	if (!!ps.status) {
		when_block->value.swap(value);

		/* this is a multi_pattern_block */
		chomp_token(tk_indent);
		while (ps.token.is_ident(K(is))) {
			auto pattern_block = pattern_block_t::parse(ps);
			if (!!ps.status) {
				when_block->pattern_blocks.push_back(pattern_block);
			}
		}

		if (ps.token.is_ident(K(else))) {
			ps.advance();
			when_block->else_block = block_t::parse(ps);
		}

		chomp_token(tk_outdent);

		if (when_block->pattern_blocks.size() == 0) {
			ps.error("when block did not have subsequent patterns to match");
		}

		return when_block;
	} else {
		assert(!ps.status);
		return nullptr;
	}
}

ptr<function_decl_t> function_decl_t::parse(parse_state_t &ps) {
	location_t attributes_location;
	identifier::ref extends_module;
	if (ps.token.tk == tk_lsquare) {
		attributes_location = ps.token.location;
		ps.advance();
		if (ps.token.is_ident(K(global))) {
			extends_module = make_iid_impl(GLOBAL_SCOPE_NAME, ps.token.location);
			ps.advance();
			chomp_token(tk_rsquare);
        } else if (ps.token.is_ident(K(module))) {
			ps.advance();
			expect_token(tk_identifier);
			extends_module = make_code_id(ps.token);
			ps.advance();
			chomp_token(tk_rsquare);
		} else {
			ps.error("expected inbound module declaration");
		}
	}

	if (!!ps.status) {
		expect_ident(K(def));
		auto parsed_type = types::parse_type(ps, {});
		if (!!ps.status) {
			debug_above(9, log("parsed type %s", parsed_type->str().c_str()));
			types::type_function_t::ref function_type = dyncast<const types::type_function_t>(parsed_type);
			assert(function_type != nullptr);
			std::string name;
			if (function_type->name == nullptr) {
				user_error(ps.status, function_type->get_location(), "function is missing a name");
			} else {
				name = function_type->name->get_name();
			}

			assert(name.size() != 0);

			if (!!ps.status) {
				if (name == "main") {
					if (extends_module == nullptr) {
						extends_module = make_iid_impl(GLOBAL_SCOPE_NAME, ps.token.location);
					} else {
						user_error(ps.status, attributes_location,
								"the main function may not specify an inbound context");
					}
				}

				if (name == "__finalize__") {
					if (auto args = dyncast<const types::type_args_t>(function_type->args)) {
						if (args->args.size() != 1) {
							user_error(ps.status, function_type->name->get_location(),
									"finalizers must only take one parameter");
						}
					} else {
						panic("we should have a type_args_t here");
					}

					if (!types::is_type_id(function_type->return_type, "void")) {
						user_error(ps.status, function_type->name->get_location(),
								"finalizers must return " c_type("void"));
					}
				}

				auto name_token = token_t(function_type->name->get_location(), tk_identifier, function_type->name->get_name());

				auto function_decl = create<ast::function_decl_t>(name_token);
				function_decl->function_type = function_type;
				function_decl->extends_module = extends_module;
				function_decl->link_to_name = name_token;
				return function_decl;
			}
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<function_defn_t> function_defn_t::parse(parse_state_t &ps) {
	auto function_decl = function_decl_t::parse(ps);

	if (!!ps.status) {
		assert(function_decl != nullptr);
		auto block = block_t::parse(ps);
		if (!!ps.status) {
			assert(block != nullptr);
			auto function_defn = create<ast::function_defn_t>(function_decl->token);
			function_defn->decl = function_decl;
			function_defn->block = block;
			return function_defn;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<module_decl_t> module_decl_t::parse(parse_state_t &ps, bool skip_module_token) {
	bool global = false;
	if (!skip_module_token) {
		if (ps.token.is_ident(K(global))) {
			global = true;
			ps.advance();
		} else {
			chomp_ident(K(module));
		}
	}

	/* we've skipped the check for the 'module' token */
	auto module_decl = create<ast::module_decl_t>(ps.token);
	module_decl->global = global;

	if (!global) {
		expect_token(tk_identifier);
		module_decl->name = ps.token;
		eat_token();
	}

	if (ps.token.tk == tk_version) {
		auto semver = semver_t::parse(ps);
		if (semver) {
			module_decl->semver.swap(semver);
		} else {
			/* ok for now */
		}
	}
	return module_decl;
}

ptr<semver_t> semver_t::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_version) {
		auto semver = create<ast::semver_t>(ps.token);
		eat_token();
		return semver;
	} else {
		return nullptr;
	}
}

void parse_maybe_type_decl(parse_state_t &ps, identifier::refs &type_variables) {
	if (!ps.line_broke() && ps.token.tk == tk_identifier) {
		while (!token_is_illegal_in_type(ps.token)) {
			if (ps.token.tk == tk_identifier) {
				/* we found a type variable, let's stash it */
				if (ps.token.is_ident(K(any))) {
					ps.error("`any` is unnecessary within type parameters of type declarations");
					break;
				}
				type_variables.push_back(make_code_id(ps.token));
				ps.advance();
				if (ps.line_broke()) {
					break;
				}
				continue;
			} else {
				break;
			}
		}
	}
}

identifier::ref make_code_id(const token_t &token) {
	return make_ptr<code_id>(token);
}

identifier::ref make_type_id_code_id(const location_t location, std::string var_name) {
	return make_ptr<type_id_code_id>(location, var_name);
}

type_decl_t::ref type_decl_t::parse(parse_state_t &ps, token_t name_token) {
	identifier::refs type_variables;
	parse_maybe_type_decl(ps, type_variables);

	if (!!ps.status) {
		return create<ast::type_decl_t>(name_token, type_variables);
	} else {
		return nullptr;
	}
}

ptr<type_def_t> type_def_t::parse(parse_state_t &ps) {
	chomp_ident(K(type));
	expect_token(tk_identifier);
	auto type_name_token = ps.token;
	ps.advance();

	auto type_def = create<ast::type_def_t>(type_name_token);
	type_def->type_decl = type_decl_t::parse(ps, type_name_token);
	if (!!ps.status) {
		type_def->type_algebra = ast::type_algebra_t::parse(ps, type_def->type_decl);
		if (!!ps.status) {
			return type_def;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<tag_t> tag_t::parse(parse_state_t &ps) {
	chomp_ident(K(tag));
	expect_token(tk_identifier);
	auto tag = create<ast::tag_t>(ps.token);
	ps.advance();

	parse_maybe_type_decl(ps, tag->type_variables);

	if (!!ps.status) {
		return tag;
	}

	assert(!ps.status);
	return nullptr;
}

type_algebra_t::ref type_algebra_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl)
{
	INDENT(8, string_format("parsing type algebra for %s",
				type_decl->token.text.c_str()));

	if (ps.token.is_ident(K(is))) {
		return type_sum_t::parse(ps, type_decl, type_decl->type_variables);
	} else if (ps.token.is_ident(K(has))) {
		return type_product_t::parse(ps, type_decl, type_decl->type_variables, false /*native*/);
	} else if (ps.token.is_ident(K(link))) {
		return type_link_t::parse(ps, type_decl, type_decl->type_variables);
	} else if (ps.token.tk == tk_assign) {
		return type_alias_t::parse(ps, type_decl, type_decl->type_variables);
	} else if (ps.token.is_ident(K(struct))) {
		return type_product_t::parse(ps, type_decl, type_decl->type_variables, true /*native*/);
	} else {
		ps.error(
				"type descriptions must begin with "
			   	c_id("is") ", " c_id("has") ", or " c_id("=") ". (Found %s)",
				ps.token.str().c_str());
		return nullptr;
	}
}

type_sum_t::ref type_sum_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
		identifier::refs type_variables_list)
{
	identifier::set type_variables = to_set(type_variables_list);
	auto is_token = ps.token;
	chomp_ident(K(is));
	bool expect_outdent = false;
	if (ps.token.tk == tk_indent) {
		/* take note of whether the user has indented or not */
		expect_outdent = true;
		ps.advance();
	}

	auto type = types::parse_type(ps, type_variables);

	if (!!ps.status) {
		if (expect_outdent) {
			if (ps.token.tk == tk_lparen) {
				ps.error("subtypes of a supertype must be separated by the '" c_type("or") "' keyword");
				return nullptr;
			} else {
				chomp_token(tk_outdent);
			}
		}

		return create<type_sum_t>(type_decl->token, type);
	} else {
		return nullptr;
	}
}

type_product_t::ref type_product_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
	   	identifier::refs type_variables,
		bool native)
{
	identifier::set generics = to_identifier_set(type_variables);
	if (native) {
		expect_ident(K(struct));
	} else {
		expect_ident(K(has));
	}
	auto type = types::parse_product_type(ps, generics);
	return create<type_product_t>(type_decl->token, native, type, generics);
}

type_link_t::ref type_link_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
		identifier::refs type_variables)
{
	identifier::set generics = to_identifier_set(type_variables);
	chomp_ident(K(link));
	return create<type_link_t>(type_decl->token);

}

type_alias_t::ref type_alias_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
	   	identifier::refs type_variables)
{
	chomp_token(tk_assign);

	identifier::set generics = to_identifier_set(type_variables);
	types::type_t::ref type = types::parse_type(ps, generics);

	if (!!ps.status) {
		auto type_alias = ast::create<ast::type_alias_t>(type_decl->token);
		type_alias->type = type;
		type_alias->type_variables = generics;
		return type_alias;
	}

	assert(!ps.status);
	return nullptr;
}

dimension_t::ref dimension_t::parse(parse_state_t &ps, identifier::set generics) {
	token_t primary_token;
	std::string name;
	if (ps.token.is_ident(K(var))) {
		ps.advance();
		expect_token(tk_identifier);
		primary_token = ps.token;
		name = primary_token.text;
		ps.advance();
	} else {
		ps.error("not sure what's going on here");
		wat();
		expect_token(tk_identifier);
		primary_token = ps.token;
	}

	types::type_t::ref type = types::parse_type(ps, generics);
	if (!!ps.status) {
		return ast::create<ast::dimension_t>(primary_token, name, type);
	}
	assert(!ps.status);
	return nullptr;
}

void add_type_macros_to_parser(
		parse_state_t &ps,
		std::vector<ptr<const ast::link_name_t>> linked_names)
{
	std::set<std::string> names_seen;
	for (auto link_name : linked_names) {
		std::string local_name = {link_name->local_name.text};
		if (in(local_name, ps.type_macros)) {
			user_error(ps.status, link_name->local_name.location,
					"you may not import multiple instances of the same name: " c_id("%s"),
					link_name->local_name.text.c_str());
		}

		std::list<identifier::ref> ids;
		ids.push_back(make_code_id(link_name->extern_module->get_name()));
		ids.push_back(make_code_id(link_name->remote_name));
		auto type_macro_expansion = type_id(types::reduce_ids(ids, link_name->remote_name.location));

		debug_above(4, log("creating type macro " c_id("%s") " => %s",
					local_name.c_str(),
					type_macro_expansion->str().c_str()));
		ps.type_macros.insert({local_name, type_macro_expansion});
	}
}

ptr<module_t> module_t::parse(parse_state_t &ps) {
	debug_above(6, log("about to parse %s with type_macros: [%s]",
				ps.filename.c_str(),
				join_with(ps.type_macros, ", ", [] (type_macros_t::value_type v) -> std::string {
					return v.first + ": " + v.second->str();
				}).c_str()));

	auto module_decl = module_decl_t::parse(ps);

	if (module_decl != nullptr) {
		std::string module_name = strip_zion_extension(ps.filename);
		ps.module_id = make_iid(module_decl->get_canonical_name());
		assert(ps.module_id != nullptr);

		auto module = create<ast::module_t>(module_decl->token, ps.filename, module_decl->global);
		module->decl.swap(module_decl);

		while (ps.token.is_ident(K(get))) {
			auto get_statement = get_statement_parse(ps);
			if (auto linked_module = dyncast<link_module_statement_t>(get_statement)) {
				module->linked_modules.push_back(linked_module);
			}
		}
		// Get links
		while (ps.token.is_ident(K(link))) {
			auto link_statement = link_statement_parse(ps);
			if (auto linked_function = dyncast<link_function_statement_t>(link_statement)) {
				module->linked_functions.push_back(linked_function);
			} else if (auto linked_var = dyncast<link_var_statement_t>(link_statement)) {
				module->linked_vars.push_back(linked_var);
			} else if (auto linked_name = dyncast<link_name_t>(link_statement)) {
				module->linked_names.push_back(linked_name);
			}
		}
		
		/* TODO: update the parser to contain the type maps from the link_names */
		add_type_macros_to_parser(ps, module->linked_names);

		/* Get vars, functions or type defs */
		while (!!ps.status) {
			if (ps.token.is_ident(K(var)) || ps.token.is_ident(K(let))) {
				bool is_let = ps.token.is_ident(K(let));
				if (is_let) {
					ps.error("let variables are not yet supported at the module level");
				} else {
					ps.advance();
					auto var = var_decl_t::parse(ps, is_let);
					if (!!ps.status) {
						module->var_decls.push_back(var);
					}
				}
			} else if (ps.token.tk == tk_lsquare || ps.token.is_ident(K(def))) {
				/* function definitions */
				auto function = function_defn_t::parse(ps);
				if (!!ps.status) {
					if (function->token.text == "main") {
						bool have_linked_main = false;
						for (auto linked_module : module->linked_modules) {
							if (linked_module->token.text == "main") {
								have_linked_main = true;
								break;
							}
						}
						if (!have_linked_main) {
							ptr<link_module_statement_t> linked_module = create<link_module_statement_t>(ps.token);
							linked_module->link_as_name = token_t(
									function->decl->token.location,
									tk_identifier,
									types::gensym()->get_name());
							linked_module->extern_module = create<ast::module_decl_t>(token_t(
										function->decl->token.location,
										tk_identifier,
										"main"));
							linked_module->extern_module->name = linked_module->extern_module->token;
							module->linked_modules.push_back(linked_module);
						}
					}
					module->functions.push_back(std::move(function));
				}
			} else if (ps.token.is_ident(K(tag))) {
				/* tags */
				auto tag = tag_t::parse(ps);
				if (!!ps.status && tag != nullptr) {
					module->tags.push_back(tag);
					if (module->global) {
						auto id = make_code_id(tag->token);
						ps.type_macros.insert({tag->token.text, type_id(id)});
						ps.global_type_macros.insert({tag->token.text, type_id(id)});
					}
				}
			} else if (ps.token.is_ident(K(type))) {
				/* type definitions */
				auto type_def = type_def_t::parse(ps);
				if (!!ps.status && type_def != nullptr) {
					module->type_defs.push_back(type_def);
					if (module->global) {
						auto id = make_code_id(type_def->token);
						ps.type_macros.insert({type_def->token.text, type_id(id)});
						ps.global_type_macros.insert({type_def->token.text, type_id(id)});
					}
				}
			} else {
				break;
			}
		}

		if (!!ps.status) {
			if (ps.token.is_ident(K(link))) {
				ps.error(C_MODULE "link" C_RESET " directives must come before types, variables, and functions");
			} else if (ps.token.tk != tk_none) {
				ps.error("unexpected '" c_id("%s") "' at top-level module scope (%s)",
						ps.token.text.c_str(), tkstr(ps.token.tk));
			}
		}

        if (!!ps.status) {
            return module;
        }
	}

    assert(!ps.status);
	return nullptr;
}
