#include <stdlib.h>
#include <string>
#include <iostream>
#include "logger.h"
#include "ast.h"
#include "token.h"
#include "logger_decls.h"
#include "compiler.h"
#include <csignal>
#include "parse_state.h"
#include "parser.h"
#include "code_id.h"

using namespace ast;


#define eat_token_or_return(fail_code) \
	do { \
		debug_lexer(log(log_info, "eating a %s", tkstr(ps.token.tk))); \
		ps.advance(); \
	} while (0)

#define eat_token() eat_token_or_return(nullptr)

#define expect_token_or_return(_tk, fail_code) \
	do { \
		if (ps.token.tk != _tk) { \
			ps.error("expected '%s', got '%s' " c_id("%s"), \
				   	tkstr(_tk), tkstr(ps.token.tk), ps.token.tk == tk_identifier ? ps.token.text.c_str() : ""); \
			dbg(); \
			return fail_code; \
		} \
	} while (0)

#define expect_token(_tk) expect_token_or_return(_tk, nullptr)

#define expect_ident_or_return(text_, fail_code) \
	do { \
		const char * const token_text = (text_); \
		expect_token_or_return(tk_identifier, fail_code); \
		if (ps.token.text != token_text) { \
			ps.error("expected '%s', got '%s'", \
					token_text, ps.token.text.c_str()); \
			dbg(); \
			return fail_code; \
		} \
	} while (0)

#define expect_ident(text_) expect_ident_or_return(text_, nullptr)

#define chomp_token_or_return(_tk, fail_code) \
	do { \
		expect_token_or_return(_tk, fail_code); \
		eat_token_or_return(fail_code); \
	} while (0)
#define chomp_token(_tk) chomp_token_or_return(_tk, nullptr)
#define chomp_ident_or_return(text_, fail_code) \
	do { \
		expect_ident_or_return(text_, fail_code); \
		eat_token_or_return(fail_code); \
	} while (0)
#define chomp_ident(text_) chomp_ident_or_return(text_, nullptr)

bool token_begins_type(const token_t &token) {
	switch (token.tk) {
	case tk_integer:
	case tk_string:
	case tk_times:
	case tk_lsquare:
	case tk_lcurly:
	case tk_identifier:
		return true;
	default:
		return false;
	};
}

ptr<var_decl_t> var_decl_t::parse(parse_state_t &ps, bool is_let) {
	expect_token(tk_identifier);

	auto var_decl = create<ast::var_decl_t>(ps.token);
	var_decl->is_let_var = is_let;
	eat_token();

	if (ps.token.tk != tk_assign) {
		var_decl->type = parse_maybe_type(ps, {}, {}, {} /*generics*/);
	} else {
		var_decl->type = type_variable(ps.prior_token.location);
	}

	if (!!ps.status) {
		if (ps.token.tk == tk_assign) {
			eat_token();
			var_decl->initializer = expression_t::parse(ps);
		}

		return var_decl;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<var_decl_t> var_decl_t::parse_param(parse_state_t &ps) {
	expect_token(tk_identifier);

	auto var_decl = create<ast::var_decl_t>(ps.token);
	eat_token();

	if (ps.token.tk == tk_assign) {
		ps.error("default values for function arguments are not a thing");
		return nullptr;
	} else if (ps.token.tk == tk_comma || ps.token.tk == tk_rparen) {
		/* ok, let's inject an autogenerated token */
		var_decl->type = type_variable(ps.token.location);
	} else {
		var_decl->type = parse_maybe_type(ps, {}, {}, {});
	}

	return var_decl;
}

ptr<return_statement_t> return_statement_t::parse(parse_state_t &ps) {
	auto return_statement = create<ast::return_statement_t>(ps.token);
	chomp_ident(K(return));
	if (!ps.line_broke() && ps.token.tk != tk_outdent) {
		return_statement->expr = expression_t::parse(ps);
		if (!return_statement->expr) {
			assert(!ps.status);
			return nullptr;
		}
	}
	return return_statement;
}

ptr<statement_t> get_statement_parse(parse_state_t &ps) {
	expect_ident(K(get));
	auto get_token = ps.token;
	ps.advance();

	auto module_decl = module_decl_t::parse(ps, true /*skip_module_token*/);
	if (!!ps.status) {
		auto link_statement = create<link_module_statement_t>(get_token);
		link_statement->extern_module = module_decl;

		if (ps.token.is_ident(K(as))) {
			/* get the local name for this module */
			ps.advance();
			expect_token(tk_identifier);
			link_statement->link_as_name = ps.token;
			ps.advance();
		}

		if (link_statement->link_as_name.tk == tk_none) {
			link_statement->link_as_name = module_decl->get_name();
		}

		if (link_statement->link_as_name.tk != tk_identifier) {
			ps.error("expected an identifier for link module name (either implicit or explicit)");
		}

		if (!!ps.status) {
			return link_statement;
		}
	}
	assert(!ps.status);
	return nullptr;
}

ptr<statement_t> link_statement_parse(parse_state_t &ps) {
	expect_ident(K(link));
	auto link_token = ps.token;
	ps.advance();

	if (ps.token.tk == tk_lsquare || ps.token.is_ident(K(def))) {
		auto link_function_statement = create<ast::link_function_statement_t>(link_token);
		auto function_decl = function_decl_t::parse(ps);
		if (function_decl) {
			if (ps.token.is_ident(K(to))) {
				ps.advance();
				if (ps.token.tk != tk_identifier && ps.token.tk != tk_string) {
					ps.error("expected an identifier (or string) for the external name of the linked function (not %s)",
							ps.token.str().c_str());
				}
				if (!!ps.status) {
					expect_token(tk_identifier);
					function_decl->link_to_name = ps.token;
					ps.advance();
				}
			}
			link_function_statement->extern_function = function_decl;
		} else {
			assert(!ps.status);
		}

		if (!!ps.status) {
			return link_function_statement;
		}
	} else if (ps.token.is_ident(K(var))) {
		ps.advance();
		// REVIEW: does it make sense to handle 'let' in this context?
		auto var_decl = var_decl_t::parse(ps, false /* is_let */);
		if (!!ps.status) {
			auto link_var = create<link_var_statement_t>(link_token);
			link_var->var_decl = var_decl;
			return link_var;
		}
	} else if (ps.token.is_ident(K(in))) {
		ps.advance();
		expect_token(tk_string);
		if (ps.link_ins != nullptr) {
			ps.link_ins->insert(ps.token);
		}
		ps.advance();
		return nullptr;
	} else if (ps.token.tk == tk_identifier) {
		/*
		 * link name to some_module.something
		 *
		 * 1. Sets up a type parser macro "name" => "some_module.something"
		 * 2. Sets up a "scope link" from this module to the "some_module" for the
		 * "something" name so that if there is a call to "something" from
		 * within this module, we also search "some_module" when enumerating
		 * callables.
		 * 3. Start tracking whether the link is in use in the module
		 */
		auto name_token = ps.token;
		ps.advance();
		chomp_ident(K(to));

		auto link_name = create<ast::link_name_t>(link_token);
		link_name->local_name = name_token;
		link_name->extern_module = module_decl_t::parse(ps, true /* skip_module_token */);

		if (!!ps.status) {
			chomp_token(tk_dot);
			expect_token(tk_identifier);
			link_name->remote_name = ps.token;
			ps.advance();
			return link_name;
		}
	} else {
		ps.error("invalid link syntax (TODO: make this error better)");
	}

	assert(!ps.status);
	return nullptr;
}

ptr<statement_t> statement_t::parse(parse_state_t &ps) {
	assert(ps.token.tk != tk_outdent);

	if (ps.token.is_ident(K(var))) {
		ps.advance();
		return var_decl_t::parse(ps, false /*is_let*/);
	} else if (ps.token.is_ident(K(let))) {
		ps.advance();
		return var_decl_t::parse(ps, true /*is_let*/);
	} else if (ps.token.is_ident(K(if))) {
		return if_block_t::parse(ps);
	} else if (ps.token.is_ident(K(while))) {
		return while_block_t::parse(ps);
	} else if (ps.token.is_ident(K(for))) {
		return for_block_t::parse(ps);
	} else if (ps.token.is_ident(K(when))) {
		return when_block_t::parse(ps);
	} else if (ps.token.is_ident(K(return))) {
		return return_statement_t::parse(ps);
	} else if (ps.token.is_ident(K(type))) {
		return type_def_t::parse(ps);
	} else if (ps.token.is_ident(K(pass))) {
		auto pass_flow = create<ast::pass_flow_t>(ps.token);
		eat_token();
		return std::move(pass_flow);
	} else if (ps.token.is_ident(K(continue))) {
		auto continue_flow = create<ast::continue_flow_t>(ps.token);
		eat_token();
		return std::move(continue_flow);
	} else if (ps.token.is_ident(K(def))) {
		return function_defn_t::parse(ps);
	} else if (ps.token.is_ident(K(break))) {
		auto break_flow = create<ast::break_flow_t>(ps.token);
		eat_token();
		return std::move(break_flow);
	} else {
		return assignment_t::parse(ps);
	}
}

ptr<expression_t> reference_expr_t::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_identifier) {
		if (ps.token.text == "null") {
			auto token = ps.token;
			ps.advance();
			return create<ast::literal_expr_t>(token);
		}
		auto reference_expr = create<ast::reference_expr_t>(ps.token);
		ps.advance();
		return std::move(reference_expr);
	} else {
		ps.error("expected an identifier");
		return nullptr;
	}
}

ptr<typeid_expr_t> typeid_expr_t::parse(parse_state_t &ps) {
	auto token = ps.token;
	chomp_ident(K(__get_typeid__));
	chomp_token(tk_lparen);

	auto value = expression_t::parse(ps);
	if (!!ps.status) {
		assert(value != nullptr);
		auto expr = ast::create<typeid_expr_t>(token, value);
		chomp_token(tk_rparen);
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<sizeof_expr_t> sizeof_expr_t::parse(parse_state_t &ps) {
	auto token = ps.token;
	chomp_ident(K(sizeof));
	chomp_token(tk_lparen);

	auto type = parse_maybe_type(ps, {}, {}, {});
	if (!!ps.status) {
		assert(type != nullptr);
		auto expr = ast::create<sizeof_expr_t>(token, type);
		chomp_token(tk_rparen);
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> parse_bang_wrap(parse_state_t &ps, ptr<expression_t> expr) {
    if (ps.token.tk == tk_bang) {
        auto bang = ast::create<ast::bang_expr_t>(ps.token);
        bang->lhs = expr;
        ps.advance();
        return bang;
    } else {
        return expr;
    }
}

ptr<expression_t> parse_cast_wrap(parse_state_t &ps, ptr<expression_t> expr) {
    if (ps.token.is_ident(K(as))) {
		auto token = ps.token;
		ps.advance();
		auto cast = ast::create<ast::cast_expr_t>(token);
		cast->lhs = expr;

		if (ps.token.tk == tk_bang) {
			ps.advance();
			cast->force_cast = true;
		}
		cast->type_cast = parse_maybe_type(ps, {}, {}, {});
        return cast;
    } else {
        return expr;
    }
}

ptr<expression_t> base_expr::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_lparen) {
		return tuple_expr_t::parse(ps);
	} else if (ps.token.is_ident(K(__get_typeid__))) {
		return typeid_expr_t::parse(ps);
	} else if (ps.token.is_ident(K(sizeof))) {
		return sizeof_expr_t::parse(ps);
	} else if (ps.token.tk == tk_identifier) {
		// NB: this is last to ensure "special" builtins are in play above
		return reference_expr_t::parse(ps);
	} else {
		return literal_expr_t::parse(ps);
	}
}

ptr<expression_t> array_literal_expr_t::parse(parse_state_t &ps) {
	chomp_token(tk_lsquare);
	auto array = create<array_literal_expr_t>(ps.token);
	auto &items = array->items;

	int i = 0;
	while (ps.token.tk != tk_rsquare && ps.token.tk != tk_none) {
		++i;
		auto item = expression_t::parse(ps);
		if (item) {
			items.push_back(item);
		} else {
			assert(!ps.status);
		}
		if (ps.token.tk == tk_comma) {
			ps.advance();
		} else if (ps.token.tk != tk_rsquare) {
			ps.error("found something that does not make sense in an array literal");
			break;
		}
	}
	chomp_token(tk_rsquare);
	return array;
}

ptr<expression_t> literal_expr_t::parse(parse_state_t &ps) {
	switch (ps.token.tk) {
	case tk_raw_float:
	case tk_raw_integer:
	case tk_raw_string:
	case tk_integer:
	case tk_string:
	case tk_char:
	case tk_float:
		{
			auto literal_expr = create<ast::literal_expr_t>(ps.token);
			ps.advance();
			return std::move(literal_expr);
		}
	case tk_lsquare:
		return array_literal_expr_t::parse(ps);
	case tk_indent:
		ps.error("unexpected indent");
		return nullptr;

	case tk_identifier:
		if (ps.token.is_ident(K(def))) {
			return function_defn_t::parse(ps);
		}
		ps.error("unexpected token found when parsing literal expression. '" c_error("%s") "'", ps.token.text.c_str());
		return nullptr;

	default:
		ps.error("out of place token found when parsing literal expression. '" c_error("%s") "' (%s)",
			   	ps.token.text.c_str(),
				tkstr(ps.token.tk));
		return nullptr;
	}
}

ptr<typeinfo_expr_t> typeinfo_expr_t::parse(parse_state_t &ps) {
	expect_token(tk_lparen);
	auto typeinfo_expr = ast::create<typeinfo_expr_t>(ps.prior_token);
	ps.advance();
	if (!!ps.status) {
		typeinfo_expr->type = parse_maybe_type(ps, {}, {}, {});
		if (!!ps.status) {
			chomp_token(tk_rparen);
			return typeinfo_expr;
		}
	}

	assert(!ps.status);
	return nullptr;
}

std::vector<ptr<expression_t>> parse_param_list(parse_state_t &ps) {
	std::vector<ptr<expression_t>> params;
	chomp_token_or_return(tk_lparen, {});
	int i = 0;
	while (ps.token.tk != tk_rparen) {
		++i;
		auto expr = expression_t::parse(ps);
		if (expr) {
			params.push_back(std::move(expr));
			if (ps.token.tk == tk_comma) {
				eat_token();
			} else if (ps.token.tk != tk_rparen) {
				ps.error("unexpected %s in parameter list (" c_id("%s") ")", tkstr(ps.token.tk), ps.token.text.c_str());
				return {};
			}
			// continue and read the next parameter
		} else {
			assert(!ps.status);
			return {};
		}
	}
	chomp_token_or_return(tk_rparen, {});

	return params;
}

namespace ast {
	namespace postfix_expr {
		ptr<expression_t> parse(parse_state_t &ps) {
			ptr<expression_t> expr = base_expr::parse(ps);
			if (!expr) {
				assert(!ps.status);
				return nullptr;
			}

			while (!!ps.status &&
					!ps.line_broke() &&
					(ps.token.tk == tk_lsquare ||
					 ps.token.tk == tk_lparen ||
					 ps.token.tk == tk_dot))
			{
				if (ps.token.tk == tk_lparen) {
					auto ref_expr = dyncast<reference_expr_t>(expr);

					if (ref_expr != nullptr && ref_expr->token.text == "typeinfo") {
						/* override the typeinfo keyword */
						expr = typeinfo_expr_t::parse(ps);
					} else {
						/* function call */
						auto callsite = create<callsite_expr_t>(ps.token);
						callsite->params = parse_param_list(ps);
						if (!!ps.status) {
							callsite->function_expr.swap(expr);
							assert(expr == nullptr);
							expr = callsite;
						}
					}
				}

				if (!!ps.status) {
					if (ps.token.tk == tk_dot) {
						auto dot_expr = create<ast::dot_expr_t>(ps.token);
						eat_token();
						expect_token(tk_identifier);
						dot_expr->rhs = ps.token;
						ps.advance();
						dot_expr->lhs.swap(expr);
						assert(expr == nullptr);
						expr = dot_expr;
					}

					if (ps.token.tk == tk_lsquare) {
						eat_token();
						auto array_index_expr = create<ast::array_index_expr_t>(ps.token);

						auto index = expression_t::parse(ps);
						if (index) {
							array_index_expr->index.swap(index);
							array_index_expr->lhs.swap(expr);
							assert(expr == nullptr);
							expr = array_index_expr;
						} else {
							assert(!ps.status);
							return nullptr;
						}
						chomp_token(tk_rsquare);
					}
				}
			}

			if (!!ps.status) {
				expr = parse_bang_wrap(ps, expr);

				if (!!ps.status) {
					return expr;
				}
			}

			assert(!ps.status);
			return nullptr;
		}
	}
}

ptr<expression_t> prefix_expr_t::parse(parse_state_t &ps) {
	ptr<prefix_expr_t> prefix_expr;
	if (ps.token.tk == tk_ampersand
			|| ps.token.tk == tk_minus
			|| ps.token.tk == tk_plus
			|| ps.token.is_ident(K(not)))
	{
		prefix_expr = create<ast::prefix_expr_t>(ps.token);
		eat_token();
	}

	ptr<expression_t> rhs;
	if (ps.token.is_ident(K(not))
			|| ps.token.tk == tk_minus
			|| ps.token.tk == tk_plus) {
		/* recurse to find more prefix expressions */
		rhs = prefix_expr_t::parse(ps);
	} else {
		/* ok, we're done with prefix operators */
		rhs = postfix_expr::parse(ps);
	}

	if (rhs) {
		if (prefix_expr) {
			prefix_expr->rhs = std::move(rhs);
			return parse_cast_wrap(ps, prefix_expr);
		} else {
			return parse_cast_wrap(ps, rhs);
		}
	} else {
		assert(!ps.status);
		return nullptr;
	}
}


ptr<expression_t> times_expr_parse(parse_state_t &ps) {
	auto expr = prefix_expr_t::parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && (ps.token.tk == tk_times
			   	|| ps.token.tk == tk_divide_by
			   	|| ps.token.tk == tk_mod)) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		switch (ps.token.tk) {
		case tk_times:
			binary_operator->function_name = "__times__";
			break;
		case tk_divide_by:
			binary_operator->function_name = "__divide__";
			break;
		case tk_mod:
			binary_operator->function_name = "__mod__";
			break;
		default:
			assert(false);
			break;
		}

		eat_token();

		auto rhs = prefix_expr_t::parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	return expr;
}

ptr<expression_t> plus_expr_parse(parse_state_t &ps) {
	auto expr = times_expr_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() &&
		   	(ps.token.tk == tk_plus || ps.token.tk == tk_minus))
   	{
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		switch (ps.token.tk) {
		case tk_plus:
			binary_operator->function_name = "__plus__";
			break;
		case tk_minus:
			binary_operator->function_name = "__minus__";
			break;
		default:
			assert(false);
			break;
		}

		eat_token();

		auto rhs = times_expr_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	if (!!ps.status) {
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> shift_expr_parse(parse_state_t &ps) {
	auto expr = plus_expr_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() &&
		   	(ps.token.tk == tk_shift_left || ps.token.tk == tk_shift_right))
   	{
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		switch (ps.token.tk) {
		case tk_shift_left:
			binary_operator->function_name = "__shl__";
			break;
		case tk_shift_right:
			binary_operator->function_name = "__shr__";
			break;
		default:
			assert(false);
			break;
		}

		eat_token();

		auto rhs = plus_expr_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	if (!!ps.status) {
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> ineq_expr_parse(parse_state_t &ps) {
	auto lhs = shift_expr_parse(ps);
	if (lhs) {
		if (ps.line_broke()
				|| !(ps.token.tk == tk_gt
					|| ps.token.tk == tk_gte
					|| ps.token.tk == tk_lt
					|| ps.token.tk == tk_lte)) {
			/* there is no rhs */
			return lhs;
		}

		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		switch (ps.token.tk) {
		case tk_gt:
			binary_operator->function_name = "__gt__";
			break;
		case tk_gte:
			binary_operator->function_name = "__gte__";
			break;
		case tk_lt:
			binary_operator->function_name = "__lt__";
			break;
		case tk_lte:
			binary_operator->function_name = "__lte__";
			break;
		default:
			assert(false);
			break;
		}

		eat_token();

		auto rhs = shift_expr_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = std::move(lhs);
			binary_operator->rhs = std::move(rhs);
			return std::move(binary_operator);
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> eq_expr_parse(parse_state_t &ps) {
	auto lhs = ineq_expr_parse(ps);
	if (!!ps.status) {
		bool not_in = false;
		if (ps.token.is_ident(K(not))) {
			eat_token();
			expect_ident(K(in));
			not_in = true;
		}

		if (ps.line_broke() ||
				!(ps.token.is_ident(K(in))
					|| ps.token.tk == tk_equal
					|| ps.token.tk == tk_inequal
                    || ps.token.is_ident(K(is)))) {
			/* there is no rhs */
			return lhs;
		}

		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		if (ps.token.is_ident(K(in))) {
			binary_operator->function_name = "__in__";
		} else if (ps.token.tk == tk_equal) {
			binary_operator->function_name = "__eq__";
		} else if (ps.token.tk == tk_inequal) {
			binary_operator->function_name = "__ineq__";
		} else if (ps.token.is_ident(K(is))) {
			binary_operator->function_name = "__is__";
		} else {
			assert(false);
		}

		eat_token();

        if (ps.token.is_ident(K(not)) && binary_operator->token.is_ident(K(is))) {
			binary_operator->function_name = "__isnot__";
            ps.advance();
        } else if (not_in) {
			binary_operator->function_name = "__notin__";
		}

		auto rhs = ineq_expr_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = lhs;
			binary_operator->rhs = rhs;
			return binary_operator;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> bitwise_and_parse(parse_state_t &ps) {
	auto expr = eq_expr_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && ps.token.tk == tk_ampersand) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		binary_operator->function_name = "__bitwise_and__";

		eat_token();

		auto rhs = eq_expr_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	if (!!ps.status) {
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> bitwise_xor_parse(parse_state_t &ps) {
	auto expr = bitwise_and_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && ps.token.tk == tk_hat) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		binary_operator->function_name = "__xor__";

		eat_token();

		auto rhs = bitwise_and_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	if (!!ps.status) {
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> bitwise_or_parse(parse_state_t &ps) {
	auto expr = bitwise_xor_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && ps.token.tk == tk_pipe) {
		auto binary_operator = create<ast::binary_operator_t>(ps.token);
		binary_operator->function_name = "__bitwise_or__";

		eat_token();

		auto rhs = bitwise_xor_parse(ps);
		if (!!ps.status) {
			binary_operator->lhs = expr;
			binary_operator->rhs = rhs;
			expr = binary_operator;
		}
	}

	if (!!ps.status) {
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> and_expr_t::parse(parse_state_t &ps) {
	auto expr = bitwise_or_parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && (ps.token.is_ident(K(and)))) {
		auto and_expr = create<ast::and_expr_t>(ps.token);

		eat_token();

		auto rhs = bitwise_or_parse(ps);
		if (!!ps.status) {
			and_expr->lhs = expr;
			and_expr->rhs = rhs;
			expr = and_expr;
		} else {
			ps.error("unable to parse right hand side of and_expr");
			return nullptr;
		}
	}

	return expr;
}

ptr<expression_t> tuple_expr_t::parse(parse_state_t &ps) {
	auto start_token = ps.token;
	chomp_token(tk_lparen);
	auto expr = expression_t::parse(ps);
	if (ps.token.tk != tk_comma) {
		chomp_token(tk_rparen);
		return expr;
	} else {
		ps.advance();

		/* we've got a tuple */
		auto tuple_expr = create<ast::tuple_expr_t>(start_token);

		/* add the first value */
		tuple_expr->values.push_back(expr);

		/* now let's find the rest of the values */
		while (ps.token.tk != tk_rparen) {
			expr = expression_t::parse(ps);
			if (expr) {
				tuple_expr->values.push_back(expr);
				if (ps.token.tk == tk_comma) {
					eat_token();
				} else if (ps.token.tk != tk_rparen) {
					ps.error(
						"unexpected token " c_id("%s") " in tuple. expected comma or right-paren",
						ps.token.text.c_str());
					return nullptr;
				}
				// continue and read the next parameter
			} else {
				assert(!ps.status);
				return nullptr;
			}
		}
		chomp_token(tk_rparen);
		return tuple_expr;
	}
}

ptr<expression_t> or_expr_t::parse(parse_state_t &ps) {
	auto expr = and_expr_t::parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && (ps.token.is_ident(K(or)))) {
		auto or_expr = create<ast::or_expr_t>(ps.token);

		eat_token();

		auto rhs = and_expr_t::parse(ps);
		if (rhs) {
			or_expr->lhs = std::move(expr);
			or_expr->rhs = std::move(rhs);
			expr = std::move(or_expr);
		} else {
			ps.error("unable to parse right hand side of or_expr");
			return nullptr;
		}
	}

	return expr;
}

ptr<expression_t> ternary_expr_t::parse(parse_state_t &ps) {
	auto condition = or_expr_t::parse(ps);
	if (!!ps.status) {
		if (ps.token.tk == tk_maybe) {
			ps.advance();
			// TODO: handle a ?? b form

			auto truthy_expr = or_expr_t::parse(ps);
			if (!!ps.status) {
				expect_token(tk_colon);
				ps.advance();
				auto falsey_expr = or_expr_t::parse(ps);
				if (!!ps.status) {
					auto ternary = ast::create<ternary_expr_t>(condition->token);
					ternary->condition = condition;
					ternary->when_true = truthy_expr;
					ternary->when_false = falsey_expr;
					return ternary;
				}
			}
		} else {
			return condition;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression_t> expression_t::parse(parse_state_t &ps) {
	return ternary_expr_t::parse(ps);
}

ptr<statement_t> assignment_t::parse(parse_state_t &ps) {
	auto lhs = expression_t::parse(ps);
	if (lhs != nullptr) {

#define handle_assign(tk_, type) \
		if (!ps.line_broke() && ps.token.tk == tk_) { \
			auto assignment = create<type>(ps.token); \
			chomp_token(tk_); \
			auto rhs = expression_t::parse(ps); \
			if (rhs) { \
				assignment->lhs = std::move(lhs); \
				assignment->rhs = std::move(rhs); \
				return std::move(assignment); \
			} else { \
				assert(!ps.status); \
				return nullptr; \
			} \
		}

		handle_assign(tk_assign, ast::assignment_t);
		handle_assign(tk_plus_eq, ast::plus_assignment_t);
		// handle_assign(tk_maybe_eq, ast::maybe_assignment_t);
		handle_assign(tk_minus_eq, ast::minus_assignment_t);
		handle_assign(tk_divide_by_eq, ast::divide_assignment_t);
		handle_assign(tk_times_eq, ast::times_assignment_t);
		handle_assign(tk_mod_eq, ast::mod_assignment_t);

		if (!ps.line_broke() && ps.token.tk == tk_becomes) {
			if (lhs->sk == sk_reference_expr) {
				auto var_decl = create<ast::var_decl_t>(lhs->token);
				var_decl->type = type_variable(lhs->token.location);
				chomp_token(tk_becomes);
				auto initializer = expression_t::parse(ps);
				if (initializer) {
					var_decl->initializer.swap(initializer);
					return var_decl;
				} else {
					assert(!ps.status);
					return nullptr;
				}
			} else {
				ps.error(":= may only come after a new symbol name");
				return nullptr;
			}
		} else {
			return lhs;
		}
		return lhs;
	} else {
		assert(!ps.status);
	}

	return nullptr;
}

ptr<param_list_decl_t> param_list_decl_t::parse(parse_state_t &ps) {
	/* reset the argument index */
	ps.argument_index = 0;

	auto param_list_decl = create<ast::param_list_decl_t>(ps.token);
	while (ps.token.tk != tk_rparen) {
		param_list_decl->params.push_back(var_decl_t::parse_param(ps));
		if (ps.token.tk == tk_comma) {
			eat_token();
		} else if (ps.token.tk != tk_rparen) {
			ps.error("unexpected token in param_list_decl");
			return nullptr;
		}
	}
	return param_list_decl;
}

ptr<block_t> block_t::parse(parse_state_t &ps) {
	auto block = create<ast::block_t>(ps.token);
	chomp_token(tk_indent);
	if (ps.token.tk == tk_outdent) {
		user_error(ps.status, block->token.location, "empty blocks are not allowed, sorry. use pass.");
		return nullptr;
	}

	while (!!ps.status && ps.token.tk != tk_outdent) {
		assert(ps.token.tk != tk_none);
		while (ps.token.tk == tk_semicolon) {
			ps.advance();
		}
		if (!ps.line_broke()
				&& !(ps.prior_token.tk == tk_indent
					|| ps.prior_token.tk == tk_outdent)) {
			ps.error("statements must be separated by a newline (or a semicolon)");
		}
		auto statement = statement_t::parse(ps);
		if (statement) {
			block->statements.push_back(std::move(statement));
		} else {
			assert(!ps.status);
			return nullptr;
		}
	}

	expect_token(tk_outdent);
	ps.advance();
	return block;
}

ptr<if_block_t> if_block_t::parse(parse_state_t &ps) {
	auto if_block = create<ast::if_block_t>(ps.token);
	if (ps.token.is_ident(K(if)) || ps.token.is_ident(K(elif))) {
		ps.advance();
	} else {
		ps.error("expected if or elif");
		return nullptr;
	}

	token_t condition_token = ps.token;
	auto assignment = assignment_t::parse(ps);
	if (!!ps.status) {
		if (auto condition = dyncast<const expression_t>(assignment)) {
			if_block->condition = condition;
		} else if (auto var_decl = dyncast<const var_decl_t>(assignment)) {
			if_block->condition = var_decl;
		} else {
			user_error(ps.status, condition_token.location,
					"if conditions are limited to expressions or variable definitions");
		}

		if (!!ps.status) {
			auto block = block_t::parse(ps);
			if (!!ps.status) {
				if_block->block = block;

				if (ps.prior_token.tk == tk_outdent) {
					/* check the successive instructions for elif or else */
					if (ps.token.is_ident(K(elif))) {
						if_block->else_ = if_block_t::parse(ps);
					} else if (ps.token.is_ident(K(else))) {
						ps.advance();
						if_block->else_ = block_t::parse(ps);
					}
				}

				return if_block;
			} else {
				assert(!ps.status);
				return nullptr;
			}
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<while_block_t> while_block_t::parse(parse_state_t &ps) {
	auto while_block = create<ast::while_block_t>(ps.token);
	chomp_ident(K(while));
	token_t condition_token = ps.token;
	auto assignment = assignment_t::parse(ps);
	if (!!ps.status) {
		if (auto condition = dyncast<const expression_t>(assignment)) {
			while_block->condition = condition;
		} else if (auto var_decl = dyncast<const var_decl_t>(assignment)) {
			while_block->condition = var_decl;
		} else {
			user_error(ps.status, condition_token.location,
					"while conditions are limited to expressions or variable definitions");
		}

		auto block = block_t::parse(ps);
		if (!!ps.status) {
			while_block->block = block;
			return while_block;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<for_block_t> for_block_t::parse(parse_state_t &ps) {
	auto for_block = create<ast::for_block_t>(ps.token);
	chomp_ident(K(for));
	expect_token(tk_identifier);
	for_block->var_token = ps.token;
	ps.advance();
	expect_ident(K(in));
	for_block->in_token = ps.token;
	ps.advance();
	auto iterable = expression_t::parse(ps);
	if (!!ps.status) {
		for_block->iterable.swap(iterable);
		auto block = block_t::parse(ps);
		if (block != nullptr) {
			for_block->block.swap(block);
			return for_block;
		} else {
			assert(!ps.status);
			return nullptr;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ast::pattern_block_t::ref pattern_block_t::parse(parse_state_t &ps) {
	auto is_token = ps.token;
	chomp_ident(K(is));

	auto pattern_block = ast::create<ast::pattern_block_t>(is_token);
	pattern_block->type = parse_maybe_type(ps, {}, {}, {});

	if (!!ps.status) {
		auto block = block_t::parse(ps);
		if (block) {
			pattern_block->block.swap(block);
			return pattern_block;
		} else {
			assert(!ps.status);
			return nullptr;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<when_block_t> when_block_t::parse(parse_state_t &ps) {
	auto when_block = create<ast::when_block_t>(ps.token);
	chomp_ident(K(when));
	auto value = expression_t::parse(ps);
	if (!!ps.status) {
		when_block->value.swap(value);

		/* this is a multi_pattern_block */
		chomp_token(tk_indent);
		while (ps.token.is_ident(K(is))) {
			auto pattern_block = pattern_block_t::parse(ps);
			if (!!ps.status) {
				when_block->pattern_blocks.push_back(pattern_block);
			}
		}

		chomp_token(tk_outdent);
		if (ps.token.is_ident(K(else))) {
			ps.advance();
			when_block->else_block = block_t::parse(ps);
		}

		if (when_block->pattern_blocks.size() == 0) {
			ps.error("when block did not have subsequent patterns to match");
		}

		return when_block;
	} else {
		assert(!ps.status);
		return nullptr;
	}
}

ptr<function_decl_t> function_decl_t::parse(parse_state_t &ps) {
	location_t attributes_location;
	identifier::ref extends_module;
	if (ps.token.tk == tk_lsquare) {
		attributes_location = ps.token.location;
		ps.advance();
		if (ps.token.is_ident(K(global))) {
			extends_module = make_iid_impl(GLOBAL_SCOPE_NAME, ps.token.location);
			ps.advance();
			chomp_token(tk_rsquare);
        } else if (ps.token.is_ident(K(module))) {
			ps.advance();
			expect_token(tk_identifier);
			extends_module = make_code_id(ps.token);
			ps.advance();
			chomp_token(tk_rsquare);
		} else {
			ps.error("expected inbound module declaration");
		}
	}

	if (!!ps.status) {
		chomp_ident(K(def));

		if (!!ps.status) {
			auto function_decl = create<ast::function_decl_t>(ps.token);
			function_decl->link_to_name = ps.token;

			if (ps.token.text == "main") {
				if (extends_module == nullptr) {
					extends_module = make_iid_impl(GLOBAL_SCOPE_NAME, ps.token.location);
				} else {
					user_error(ps.status, attributes_location,
							"the main function may not specify an inbound context");
				}
			}

			chomp_token(tk_identifier);
			chomp_token(tk_lparen);

			function_decl->extends_module = extends_module;
			function_decl->param_list_decl = param_list_decl_t::parse(ps);

			chomp_token(tk_rparen);
			if (!ps.line_broke()) {
				if (token_begins_type(ps.token)) {
					function_decl->return_type = parse_maybe_type(ps, {}, {}, {});
					debug_above(6, log("parsed function return type %s at %s",
									   function_decl->return_type->str().c_str(),
									   ps.token.str().c_str()));
				}

				if (function_decl->token.text == "__finalize__") {
					if (function_decl->param_list_decl->params.size() != 1) {
						user_error(ps.status, function_decl->token.location,
								"finalizers must only take one parameter");
					}
					if (function_decl->return_type != nullptr) {
						user_error(ps.status, function_decl->return_type->get_location(),
								"finalizers cannot return anything");
					}
				}
			}

			return function_decl;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<function_defn_t> function_defn_t::parse(parse_state_t &ps) {
	auto function_decl = function_decl_t::parse(ps);

	if (!!ps.status) {
		assert(function_decl != nullptr);
		auto block = block_t::parse(ps);
		if (!!ps.status) {
			assert(block != nullptr);
			auto function_defn = create<ast::function_defn_t>(function_decl->token);
			function_defn->decl = function_decl;
			function_defn->block = block;
			return function_defn;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<module_decl_t> module_decl_t::parse(parse_state_t &ps, bool skip_module_token) {
	bool global = false;
	if (!skip_module_token) {
		if (ps.token.is_ident(K(global))) {
			global = true;
			ps.advance();
		} else {
			chomp_ident(K(module));
		}
	}

	/* we've skipped the check for the 'module' token */
	auto module_decl = create<ast::module_decl_t>(ps.token);
	module_decl->global = global;

	if (!global) {
		expect_token(tk_identifier);
		module_decl->name = ps.token;
		eat_token();
	}

	if (ps.token.tk == tk_version) {
		auto semver = semver_t::parse(ps);
		if (semver) {
			module_decl->semver.swap(semver);
		} else {
			/* ok for now */
		}
	}
	return module_decl;
}

ptr<semver_t> semver_t::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_version) {
		auto semver = create<ast::semver_t>(ps.token);
		eat_token();
		return semver;
	} else {
		return nullptr;
	}
}

void parse_maybe_type_decl(parse_state_t &ps, identifier::refs &type_variables) {
	if (!ps.line_broke() && ps.token.tk == tk_lcurly) {
		ps.advance();
		while (true) {
			if (ps.token.tk == tk_identifier) {
				/* we found a type variable, let's stash it */
				if (ps.token.is_ident(K(any))) {
					ps.error("`any` is unnecessary within type parameters of type declarations");
					break;
				}
				type_variables.push_back(make_code_id(ps.token));
				ps.advance();
				if (ps.token.tk == tk_comma) {
					ps.advance();
				} else {
					continue;
				}
			} else if (ps.token.tk == tk_rcurly) {
				ps.advance();
				break;
			} else {
				ps.error("unexpected token found `" c_error("%s") "`", ps.token.text.c_str());
				break;
			}
		}
	}
}

identifier::ref make_code_id(const token_t &token) {
	return make_ptr<code_id>(token);
}

identifier::ref make_type_id_code_id(const location_t location, std::string var_name) {
	return make_ptr<type_id_code_id>(location, var_name);
}

types::type_t::refs parse_type_operands(
		parse_state_t &ps,
		identifier::ref supertype_id,
		identifier::refs type_variables,
		identifier::set generics)
{
	types::type_t::refs arguments;

	/* loop over the type arguments */
	while (!!ps.status && ps.token.tk != tk_rcurly) {
		/* we got an argument, recursively parse */
		auto next_type = parse_maybe_type(ps, supertype_id, type_variables, generics);
		if (!!ps.status) {
			arguments.push_back(next_type);

			if (ps.token.tk == tk_rcurly) {
				/* move on */
				break;
			} else if (ps.token.tk == tk_comma) {
				/* if we get a comma, move past it */
				ps.advance();
			} else {
				ps.error("expected ('}' or ','), got %s", tkstr(ps.token.tk));
			}
		}
	}

	if (ps.token.tk == tk_rcurly) {
		ps.advance();
	} else {
		ps.error("unexpected token found in type reference argument list, found %s",
				tkstr(ps.token.tk));
	}
	return arguments;
}

types::type_t::ref _parse_function_type(parse_state_t &ps, identifier::set generics) {
	chomp_ident(K(def));
	chomp_token(tk_lparen);
	types::type_t::refs param_types;
	types::type_t::ref return_type;
	std::map<std::string, int> name_index;
	int index = 0;

	while (!!ps.status) {
		if (ps.token.tk == tk_identifier) {
			auto var_name = ps.token;
			ps.advance();
			types::type_t::ref type = parse_maybe_type(ps, {}, {}, generics);
			if (!!ps.status) {
				param_types.push_back(type);
				if (name_index.find(var_name.text) != name_index.end()) {
					ps.error("duplicated parameter name: %s",
							var_name.text.c_str());
				} else {
					name_index[var_name.text] = index;
					++index;
				}
				if (ps.token.tk == tk_comma) {
					/* advance past a comma */
					ps.advance();
				}
			}
		} else if (ps.token.tk == tk_rparen) {
			ps.advance();
			break;
		} else {
			ps.error("expected a parameter name");
			return nullptr;
		}
	}

	if (!!ps.status) {
		/* now let's parse the return type */
		if (!ps.line_broke() && token_begins_type(ps.token)) {
			return_type = parse_maybe_type(ps, {}, {}, generics);
		} else {
			return_type = type_void();
		}

		if (!!ps.status) {
			return type_function(type_args(param_types), return_type);
		}
	}

	assert(!ps.status);
	return nullptr;
}

identifier::ref reduce_ids(std::list<identifier::ref> ids, location_t location) {
	assert(ids.size() != 0);
	return make_iid_impl(join(ids, SCOPE_SEP), location);
}

types::type_t::ref _parse_single_type(
		parse_state_t &ps,
	   	identifier::ref supertype_id,
	   	identifier::refs type_variables,
	   	identifier::set generics)
{
	if (!token_begins_type(ps.token)) {
		ps.error("type references cannot begin with %s", ps.token.str().c_str());
		return nullptr;
	}

	switch (ps.token.tk) {
	case tk_integer:
	case tk_string:
		{
			auto type = type_literal(ps.token);
			ps.advance();
			return type;
		}

	case tk_times:
		{
			ps.advance();
			auto type = _parse_single_type(ps, supertype_id, type_variables, generics);
			if (!!ps.status) {
				return ::type_ptr(type);
			}
		}
		break;
	case tk_identifier:
		if (ps.token.is_ident(K(integer_t))) {
			auto token = ps.token;
			ps.advance();
			chomp_token(tk_lcurly);
			auto bit_size = _parse_single_type(ps, nullptr, type_variables, generics);
			if (!!ps.status) {
				chomp_token(tk_comma);
				auto signed_ = _parse_single_type(ps, nullptr, type_variables, generics);
				if (!!ps.status) {
					chomp_token(tk_rcurly);
					return type_integer(bit_size, signed_);
				}
			}

			assert(!ps.status);
			return nullptr;
		} else if (ps.token.is_ident(K(has))
				|| ps.token.is_ident(K(struct)))
	   	{
			bool native_struct = ps.token.is_ident(K(struct));
			ps.advance();

			if (ps.token.tk != tk_indent && native_struct) {
				/* special case of empty structure */
				return ::type_struct({}, {});
			}

			chomp_token(tk_indent);
			types::type_t::refs dimensions;
			types::name_index_t name_index;
			int index = 0;
			while (!!ps.status && ps.token.tk != tk_outdent) {
				if (!ps.line_broke() && ps.prior_token.tk != tk_indent) {
					ps.error("product type dimensions must be separated by a newline");
				}

				token_t var_token;
				if (ps.token.is_ident(K(var))) {
					ps.advance();
					expect_token(tk_identifier);
					var_token = ps.token;
					if (name_index.find(var_token.text) != name_index.end()) {
						ps.error("name " c_id("%s") " already exists in type", var_token.text.c_str());
					}
					name_index[var_token.text] = index++;
					ps.advance();
				} else {
					ps.error("not sure what's going on here");
					wat();
					expect_token(tk_identifier);
					var_token = ps.token;
				}

				types::type_t::ref dim_type = parse_maybe_type(ps, {}, {}, generics);
				if (!!ps.status) {
					dimensions.push_back(dim_type);
				}
			}
			chomp_token(tk_outdent);
			if (!!ps.status) {
				return ::type_struct(dimensions, name_index);
			} else {
				return nullptr;
			}
		} else if (ps.token.is_ident(K(def))) {
			return _parse_function_type(ps, generics);
		} else if (ps.token.is_ident(K(any))) {
			/* parse generic refs */
			ps.advance();
			types::type_t::ref type;
			if (ps.token.tk == tk_identifier) {
				/* named generic */
				type = type_variable(make_code_id(ps.token));
				ps.advance();
			} else {
				/* no named generic */
				type = type_variable(ps.token.location);
			}
			return type;
		} else {
			/* build the type-path that is referenced here */
			types::type_t::ref cur_type;
			std::list<identifier::ref> ids;
			location_t location = ps.token.location;
			while (ps.token.tk == tk_identifier) {
				ids.push_back(make_code_id(ps.token));
				ps.advance();
				if (ps.token.tk == SCOPE_TK) {
					ps.advance();
					expect_token(tk_identifier);
				} else {
					break;
				}
			}

			/* reduce the type-path to a single simplified id */
			identifier::ref id = reduce_ids(ids, location);

			debug_above(9, log("checking what " c_id("%s") " is",
						id->str().c_str()));

			/* stash the identifier */
			if (generics.find(id) != generics.end()) {
				/* this type is marked as definitely unbound - aka generic. let's
				 * create a generic for it */
				cur_type = type_variable(id);
			} else {
				/* this is not a generic */
				if (in(id->get_name(), ps.type_macros)) {
					debug_above(9, log("checking whether type " c_id("%s") " expands...",
								id->get_name().c_str()));

					/* macro type expansion */
					cur_type = ps.type_macros[id->get_name()];
				} else if (id->get_name().find(SCOPE_SEP_CHAR) != std::string::npos) {
					/* if we're explicit about the type path, then let's just
					 * use that as the id */
					cur_type = type_id(id);
				} else {
					/* we don't have a macro/type_name link for this type, so
					 * let's assume it's in this module */
					if (ps.module_id->get_name() == GLOBAL_SCOPE_NAME) {
						/* the std module is the only "global" module */
						cur_type = type_id(id);
					} else {
						assert(ps.module_id->get_name().size() != 0);
						cur_type = type_id(reduce_ids({ps.module_id, id}, location));
					}
					debug_above(9, log("transformed " c_id("%s") " to " c_id("%s"),
								id->get_name().c_str(),
								cur_type->str().c_str()));
				}
			}

			types::type_t::refs arguments;
			if (ps.token.tk == tk_lcurly) {
				ps.advance();
				arguments = parse_type_operands(ps, supertype_id,
						type_variables, generics);
			}

			for (auto type_arg : arguments) {
				cur_type = type_operator(cur_type, type_arg);
			}

			return cur_type;
		}
		break;
	case tk_lsquare:
		{
			ps.advance();
			auto element_type = parse_maybe_type(ps, supertype_id,
					type_variables, generics);

			if (ps.token.tk != tk_rsquare) {
				ps.error("vector type reference must end with a ']', found %s",
						ps.token.str().c_str());
				return nullptr;
			} else {
				ps.advance();
				return type_vector_type(element_type);
			}
		}
		break;
	case tk_lcurly:
		{
			ps.advance();
			types::type_t::refs arguments = parse_type_operands(ps, supertype_id, type_variables, generics);
			return type_tuple(arguments);
		}
		break;
	default:
		panic("should have been caught above.");
	}

	not_impl();
	return nullptr;
}

types::type_t::ref _parse_type(
		parse_state_t &ps,
	   	identifier::ref supertype_id,
	   	identifier::refs type_variables,
	   	identifier::set generics)
{
    location_t location = ps.token.location;
	types::type_t::refs options;
	while (!!ps.status) {
		auto type = _parse_single_type(ps, supertype_id, type_variables, generics);

		if (!!ps.status) {
			options.push_back(type);
			if (ps.token.is_ident(K(or))) {
				ps.advance();
				continue;
			} else {
				break;
			}
		}
	}
	
	if (!!ps.status) {
		if (options.size() == 1) {
			return options[0];
		} else {
			types::type_t::ref sum_fn = type_sum_safe(options,
                    supertype_id != nullptr ? supertype_id->get_location() : location,
                    {});
            assert(sum_fn != nullptr);
			if (!!ps.status) {
				for (auto iter = type_variables.rbegin();
						iter != type_variables.rend();
						++iter)
				{
					sum_fn = ::type_lambda(*iter, sum_fn);
				}

				return sum_fn;
			}
		}
	}
	assert(!ps.status);
	return nullptr;
}


types::type_t::ref parse_maybe_type(
        parse_state_t &ps,
        identifier::ref supertype_id,
        identifier::refs type_variables,
        identifier::set generics)
{
    types::type_t::ref type = _parse_type(ps, supertype_id, type_variables, generics);
    if (!!ps.status) {
        if (ps.token.tk == tk_maybe) {
            /* no named maybe generic */
            type = type_maybe(type);
            ps.advance();
            return type;
        } else {
            return type;
        }
    }
    assert(!ps.status);
    return nullptr;
}

type_decl_t::ref type_decl_t::parse(parse_state_t &ps, token_t name_token) {
	identifier::refs type_variables;
	parse_maybe_type_decl(ps, type_variables);

	if (!!ps.status) {
		return create<ast::type_decl_t>(name_token, type_variables);
	} else {
		return nullptr;
	}
}

ptr<type_def_t> type_def_t::parse(parse_state_t &ps) {
	chomp_ident(K(type));
	expect_token(tk_identifier);
	auto type_name_token = ps.token;
	ps.advance();

	auto type_def = create<ast::type_def_t>(type_name_token);
	type_def->type_decl = type_decl_t::parse(ps, type_name_token);
	if (!!ps.status) {
		type_def->type_algebra = ast::type_algebra_t::parse(ps, type_def->type_decl);
		if (!!ps.status) {
			return type_def;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<tag_t> tag_t::parse(parse_state_t &ps) {
	chomp_ident(K(tag));
	expect_token(tk_identifier);
	auto tag = create<ast::tag_t>(ps.token);
	ps.advance();

	parse_maybe_type_decl(ps, tag->type_variables);

	if (!!ps.status) {
		return tag;
	}

	assert(!ps.status);
	return nullptr;
}

type_algebra_t::ref type_algebra_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl)
{
	INDENT(8, string_format("parsing type algebra for %s",
				type_decl->token.text.c_str()));

	if (ps.token.is_ident(K(is))) {
		return type_sum_t::parse(ps, type_decl, type_decl->type_variables);
	} else if (ps.token.is_ident(K(has))) {
		return type_product_t::parse(ps, type_decl, type_decl->type_variables, false /*native*/);
	} else if (ps.token.is_ident(K(link))) {
		return type_link_t::parse(ps, type_decl, type_decl->type_variables);
	} else if (ps.token.tk == tk_assign) {
		return type_alias_t::parse(ps, type_decl, type_decl->type_variables);
	} else if (ps.token.is_ident(K(struct))) {
		return type_product_t::parse(ps, type_decl, type_decl->type_variables, true /*native*/);
	} else {
		ps.error(
				"type descriptions must begin with "
			   	c_id("is") ", " c_id("has") ", or " c_id("=") ". (Found %s)",
				ps.token.str().c_str());
		return nullptr;
	}
}

type_sum_t::ref type_sum_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
		identifier::refs type_variables_list)
{
	identifier::set type_variables = to_set(type_variables_list);
	auto is_token = ps.token;
	chomp_ident(K(is));
	bool expect_outdent = false;
	if (ps.token.tk == tk_indent) {
		/* take note of whether the user has indented or not */
		expect_outdent = true;
		ps.advance();
	}

	auto type = _parse_type(ps, make_code_id(type_decl->token),
			type_variables_list, type_variables);

	if (!!ps.status) {
		if (expect_outdent) {
			if (ps.token.tk == tk_lparen) {
				ps.error("subtypes of a supertype must be separated by the '" c_type("or") "' keyword");
				return nullptr;
			} else {
				chomp_token(tk_outdent);
			}
		}

		return create<type_sum_t>(type_decl->token, type);
	} else {
		return nullptr;
	}
}

type_product_t::ref type_product_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
	   	identifier::refs type_variables,
		bool native)
{
	identifier::set generics = to_identifier_set(type_variables);
	if (native) {
		expect_ident(K(struct));
	} else {
		expect_ident(K(has));
	}
	auto type = _parse_single_type(ps, {}, {}, generics);
	return create<type_product_t>(type_decl->token, native, type, generics);
}

type_link_t::ref type_link_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
		identifier::refs type_variables)
{
	identifier::set generics = to_identifier_set(type_variables);
	chomp_ident(K(link));

	token_t finalize_fn, mark_fn;

	/* read the underlying type */
	types::type_t::ref underlying_type = _parse_type(ps, nullptr, type_variables, generics);

	if (!!ps.status) {
		/* read the name of the finalize function */
		expect_token(tk_identifier);
		finalize_fn = ps.token;
		ps.advance();

		/* read the name of the mark function */
		expect_token(tk_identifier);
		mark_fn = ps.token;
		ps.advance();

		auto type_link = create<type_link_t>(type_decl->token);
		type_link->underlying_type = underlying_type;
		type_link->finalize_fn = finalize_fn;
		type_link->mark_fn = mark_fn;
		return type_link;
	}

	assert(!ps.status);
	return nullptr;
}

type_alias_t::ref type_alias_t::parse(
		parse_state_t &ps,
		ast::type_decl_t::ref type_decl,
	   	identifier::refs type_variables)
{
	chomp_token(tk_assign);

	identifier::set generics = to_identifier_set(type_variables);
	types::type_t::ref type = parse_maybe_type(ps, make_code_id(type_decl->token), type_variables, generics);
	if (!!ps.status) {
		auto type_alias = ast::create<ast::type_alias_t>(type_decl->token);
		type_alias->type = type;
		type_alias->type_variables = generics;
		return type_alias;
	}

	assert(!ps.status);
	return nullptr;
}

dimension_t::ref dimension_t::parse(parse_state_t &ps, identifier::set generics) {
	token_t primary_token;
	std::string name;
	if (ps.token.is_ident(K(var))) {
		ps.advance();
		expect_token(tk_identifier);
		primary_token = ps.token;
		name = primary_token.text;
		ps.advance();
	} else {
		ps.error("not sure what's going on here");
		wat();
		expect_token(tk_identifier);
		primary_token = ps.token;
	}

	types::type_t::ref type = parse_maybe_type(ps, {}, {}, generics);
	if (!!ps.status) {
		return ast::create<ast::dimension_t>(primary_token, name, type);
	}
	assert(!ps.status);
	return nullptr;
}

void add_type_macros_to_parser(
		parse_state_t &ps,
		std::vector<ptr<const ast::link_name_t>> linked_names)
{
	std::set<std::string> names_seen;
	for (auto link_name : linked_names) {
		std::string local_name = {link_name->local_name.text};
		if (in(local_name, ps.type_macros)) {
			user_error(ps.status, link_name->local_name.location,
					"you may not import multiple instances of the same name: " c_id("%s"),
					link_name->local_name.text.c_str());
		}

		std::list<identifier::ref> ids;
		ids.push_back(make_code_id(link_name->extern_module->get_name()));
		ids.push_back(make_code_id(link_name->remote_name));
		auto type_macro_expansion = type_id(reduce_ids(ids, link_name->remote_name.location));

		debug_above(4, log("creating type macro " c_id("%s") " => %s",
					local_name.c_str(),
					type_macro_expansion->str().c_str()));
		ps.type_macros.insert({local_name, type_macro_expansion});
	}
}

ptr<module_t> module_t::parse(parse_state_t &ps) {
	debug_above(6, log("about to parse %s with type_macros: [%s]",
				ps.filename.c_str(),
				join_with(ps.type_macros, ", ", [] (type_macros_t::value_type v) -> std::string {
					return v.first + ": " + v.second->str();
				}).c_str()));

	auto module_decl = module_decl_t::parse(ps);

	if (module_decl != nullptr) {
		std::string module_name = strip_zion_extension(ps.filename);
		ps.module_id = make_iid(module_decl->get_canonical_name());
		assert(ps.module_id != nullptr);

		auto module = create<ast::module_t>(module_decl->token, ps.filename, module_decl->global);
		module->decl.swap(module_decl);

		while (ps.token.is_ident(K(get))) {
			auto get_statement = get_statement_parse(ps);
			if (auto linked_module = dyncast<link_module_statement_t>(get_statement)) {
				module->linked_modules.push_back(linked_module);
			}
		}
		// Get links
		while (ps.token.is_ident(K(link))) {
			auto link_statement = link_statement_parse(ps);
			if (auto linked_function = dyncast<link_function_statement_t>(link_statement)) {
				module->linked_functions.push_back(linked_function);
			} else if (auto linked_var = dyncast<link_var_statement_t>(link_statement)) {
				module->linked_vars.push_back(linked_var);
			} else if (auto linked_name = dyncast<link_name_t>(link_statement)) {
				module->linked_names.push_back(linked_name);
			}
		}
		
		/* TODO: update the parser to contain the type maps from the link_names */
		add_type_macros_to_parser(ps, module->linked_names);

		/* Get vars, functions or type defs */
		while (!!ps.status) {
			if (ps.token.is_ident(K(var)) || ps.token.is_ident(K(let))) {
				bool is_let = ps.token.is_ident(K(let));
				if (is_let) {
					ps.error("let variables are not yet supported at the module level");
				} else {
					ps.advance();
					auto var = var_decl_t::parse(ps, is_let);
					if (!!ps.status) {
						module->var_decls.push_back(var);
					}
				}
			} else if (ps.token.tk == tk_lsquare || ps.token.is_ident(K(def))) {
				/* function definitions */
				auto function = function_defn_t::parse(ps);
				if (!!ps.status) {
					if (function->token.text == "main") {
						bool have_linked_main = false;
						for (auto linked_module : module->linked_modules) {
							if (linked_module->token.text == "main") {
								have_linked_main = true;
								break;
							}
						}
						if (!have_linked_main) {
							ptr<link_module_statement_t> linked_module = create<link_module_statement_t>(ps.token);
							linked_module->link_as_name = token_t(
									function->decl->token.location,
									tk_identifier,
									types::gensym()->get_name());
							linked_module->extern_module = create<ast::module_decl_t>(token_t(
										function->decl->token.location,
										tk_identifier,
										"main"));
							linked_module->extern_module->name = linked_module->extern_module->token;
							module->linked_modules.push_back(linked_module);
						}
					}
					module->functions.push_back(std::move(function));
				}
			} else if (ps.token.is_ident(K(tag))) {
				/* tags */
				auto tag = tag_t::parse(ps);
				if (!!ps.status && tag != nullptr) {
					module->tags.push_back(tag);
					if (module->global) {
						auto id = make_code_id(tag->token);
						ps.type_macros.insert({tag->token.text, type_id(id)});
						ps.global_type_macros.insert({tag->token.text, type_id(id)});
					}
				}
			} else if (ps.token.is_ident(K(type))) {
				/* type definitions */
				auto type_def = type_def_t::parse(ps);
				if (!!ps.status && type_def != nullptr) {
					module->type_defs.push_back(type_def);
					if (module->global) {
						auto id = make_code_id(type_def->token);
						ps.type_macros.insert({type_def->token.text, type_id(id)});
						ps.global_type_macros.insert({type_def->token.text, type_id(id)});
					}
				}
			} else {
				break;
			}
		}

		if (!!ps.status) {
			if (ps.token.is_ident(K(link))) {
				ps.error(C_MODULE "link" C_RESET " directives must come before types, variables, and functions");
			} else if (ps.token.tk != tk_none) {
				ps.error("unexpected '" c_id("%s") "' at top-level module scope (%s)",
						ps.token.text.c_str(), tkstr(ps.token.tk));
			}
		}

        if (!!ps.status) {
            return module;
        }
	}

    assert(!ps.status);
	return nullptr;
}
