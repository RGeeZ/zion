module eightq @1.0
link module math
# test: pass

link def exit(x __int__) void

type Pos has
	var col int
	var row int

[module any]
def str(p Pos) str
	return "(" + p.col + ", " + p.row + ")"

def under_attack(pos, queens) bool
	if len(queens) == 0
		return false

	i := 0	
	while i < len(queens)
		if queen := nth(queens, i)
			if pos.col == queen.col
				return true
			if pos.row == queen.row
				return true
			if math.abs(pos.row-queen.row) == math.abs(pos.col-queen.col)
				return true
		i += 1

	return false

def iter_solve(n) [[Pos]]
	var solutions [[Pos]]
	row := 0
	while row < n
		solutions = check(solutions, row, n)
		row += 1
	return solutions

def check(solutions, row, n) [[Pos]]
	var new_solutions [[Pos]] = nil

	col := 0
	while col < n
		var result [[Pos]]
		if solutions == nil
			result = List(List(Pos(col, row), nil), nil)
		else
			result = append_if_not_under_attack(new_solutions, col, row, solutions)
		new_solutions = result
		col += 1

	return new_solutions

def append_if_not_under_attack(new_solutions [[Pos]], col, row, solutions [[Pos]]) [[Pos]]
	i := 0
	l := len(solutions)

	while i < len(solutions)
		maybe_solution := nth(solutions, i)
		if solution := maybe_solution
			if not under_attack(Pos(col, row), solution)
				new_solutions = conj(new_solutions,
					conj(solution, Pos(col, row)))
		i += 1

	return new_solutions


def main() __int__
	print(iter_solve(8))
	return (0).raw
