# test: pass

fn no_conflict(new_row, new_column, solution) {
    for row in range(new_row) {
        condition := (
            solution[row]       != new_column           and
            solution[row] + row != new_column + new_row and
            solution[row] - row != new_column - new_row)

        if not condition {
            return False
        }
    }

    return True
}

fn copy_and_extend(v, a) {
    n := []
    reserve(n, len(v) + 1)
    for x in v {
        append(n, x)
    }
    append(n, a)
    return n
}

fn add_one_queen(new_row, columns, prev_solutions) [[Int]] {
    solutions := new [[int]]
    reserve(solutions, 92)

    for solution in prev_solutions {
        static_print(solution)
        for new_column in range(columns) {
            static_print(new_column)
            if no_conflict(new_row, new_column, solution) {
                append(solutions, copy_and_extend(solution, new_column))
            }
        }
    }

    return solutions
}

fn queens(rows, columns) {
    solutions := Ref([[]])
    solution := []

    # Introduce an empty solution upon which the dynamic programming algorithm can build
    append(!solutions, solution)

    for row in range(rows) {
        solutions = add_one_queen(row, columns, !solutions)
    }

    return !solutions
}

fn main() {
    solutions := queens(8, 8)
    print(len(solutions))
}
