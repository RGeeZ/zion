module eightq @1.0
link module math
# test: pass

type Pos has
	var col int
	var row int

def under_attack(pos, queens) bool
	if len(queens) == 0
		return false

	i := 0	
	while i < len(queens)
		maybe_queen := nth(queens, i)
		when maybe_queen is Just{Pos}
			queen := maybe_queen.value
			if pos.col == queen.col
				return true
			if pos.row == queen.row
				return true
			if math.abs(pos.row-queen.row) == math.abs(pos.col-queen.col)
				return true
		i += 1

	return false

def iter_solve(n) List{List{Pos}}
	var solutions List{List{Pos}} = Empty
	row := 0
	while row < n
		# solutions = check(solutions, row, n)
		row += 1
	return solutions

def check(solutions, row, n) List{List{Pos}}
	var new_solutions List{List{Pos}} = Empty

	col := 0
	while col < n
		var result List{List{Pos}}
		when solutions is Empty
			result = conj(solutions, Node(Pos(col, row), Empty))
		else
			result = append_if_not_under_attack(new_solutions, col, row, solutions)
		# new_solutions = result
		col += 1

	return new_solutions

def append_if_not_under_attack(new_solutions List{List{Pos}}, col, row, solutions List{List{Pos}}) List{List{Pos}}
	i := 0
	while i < len(solutions)
		maybe_solution := nth(solutions, i)
		when maybe_solution is Just{List{Pos}}
			solution := maybe_solution.value
			if not under_attack(Pos(col, row), solution)
				new_solutions = conj(new_solutions,
					conj(solution, Pos(col, row)))
		i += 1

	return new_solutions

def str(list List{any T}) str
	s := "["
	var seen_one bool = false
	var done bool = false
	static_print(done)
	while not done
		node := list
		when node
			is Node{any T}
				if seen_one
					s += ", "
				else
					seen_one = true

				s += str(node.value)
				list = node.next
			is Empty
				done = true

	return s + "]"

def str(p Pos) str
	return "(" + p.col + ", " + p.row + ")"


def main() void
	print(str(iter_solve(8)))
