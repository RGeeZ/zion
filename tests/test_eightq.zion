# test: pass

fn no_conflict(new_row, new_column, solution) {
    if len(solution) == 0 {
        return True
    }
    for row in range(new_row) {
        condition := (
            solution[row]       != new_column           and
            solution[row] + row != new_column + new_row and
            solution[row] - row != new_column - new_row)

        if not condition {
            return False
        }
    }

    return True
}

fn copy_and_extend(v, a) {
    print("copy_and_extend")
    n := []
    reserve(n, len(v) + 1)
    for x in v {
        append(n, x)
    }
    append(n, a)
    return n
}

fn add_one_queen(new_row, columns, prev_solutions) [[Int]] {
    print("add_one_queen(...)")
    solutions := [[]]
    reserve(solutions, 92)

    print("before loop")
    for solution in prev_solutions {
        print("in loop")
        for new_column in range(columns) {
            print("in loop 2")
            if no_conflict(new_row, new_column, solution) {
                print("pre-inner-append")
                append(solutions, copy_and_extend(solution, new_column))
                print("post-inner-append")
            }
        }
    }

    return solutions
}

fn queens(rows Int, columns Int) [[Int]] {
    var solutions = [[]]
    solution := []

    # Introduce an empty solution upon which the dynamic programming algorithm can build
    append(!solutions, solution)

    for row in range(rows) {
        print(row)
        solutions = add_one_queen(row, columns, !solutions)
    }

    return !solutions
}

fn main() {
    solutions := queens(8, 8)
    print(len(solutions))
}
