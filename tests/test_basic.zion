fn tuple(h) {
    return (h,)
}

data Maybe a {
    Nothing
    Just(a)
}

class Functor f {
    fn fmap(fn (a) b, f a) f b  
}

/*
instance Functor Maybe {
    fn fmap(f, m) => match m {
        Nothing => Nothing
        Just(x) => Just(f(x))
    }
}
*/
class Stringable a {
    fn str(a) str
}

data Ordering is {
    EQ
    LT
    GT
}

class Orderable a {
    fn compare(a, a) -> Ordering
    fn ==(a, a) bool
    fn <=(a, a) bool
    fn <(a, a) bool
    fn >=(a, a) bool
    fn >(a, a) bool
}

class Num a {
    has Orderable a
    fn +(a, a) a
    fn *(a, a) a
    fn -(a, a) a
    fn /(a, a) a
}

instance Orderable (a, b) {
    has Orderable a
    has Orderable b
    fn 
}
    
fn main() {
    return str((2, 3))
}
