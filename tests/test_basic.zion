fn id(x) => x
fn sqr(a) => a * a

fn tuple(h) {
    return (h,)
}

data Maybe a {
    Nothing
    Just(a)
}

class Functor f {
    fn fmap(fn (a) b, f a) f b  
}

fn add(x, y) => x + y
fn twice(f, x) => f(f(x))
fn plus4(x) => twice(add(2))(x)
fn hey() {
    return plus4(3)
}

class Show a {
    fn str(a) String
}

data Ordering {
    EQ
    LT
    GT
}

class Ord a {
    fn compare(a, a) Ordering
}

class Num a {
    has Ord
    fn from_int(Int) a
    fn +(a, a) a
    fn *(a, a) a
    fn -(a, a) a
    fn /(a, a) a
}

instance Num Int {
    let from_int = id
    fn +(x, y) => add_int(x, y)
    fn *(x, y) => multiply_int(x, y)
    fn -(x, y) => subtract_int(x, y)
    fn /(x, y) => divide_int(x, y)
}

fn doit(m) {
    return m
}

fn test_doit() {
    return doit(Just("hey"))
}

fn dd(x) {
    return sqr(x)
}

fn main() {
    return fmap(fn (x) => "str", Just(3))
    # return dd("hey")
}
