module _
# test: pass
# expect: Symbol

get sys

type Node is
	Symbol(s str, pos uint)
	Sequence(nodes [Node])

[global]
def str(n Node) str
	match n
		Symbol(s, pos)
			return "Symbol('" + s + "', " + pos + ")"
		Sequence(nodes)
			return "[" + join(", ", nodes) + "]"

type ParseState has
	let s str
	let i uint

type Step is Step(node Node, ps ParseState)

type Parser = def (ps ParseState) Step?

def parse_token(k str) Parser
	return def (ps ParseState) Step?
		var start = ps.i
		while start < len(ps.s) and isspace(ps.s[start])
			start += 1
		var i = start
		while i < len(ps.s) and i-start < len(k) and k[i-start] == ps.s[i]
			i += 1
		# print("while matching for token '" + k + "' we are at position " + i + " and start = " + start)

		if start != i
			symbol := ps.s[start:i]
			if symbol == k
				return Just(Step(Symbol(symbol, start), ParseState(ps.s, i)))
		return Empty

def parse_symbol(ps ParseState) Step?
	var start = ps.i
	while start < len(ps.s) and isspace(ps.s[start])
		start += 1
	var i = start
	while i < len(ps.s) and isalpha(ps.s[i])
		i += 1

	if start != i
		return Just(Step(Symbol(ps.s[start:i], start), ParseState(ps.s, i)))
	else
		return Empty

def __bitwise_or__(p1 Parser, p2 Parser) Parser
	return def (ps ParseState) Step?
		step := p1(ps)
		match step
			Just(_)
				return step
			else
				return p2(ps)
			
def __backslash__(p1 Parser, p2 Parser) Parser
	return def (ps ParseState) Step?
		step1 := p1(ps)
		match step1
			Just(Step(node1, ps1))
				step2 := p2(ps1)
				match step2
					Just(Step(node2, ps2))
						return Just(Step(Sequence([node1, node2]), ps2))
					Empty
						return Empty
			Empty
				return Empty
			
def __backslash__(s str, p2 Parser) Parser
	return parse_token(s) \ p2
			
def __backslash__(p1 Parser, s str) Parser
	return p1 \ parse_token(s)
			
def parse_kleene_star(parser Parser) Parser
	return def (ps ParseState) Step?
		let nodes [Node]
		while ps.i < len(ps.s)
			match parser(ps)
				Just(Step(node, next_ps))
					append(nodes, node)
					ps = next_ps
				Empty
					break
		return Just(Step(Sequence(nodes), ps))

[global]
def str[Args, R](fn def (..Args) R) str
	return "<closure>"

def main()
	program := "def f x = * x x"
	print(program)
	ps := ParseState(program, 0)

	parse_expr := (parse_token("*") | parse_token("+") | parse_token("-")) \ parse_symbol \ parse_symbol
	parse_parens := "(" \ parse_expr \ ")"
	parser := "def" \ parse_symbol \ parse_kleene_star(parse_symbol) \ "=" \ parse_expr

	step := parser(ps)
	match step
		Empty
			pass
		Just(Step(node, ps))
			print(node)
			print(ps.i)
