module _

type Either L R is
	Left(l L)
	Right(r R)

type Error is Error(message str)

######################
type DataType is DataType(typename str, ctors [Ctor])

type Ctor has
	name str
	arg_types [DataType]
	
type IntSet is
	Exclude(exclude [int])
	Include(include [int])

def empty(set IntSet) bool
	when set is
		Exclude(exclude)
			return false
		Include(include)
			return len(include) == 0
	
[global]
def str(error Error) str
	when error is
		Error(error)
			return "Error: " + error

[global]
def str(set IntSet) str
	when set is
		Exclude(exclude)
			return "Exclude(" + exclude + ")"
		Include(include)
			return "Include(" + include + ")"

type CtorPatternValue has
	typename str
	name str
	args [Pattern]

type Pattern is
	CtorPattern(cpv CtorPatternValue)
	CtorPatterns(patterns [CtorPatternValue])
	AllOf(t DataType)
	Nothing

def pattern_from_type(t DataType) Pattern
	when t is
		DataType(typename, ctors)
			let ctor_patterns [CtorPatternValue]
			for ctor in ctors
				let arg_patterns [Pattern]
				for arg_type in ctor.arg_types
					append(arg_patterns, AllOf(arg_type))
				append(ctor_patterns, CtorPatternValue(typename, ctor.name, arg_patterns))
			return CtorPatterns(ctor_patterns)
			
type Pair T S is Pair(lhs T, rhs S)

def set_union(lhs Pattern, rhs Pattern) Pattern
	# ∪ Operator for Patterns
	when Pair(lhs, rhs) is
		Pair(_, Nothing)
			return lhs
		Pair(Nothing, _)
			return rhs
		Pair(CtorPatterns(lhs), CtorPatterns(rhs))
			let patterns [CtorPatternValue] = copy(lhs)
			for a in rhs
				append(patterns, a)
			return CtorPatterns(patterns)
		Pair(CtorPatterns(lhs), CtorPattern(rhs))
			let patterns [CtorPatternValue] = copy(lhs)
			append(patterns, rhs)
			return CtorPatterns(patterns)
		Pair(CtorPattern(lhs), CtorPatterns(rhs))
			let patterns [CtorPatternValue] = copy(rhs)
			append(patterns, lhs)
			return CtorPatterns(patterns)
		Pair(CtorPattern(lhs), CtorPattern(rhs))
			return CtorPatterns([lhs, rhs])
		else
			panic("Unhandled set_union parameters: " + lhs + " ∪ " + rhs + "\n")
	assert(false)
	return lhs

def set_intersect(lhs Pattern, rhs Pattern) Pattern
	# ∩ Operator for Patterns
	when Pair(lhs, rhs) is
		Pair(Nothing, _)
			return Nothing
		Pair(_, Nothing)
			return Nothing

		# Handle Ctors
		Pair(AllOf(DataType(lhs_typename, lhs_ctors)), AllOf(DataType(rhs_typename, rhs_ctors)))
			if lhs_typename == rhs_typename
				assert(len(lhs_ctors) == len(rhs_ctors))

				# No reduction in the pattern
				return lhs
			else
				panic("Type mismatch. " + lhs_typename + " != " + rhs_typename)
				return Nothing

		# Handle reduction from total domain to a subset
		Pair(AllOf(DataType(lhs_typename, _)), CtorPatterns(ctor_patterns))
			return reduce_all_datatype(lhs_typename, rhs, ctor_patterns)
		Pair(CtorPatterns(ctor_patterns), AllOf(DataType(rhs_typename, _)))
			return reduce_all_datatype(rhs_typename, lhs, ctor_patterns)

		Pair(CtorPatterns(lhs_ctor_patterns), CtorPatterns(rhs_ctor_patterns))
			return set_intersect(lhs_ctor_patterns, rhs_ctor_patterns)
		else
			assert(false)
			return Nothing

def impossible(pattern CtorPatternValue) bool
	for arg in pattern.args
		if impossible(arg)
			return true
		
	return false
	
def impossible(pattern Pattern) bool
	when pattern is
		CtorPattern(ctor_pattern)
			return impossible(ctor_pattern)
		CtorPatterns(ctor_patterns)
			# print("seeing if " + ctor_patterns + " is impossible")
			if len(ctor_patterns) == 0
				return true
			for cp in ctor_patterns
				if impossible(cp)
					return true
			return false
		AllOf(t)
			return false
		Nothing
			return true
		
def set_intersect(lhs [CtorPatternValue], rhs [CtorPatternValue]) Pattern
	var intersect = Nothing
	for a in lhs
		intersect = set_union(foldl(set_cpv_intersect, CtorPattern(a), rhs), intersect)
	return intersect

def set_cpv_intersect(lhs Pattern, rhs CtorPatternValue) Pattern
	when lhs is
		CtorPattern(cpv)
			return set_intersect(cpv, rhs)
		else
			assert(false)
			return Nothing

def set_intersect(lhs CtorPatternValue, rhs CtorPatternValue) Pattern
	assert(lhs.typename == rhs.typename)
	assert(len(rhs.args) == len(lhs.args))

	if rhs.name != rhs.name
		return Nothing

	let reduced_args [Pattern]
	reserve(reduced_args, len(lhs.args))

	for i in range(len(lhs.args))
		new_arg := set_intersect(lhs.args[i], rhs.args[i])
		when new_arg is
			Nothing
				return Nothing
			else
				append(reduced_args, new_arg)

	return CtorPattern(CtorPatternValue(lhs.typename, lhs.name, reduced_args))


def reduce_all_datatype(lhs_typename str, rhs Pattern, ctor_patterns [CtorPatternValue]) Pattern
	for ctor_pattern in ctor_patterns
		if ctor_pattern.typename != lhs_typename
			panic("Invalid typed ctor pattern found. Expected " + lhs_typename
					+ " but ctor_pattern indicates it is a " + ctor_pattern.typename)

	# This is a reduction to the right hand side
	if len(ctor_patterns) == 1
		return CtorPattern(ctor_patterns[0])
	else
		return CtorPatterns(ctor_patterns)

[global]
def str(ctor Ctor) str
	if len(ctor.arg_types) == 0
		return ctor.name
	return ctor.name + "(" + join(", ", ctor.arg_types) + ")"

[global]
def str(t DataType) str
	when t is
		DataType(typename, ctors)
			return typename #  + ": DataType(" + join(", ", ctors) + ")"

[global]
def str(pattern Pattern) str
	when pattern is
		CtorPattern(ctor_pattern)
			return "CtorPattern(" + ctor_pattern + ")"
		CtorPatterns(ctor_patterns)
			return "CtorPatterns(" + ctor_patterns + ")"
		AllOf(t)
			return "AllOf(" + t + ")"
		Nothing
			return "Nothing"
		else
			assert(false)
			return "FAIL"
	
[global]
def str(ctor_pattern CtorPatternValue) str
	args := ctor_pattern.args
	if len(args) == 0
		return ctor_pattern.name
	return ctor_pattern.name + "(" + args + ")"
	
type Coverage has
	covered Pattern
	uncovered Pattern

[global]
def str(cov Coverage) str
	return "Coverage(" + cov.covered + ", " + cov.uncovered + ")"

type Sender = def (pattern Pattern) void

def set_difference(lhs CtorPatternValue, rhs CtorPatternValue, send Sender)
	print("set_difference(" + lhs + ", " + rhs + ")")
	assert(lhs.typename == rhs.typename)
	assert(len(rhs.args) == len(lhs.args))

	if lhs.name != rhs.name
		send(CtorPattern(lhs))

	if len(lhs.args) == 0
		send(Nothing)
	else
		for i in range(len(lhs.args))
			send_ctor_pattern := def (arg Pattern)
				when arg is
					Nothing
						send(Nothing)
					else
						args := copy(lhs.args)
						args[i] = arg
						send(CtorPattern(CtorPatternValue(lhs.typename, lhs.name, args)))

			set_difference(lhs.args[i], rhs.args[i], send_ctor_pattern)
					
	
def set_difference(lhs Pattern, rhs Pattern, send Sender) void
	# Set difference on patterns
	when Pair(lhs, rhs) is
		Pair(_, Nothing)
			# Identity
			send(Nothing)

		Pair(Nothing, _)
			# Unit
			send(Nothing)

		Pair(AllOf(DataType(typename2, _)), AllOf(DataType(typename1, _)))
			if typename1 == typename2
				send(Nothing)
			else
				panic("Type mismatch.")

		Pair(AllOf(_), AllOf(_))
			panic("Type mismatch.")

		Pair(_, AllOf(t))
			set_difference(lhs, pattern_from_type(t), send)

		Pair(AllOf(t), _)
			set_difference(pattern_from_type(t), rhs, send)

		Pair(CtorPatterns(lhs), CtorPatterns(_))
			# Iterate over all the initial patterns
			for a in lhs
				set_difference(CtorPattern(a), rhs, send)

		Pair(CtorPattern(lhs), CtorPatterns(rhs))
			# Make a state machine to compose the difference per sub-pattern
			var new_a = Ref(Nothing)
			new_a_send := def (p Pattern)
				new_a.value = set_union(new_a.value, p)

			# Simplify a bit
			new_a.value = CtorPattern(lhs)

			# Iterate over all the things to subtract
			for b in rhs
				# compose...
				current_a := new_a.value
				new_a.value = Nothing

				# Compute the difference at this level, and join it 
				set_difference(current_a, CtorPattern(b), new_a_send)

			send(new_a.value)

		Pair(CtorPatterns(lhs), CtorPattern(rhs))
			for a in lhs
				set_difference(a, rhs, send)

		Pair(CtorPatterns(_), _)
			panic("Type mismatch. " + lhs + " != " + rhs)

		Pair(_, CtorPatterns(_))
			panic("Type mismatch. " + lhs + " != " + rhs)

		Pair(CtorPattern(lhs), CtorPattern(rhs))
			set_difference(lhs, rhs, send)

		else
			panic("Unmatched Pair(" + lhs + ", " + rhs + ")")

[global]
def str(c Either any T any Q) str
	when c is
		Left(t)
			return str(t)
		Right(q)
			return str(q)

type Ref T has
	var value T

def get_set_difference(lhs Pattern, rhs Pattern) Pattern
	var final_difference = Ref(Nothing)

	send := def (p Pattern)
		print("Found: " + p)
		final_difference.value = set_union(p, final_difference.value)

	set_difference(lhs, rhs, send)
	print(str(lhs) + " - " + rhs + " = " + final_difference.value)
	return final_difference.value

def main()
	let empty_types [DataType]
	Bool := DataType("Bool", [Ctor("True", empty_types), Ctor("False", empty_types)])
	Brightness := DataType("Brightness", [
		Ctor("High", empty_types),
		Ctor("Medium", empty_types),
		Ctor("Low", empty_types),
	])

	Color := DataType("Color", [
		Ctor("Red", [Brightness]),
		Ctor("Green", [Brightness]),
		Ctor("Ble", [Brightness]),
	])

	Pair := DataType("Pair", [Ctor("Pair", [Bool, Bool])])
	ColorPair := DataType("ColorPair", [Ctor("ColorPair", [Color, Color])])

	let empty_patterns [Pattern] = []
	True := CtorPatternValue("Bool", "True", empty_patterns)
	False := CtorPatternValue("Bool", "False", empty_patterns)
	bool_pattern := AllOf(Bool)
	true_pattern := CtorPattern(True)
	# get_set_difference(bool_pattern, true_pattern)

	get_set_difference(
			CtorPatterns([
				CtorPatternValue("Pair", "Pair", [AllOf(Bool), AllOf(Bool)])
			]),
			CtorPatterns([
				CtorPatternValue("Pair", "Pair", [CtorPatterns([True]), CtorPatterns([False])]),
				CtorPatternValue("Pair", "Pair", [CtorPatterns([False]), CtorPatterns([True])]),
				CtorPatternValue("Pair", "Pair", [CtorPatterns([False]), CtorPattern(False)]),
				CtorPatternValue("Pair", "Pair", [AllOf(Bool), CtorPatterns([True])]),
				CtorPatternValue("Pair", "Pair", [AllOf(Bool), CtorPatterns([True])]),
			]))
