module _

type Either L R is
	Left(l L)
	Right(r R)

type Error is Error(message str)

######################
type Type is
	Integer
	DataType(typename str, ctors [Ctor])

type Ctor has
	name str
	arg_types [Type]
	
type CtorPattern has
	typename str
	name str
	args [Pattern]

type IntSet is
	Exclude(exclude [int])
	Include(include [int])

def empty(set IntSet) bool
	when set is
		Exclude(exclude)
			return false
		Include(include)
			return len(include) == 0
	
[global]
def str(set IntSet) str
	when set is
		Exclude(exclude)
			return "Exclude(" + exclude + ")"
		Include(include)
			return "Include(" + include + ")"

type Pattern is
	CtorPatterns(ctor_patterns [CtorPattern])
	Integers(set IntSet)
	AllOf(t Type)
	Nothing

def pattern_from_type(t Type) Pattern
	when t is
		Integer
			let ints [int]
			return Integers(Exclude(ints))
		DataType(typename, ctors)
			let ctor_patterns [CtorPattern]
			for ctor in ctors
				let patterns [Pattern]
				for arg_type in ctor.arg_types
					append(patterns, AllOf(arg_type))
				append(ctor_patterns, CtorPattern(typename, ctor.name, patterns))
			return CtorPatterns(ctor_patterns)
			
type Pair T S is Pair(lhs T, rhs S)

def __bitwise_and__(lhs Either Pattern Error, rhs Either Pattern Error) Either Pattern Error
	when Pair(lhs, rhs) is
		Pair(Right(Error(lhs_message)), Right(Error(rhs_message)))
			return Right(Error("Error! " + lhs_message + " and " + rhs_message))
		Pair(Right(_), _)
			return lhs
		Pair(_, Right(_))
			return rhs
		Pair(Left(lhs), Left(rhs))
			return set_intersect(lhs, rhs)

def set_difference(lhs [int], rhs [int]) [int]
	let new [int]
	for l in lhs
		if l not in rhs
			append(new, l)
	return new
			
def set_intersect(lhs [int], rhs [int]) [int]
	let new [int]
	for l in lhs
		if l in rhs
			append(new, l)
	return new
			
def set_union(lhs [int], rhs [int]) [int]
	let new [int] = copy(lhs)
	for r in rhs
		if r not in new
			append(new, r)
	return new

def set_difference(lhs IntSet, rhs IntSet) IntSet
	when Pair(lhs, rhs) is
		Pair(Exclude(lhs_exclude), Exclude(rhs_exclude))
			return Include(set_difference(rhs_exclude, lhs_exclude))
		Pair(Exclude(exclude), Include(include))
			return Exclude(set_union(exclude, include))
		Pair(Include(include), Exclude(exclude))
			return Include(set_intersect(include, exclude))
		Pair(Include(lhs_include), Include(rhs_include))
			return Include(set_difference(lhs_include, rhs_include))

def set_intersect(lhs IntSet, rhs IntSet) IntSet
	when Pair(lhs, rhs) is
		Pair(Exclude(lhs_exclude), Exclude(rhs_exclude))
			return Exclude(set_union(lhs_exclude, rhs_exclude))
		Pair(Exclude(exclude), Include(include))
			return Include(set_difference(include, exclude))
		Pair(Include(include), Exclude(exclude))
			return Include(set_difference(include, exclude))
		Pair(Include(lhs_include), Include(rhs_include))
			return Include(set_intersect(lhs_include, rhs_include))

def set_intersect(lhs Pattern, rhs Pattern) Either Pattern Error
	when Pair(lhs, rhs) is
		Pair(Nothing, _)
			return Left(Nothing)
		Pair(_, Nothing)
			return Left(Nothing)

		# Handle Integer reduction from the entire domain of integers
		Pair(AllOf(Integer), Integers(_))
			return Left(rhs)
		Pair(Integers(_), AllOf(Integer))
			return Left(lhs)

		# Handle Integer set intersection
		Pair(Integers(lhs_set), Integers(rhs_set))
			return Left(Integers(set_intersect(lhs_set, rhs_set)))

		# Handle Ctors
		Pair(AllOf(DataType(lhs_typename, lhs_ctors)), AllOf(DataType(rhs_typename, rhs_ctors)))
			if lhs_typename == rhs_typename
				assert(len(lhs_ctors) == len(rhs_ctors))

				# No reduction in the pattern
				return Left(lhs)
			else
				return Right(Error("Type mismatch. " + lhs_typename + " != " + rhs_typename))

		# Handle reduction from total domain to a subset
		Pair(AllOf(DataType(lhs_typename, _)), CtorPatterns(ctor_patterns))
			return reduce_all_datatype(lhs_typename, rhs, ctor_patterns)
		Pair(CtorPatterns(ctor_patterns), AllOf(DataType(rhs_typename, _)))
			return reduce_all_datatype(rhs_typename, lhs, ctor_patterns)

		Pair(CtorPatterns(lhs_ctor_patterns), CtorPatterns(rhs_ctor_patterns))
			return reduce_ctor_patterns(lhs_ctor_patterns, rhs_ctor_patterns)
		else
			assert(false)
			return Right(Error("Not implemented"))

def impossible(pattern CtorPattern) bool
	for arg in pattern.args
		if impossible(arg)
			return true
		
	return false
	
def impossible(pattern Pattern) bool
	when pattern is
		CtorPatterns(ctor_patterns)
			for cp in ctor_patterns
				if impossible(cp)
					return true
			return false
		Integers(set)
			if empty(set)
				return true
			return false
		AllOf(t)
			return false
		Nothing
			return true
		
def reduce_ctor_patterns(lhs_ctor_patterns, rhs_ctor_patterns) Either Pattern Error
	let final_ctor_patterns [CtorPattern]
	for lhs_cp in lhs_ctor_patterns
		reduced_typename := lhs_cp.typename
		reduced_name := lhs_cp.name
		reduced_args := copy(lhs_cp.args)

		for rhs_cp in rhs_ctor_patterns
			if lhs_cp.typename != rhs_cp.typename
				return Right(
					Error("Type mismatch in patterns. " + lhs_cp.typename + " != " +
						rhs_cp.typename))
			if len(rhs_cp.args) != len(reduced_args)
				return Right(
					Error("Different number of patterns in ctors. |" + lhs_cp.name + "| != |" +
						rhs_cp.name + "|"))

			if rhs_cp.name == reduced_name
				for i in range(len(reduced_args))
					result := set_intersect(reduced_args[i], rhs_cp.args[i])
					when result is
						Left(pattern)
							reduced_args[i] = pattern
						Right(_)
							return result

		reduced_pattern := CtorPattern(reduced_typename, reduced_name, reduced_args)
		if impossible(reduced_pattern)
			continue
		append(final_ctor_patterns, reduced_pattern)

	if len(final_ctor_patterns) == 0
		return Right(Error("No patterns remain"))
	else
		return Left(CtorPatterns(final_ctor_patterns))


def reduce_all_datatype(lhs_typename str, rhs Pattern, ctor_patterns [CtorPattern]) Either Pattern Error
	for ctor_pattern in ctor_patterns
		if ctor_pattern.typename != lhs_typename
			return Right(
				Error(
					"Invalid typed ctor pattern found. Expected " + lhs_typename
					+ " but ctor_pattern indicates it is a " + ctor_pattern.typename))

	# This is a reduction to the right hand side
	return Left(rhs)

[global]
def str(ctor Ctor) str
	if len(ctor.arg_types) == 0
		return ctor.name
	return ctor.name + "(" + join(", ", ctor.arg_types) + ")"

[global]
def str(t Type) str
	when t is
		Integer
			return "Integer"
		DataType(typename, ctors)
			return typename + ": DataType(" + join(", ", ctors) + ")"

[global]
def str(pattern Pattern) str
	print("switching on " + runtime.__get_ctor_id(pattern as! *var_t))
	when pattern is
		CtorPatterns(ctor_patterns)
			return "CtorPatterns(" + ctor_patterns + ")"
		AllOf(t)
			return "AllOf(" + t + ")"
		Nothing
			return "Nothing"
		Integers(set)
			return "Integers(" + set + ")"
		else
			assert(false)
			return "FAIL"
	
[global]
def str(ctor_pattern CtorPattern) str
	print("ctor id of ctor pattern is " + runtime.__get_ctor_id(ctor_pattern as! *var_t))
	args := ctor_pattern.args
	if len(args) == 0
		return ctor_pattern.name
	print("len(args) = " + len(args))
	# for arg in args
	# print("- " + arg)
	
	return ctor_pattern.name + "(" + args + ")"
	
type Coverage has
	covered Pattern
	uncovered Pattern

[global]
def str(cov Coverage) str
	return "Coverage(" + cov.covered + ", " + cov.uncovered + ")"

def impossible_pattern_to_match(pattern Pattern) bool
	when pattern is
		Nothing
			return true
		Integers(set)
			return empty(set)
		else
			return false

def cover(to_cover Pattern, uncovered Pattern) Either Coverage Error
	# Compute the final covering of this incoming pattern
	# Also compute the final uncovered pattern
	either := set_intersect(to_cover, uncovered)
	when either is
		Right(error)
			return Right(error)
		Left(pattern)
			print("cover(" + to_cover + ", " + uncovered + ") calling cover2(" + pattern + ", " +
					uncovered + ")")
			return cover2(pattern, uncovered)

def ctor_patterns_difference(lhs CtorPattern, rhs CtorPattern) [CtorPattern]
	assert(lhs.typename == rhs.typename)
	if lhs.name != rhs.name
		print("ctor_patterns_difference(" + lhs + ", " + rhs + ") => " + [lhs])
		return [lhs]
	assert(len(lhs.args) == len(rhs.args))
	
	let difference [CtorPattern]
	print("len(lhs.args) = " + len(lhs.args))
	for i in range(len(lhs.args))
		print("i = " + i)
		result := cover(rhs.args[i], lhs.args[i])
		when result is
			Left(coverage)
				print("coverage.uncovered = " + coverage.uncovered)
				when coverage.uncovered is 
					CtorPatterns(ctor_patterns)
						for a in ctor_patterns
							let args [Pattern] = copy(lhs.args)
							assert(i < len(args) and i >= 0)
							print("replacing " + args[i] + " with " + a + " with ctor id " + runtime.__get_ctor_id(a as! *var_t))
							args[i] = a
							append(difference, CtorPattern(lhs.typename, lhs.name, args))
					Nothing
						pass
					else
						assert(false)
			Right(Error(message))
				print("swallowing error " + message)

	print("ctor_patterns_difference(" + lhs + ", " + rhs + ") => " + difference)
	return difference
					
	
def ctor_patterns_difference(lhs_patterns [CtorPattern], rhs CtorPattern) [CtorPattern]
	let ctor_patterns [CtorPattern]
	for lhs in lhs_patterns
		for remaining in ctor_patterns_difference(lhs, rhs)
			append(ctor_patterns, remaining)
		
	print("ctor_patterns_difference(" + lhs_patterns + ", " + rhs + ") => " + ctor_patterns)
	return ctor_patterns

def cover2(covered Pattern, uncovered Pattern) Either Coverage Error
	# `covered` is guaranteed to only contain patterns covered by uncovered, that is
	# it should only be useful for covering uncovered.
	# Now the trick is to visit the covered and the uncovered in parallel, and generate new uncovered patterns

	when Pair(covered, uncovered) is
		Pair(AllOf(Integer), AllOf(Integer))
			return Left(Coverage(covered, Nothing))
		Pair(AllOf(DataType(typename1, _)), AllOf(DataType(typename2, _)))
			if typename1 == typename2
				return Left(Coverage(covered, Nothing))
			else
				return Right(Error("Type mismatch."))
		Pair(AllOf(t), _)
			return cover2(pattern_from_type(t), uncovered)
		Pair(_, AllOf(t))
			return cover2(covered, pattern_from_type(t))
		Pair(Nothing, _)
			return Right(Error("This pattern will never match."))
		Pair(_, Nothing)
			return Right(Error("Nothing left to cover."))

		Pair(CtorPatterns(lhs), CtorPatterns(rhs))
			let working_set_uncovered [CtorPattern]
			for p in lhs
				# Remove each pattern from the "covering" side from the uncovered set
				for j in ctor_patterns_difference(rhs, p)
					append(working_set_uncovered, j)
			return Left(Coverage(covered, CtorPatterns(working_set_uncovered)))
		Pair(CtorPatterns(_), _)
			return Right(Error("Type mismatch"))
		Pair(_, CtorPatterns(_))
			return Right(Error("Type mismatch"))

		Pair(Integers(covered_set), Integers(uncovered_set))
			return Left(Coverage(covered, Integers(set_difference(uncovered_set, covered_set))))

		else
			return Right(Error("Unmatched Pair(" + covered + ", " + uncovered + ")"))

def main()
	let empty_types [Type]
	Bool := DataType("Bool", [Ctor("True", empty_types), Ctor("False", empty_types)])
	Pair := DataType("Pair", [Ctor("Pair", [Bool, Bool])])

	let empty_pattern [Pattern]
	True := CtorPattern("Bool", "True", empty_pattern)
	False := CtorPattern("Bool", "False", empty_pattern)

	c := cover(
			CtorPatterns([
				CtorPattern("Pair", "Pair", [CtorPatterns([True]), AllOf(Bool)])
			]),
			CtorPatterns([
				CtorPattern("Pair", "Pair", [AllOf(Bool), AllOf(Bool)])
			]))

	when c is
		Left(coverage)
			print(coverage)
		Right(Error(message))
			print("Error: " + message)

