#include <stdlib.h>
#include <string>
#include "ast.h"
#include "token.h"
#include "logger_decls.h"
#include <csignal>
#include "parse_state.h"
#include "parser.h"
#include "code_id.h"

using namespace ast;


#define eat_token_or_return(fail_code) \
	do { \
		debug_above(9, log(log_info, "eating a %s", tkstr(ps.token.tk))); \
		ps.advance(); \
	} while (0)

#define eat_token() eat_token_or_return(nullptr)

#define expect_token_or_return(_tk, fail_code) \
	do { \
		if (ps.token.tk != _tk) { \
			ps.error("expected '%s', got '%s'", \
				   	tkstr(_tk), tkstr(ps.token.tk)); \
			/* dbg(); */ \
			return fail_code; \
		} \
	} while (0)

#define expect_token(_tk) expect_token_or_return(_tk, nullptr)

#define chomp_token_or_return(_tk, fail_code) \
	do { \
		expect_token_or_return(_tk, fail_code); \
		eat_token_or_return(fail_code); \
	} while (0)
#define chomp_token(_tk) chomp_token_or_return(_tk, nullptr)

ptr<var_decl> var_decl::parse(parse_state_t &ps) {
	expect_token(tk_identifier);

	auto var_decl = create<ast::var_decl>(ps.token);
	eat_token();

	if (ps.token.tk != tk_assign) {
		var_decl->type = parse_maybe_type(ps, {}, {}, {} /*generics*/);
	} else {
		var_decl->type = type_variable(ps.prior_token.location);
	}

	if (!!ps.status) {
		if (ps.token.tk == tk_assign) {
			eat_token();
			var_decl->initializer = expression::parse(ps);
		}

		return var_decl;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<var_decl> var_decl::parse_param(parse_state_t &ps) {
	expect_token(tk_identifier);

	auto var_decl = create<ast::var_decl>(ps.token);
	eat_token();

	if (ps.token.tk == tk_assign) {
		ps.error("default values for function arguments are not a thing");
		return nullptr;
	} else if (ps.token.tk == tk_comma || ps.token.tk == tk_rparen) {
		/* ok, let's inject an autogenerated token */
		var_decl->type = type_variable(ps.token.location);
	} else {
		var_decl->type = parse_maybe_type(ps, {}, {}, {});
	}

	return var_decl;
}

ptr<return_statement> return_statement::parse(parse_state_t &ps) {
	auto return_statement = create<ast::return_statement>(ps.token);
	chomp_token(tk_return);
	if (!ps.line_broke() && ps.token.tk != tk_outdent) {
		return_statement->expr = expression::parse(ps);
		if (!return_statement->expr) {
			assert(!ps.status);
			return nullptr;
		}
	}
	return return_statement;
}

ptr<statement> link_statement_parse(parse_state_t &ps) {
	expect_token(tk_link);
	auto link_token = ps.token;
	ps.advance();

	if (ps.token.tk == tk_lsquare || ps.token.tk == tk_def) {
		auto link_function_statement = create<ast::link_function_statement>(link_token);
		auto function_decl = function_decl::parse(ps);
		if (function_decl) {
			link_function_statement->function_name = function_decl->token;
			link_function_statement->extern_function = function_decl;
		} else {
			assert(!ps.status);
		}
		return link_function_statement;
	} else {
		auto link_statement = create<link_module_statement>(link_token);

		if (ps.token.tk == tk_identifier) {
			link_statement->link_as_name = ps.token;
			ps.advance();
			chomp_token(tk_to);
		}

		if (ps.token.tk == tk_module) {
			auto module_decl = module_decl::parse(ps);
			if (module_decl) {
				if (link_statement->link_as_name.tk == tk_none) {
					link_statement->link_as_name = module_decl->get_name();
				}
				if (link_statement->link_as_name.tk != tk_identifier) {
					ps.error("expected an identifier for link module name (either implicit or explicit)");
				}
				link_statement->extern_module.swap(module_decl);
			} else {
				assert(!ps.status);
			}
		} else {
			ps.error("link must be followed by function declaration or module import");
		}

		return link_statement;
	}
}

ptr<statement> statement::parse(parse_state_t &ps) {
	assert(ps.token.tk != tk_outdent);

	if (ps.token.tk == tk_var) {
		eat_token();
		return var_decl::parse(ps);
	} else if (ps.token.tk == tk_if) {
		return if_block::parse(ps);
	} else if (ps.token.tk == tk_while) {
		return while_block::parse(ps);
	} else if (ps.token.tk == tk_when) {
		return when_block::parse(ps);
	} else if (ps.token.tk == tk_return) {
		return return_statement::parse(ps);
	} else if (ps.token.tk == tk_type) {
		return type_def::parse(ps);
	} else if (ps.token.tk == tk_link) {
		return link_statement_parse(ps);
	} else if (ps.token.tk == tk_pass) {
		auto pass_flow = create<ast::pass_flow>(ps.token);
		eat_token();
		return std::move(pass_flow);
	} else if (ps.token.tk == tk_continue) {
		auto continue_flow = create<ast::continue_flow>(ps.token);
		eat_token();
		return std::move(continue_flow);
	} else if (ps.token.tk == tk_def) {
		return function_defn::parse(ps);
	} else if (ps.token.tk == tk_break) {
		auto break_flow = create<ast::break_flow>(ps.token);
		eat_token();
		return std::move(break_flow);
	} else {
		return assignment::parse(ps);
	}
}

ptr<expression> reference_expr::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_identifier) {
		auto reference_expr = create<ast::reference_expr>(ps.token);
		ps.advance();
		return std::move(reference_expr);
	} else {
		ps.error("expected an identifier");
		return nullptr;
	}
}

ptr<typeid_expr> typeid_expr::parse(parse_state_t &ps) {
	auto token = ps.token;
	chomp_token(tk_get_typeid);
	chomp_token(tk_lparen);

	auto value = expression::parse(ps);
	if (!!ps.status) {
		assert(value != nullptr);
		auto expr = ast::create<typeid_expr>(token, value);
		chomp_token(tk_rparen);
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<sizeof_expr> sizeof_expr::parse(parse_state_t &ps) {
	auto token = ps.token;
	chomp_token(tk_sizeof);
	chomp_token(tk_lparen);

	auto type = parse_maybe_type(ps, {}, {}, {});
	if (!!ps.status) {
		assert(type != nullptr);
		auto expr = ast::create<sizeof_expr>(token, type);
		chomp_token(tk_rparen);
		return expr;
	}

	assert(!ps.status);
	return nullptr;
}

ptr<expression> parse_bang_wrap(parse_state_t &ps, ptr<expression> expr) {
    if (ps.token.tk == tk_bang) {
        auto bang = ast::create<ast::bang_expr>(ps.token);
        bang->lhs = expr;
        ps.advance();
        return bang;
    } else {
        return expr;
    }
}

ptr<expression> parse_cast_wrap(parse_state_t &ps, ptr<expression> expr) {
    if (ps.token.tk == tk_as) {
		auto token = ps.token;
		ps.advance();
		auto cast = ast::create<ast::cast_expr>(token);
		cast->lhs = expr;

		if (ps.token.tk == tk_bang) {
			ps.advance();
			cast->force_cast = true;
		}
		cast->type_cast = parse_maybe_type(ps, {}, {}, {});
        return cast;
    } else {
        return expr;
    }
}

ptr<expression> base_expr::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_lparen) {
		return tuple_expr::parse(ps);
	} else if (ps.token.tk == tk_identifier) {
		return reference_expr::parse(ps);
	} else if (ps.token.tk == tk_get_typeid) {
		return typeid_expr::parse(ps);
	} else if (ps.token.tk == tk_sizeof) {
		return sizeof_expr::parse(ps);
	} else {
		return literal_expr::parse(ps);
	}
}

ptr<expression> array_literal_expr::parse(parse_state_t &ps) {
	chomp_token(tk_lsquare);
	auto array = create<array_literal_expr>(ps.token);
	auto &items = array->items;

	int i = 0;
	while (ps.token.tk != tk_rsquare && ps.token.tk != tk_none) {
		++i;
		auto item = expression::parse(ps);
		if (item) {
			items.push_back(item);
		} else {
			assert(!ps.status);
		}
		if (ps.token.tk == tk_comma) {
			ps.advance();
		} else if (ps.token.tk != tk_rsquare) {
			ps.error("found something that does not make sense in an array literal");
			break;
		}
	}
	chomp_token(tk_rsquare);
	return array;
}

ptr<expression> literal_expr::parse(parse_state_t &ps) {
	switch (ps.token.tk) {
	case tk_integer:
	case tk_string:
	case tk_char:
	case tk_float:
		{
			auto literal_expr = create<ast::literal_expr>(ps.token);
			ps.advance();
			return std::move(literal_expr);
		}
	case tk_lsquare:
		return array_literal_expr::parse(ps);
	case tk_def:
		return function_defn::parse(ps);
	case tk_indent:
		ps.error("unexpected indent");
		return nullptr;

	default:
		ps.error("out of place token '" c_id("%s") "' (%s)",
			   	ps.token.text.c_str(), tkstr(ps.token.tk));
		return nullptr;
	}
}

namespace ast {
	namespace postfix_expr {
		ptr<expression> parse(parse_state_t &ps) {
			ptr<expression> expr = base_expr::parse(ps);
			if (!expr) {
				assert(!ps.status);
				return nullptr;
			}

			while (!ps.line_broke() && (ps.token.tk == tk_lsquare || ps.token.tk == tk_lparen || ps.token.tk == tk_dot)) {
				if (ps.token.tk == tk_lparen) {
					/* function call */
					auto callsite = create<callsite_expr>(ps.token);
					auto params = param_list::parse(ps);
					if (params) {
						callsite->params.swap(params);
						callsite->function_expr.swap(expr);
						assert(expr == nullptr);
						expr = callsite;
					} else {
						assert(!ps.status);
					}
				}
				if (ps.token.tk == tk_dot) {
					auto dot_expr = create<ast::dot_expr>(ps.token);
					eat_token();
					expect_token(tk_identifier);
					dot_expr->rhs = ps.token;
					ps.advance();
					dot_expr->lhs.swap(expr);
					assert(expr == nullptr);
                    expr = dot_expr;
				}
				if (ps.token.tk == tk_lsquare) {
					eat_token();
					auto array_index_expr = create<ast::array_index_expr>(ps.token);

					auto index = expression::parse(ps);
					if (index) {
						array_index_expr->index.swap(index);
						array_index_expr->lhs.swap(expr);
						assert(expr == nullptr);
						expr = array_index_expr;
					} else {
						assert(!ps.status);
						return nullptr;
					}
					chomp_token(tk_rsquare);
				}
			}

			if (!!ps.status) {
				expr = parse_bang_wrap(ps, expr);

				if (!!ps.status) {
					return parse_cast_wrap(ps, expr);
				}
			}

			assert(!ps.status);
			return nullptr;
		}
	}
}

ptr<expression> prefix_expr::parse(parse_state_t &ps) {
	ptr<prefix_expr> prefix_expr;
	if (ps.token.tk == tk_not
			|| ps.token.tk == tk_minus
			|| ps.token.tk == tk_plus)
	{
		prefix_expr = create<ast::prefix_expr>(ps.token);
		eat_token();
	}

	ptr<expression> rhs;
	if (ps.token.tk == tk_not
			|| ps.token.tk == tk_minus
			|| ps.token.tk == tk_plus) {
		/* recurse to find more prefix expressions */
		rhs = prefix_expr::parse(ps);
	} else {
		/* ok, we're done with prefix operators */
		rhs = postfix_expr::parse(ps);
	}

	if (rhs) {
		if (prefix_expr) {
			prefix_expr->rhs = std::move(rhs);
			return std::move(prefix_expr);
		} else {
			return rhs;
		}
	} else {
		assert(!ps.status);
		return nullptr;
	}
}

ptr<expression> times_expr::parse(parse_state_t &ps) {
	auto expr = prefix_expr::parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && (ps.token.tk == tk_times
			   	|| ps.token.tk == tk_divide_by
			   	|| ps.token.tk == tk_mod)) {
		auto times_expr = create<ast::times_expr>(ps.token);

		eat_token();

		auto rhs = prefix_expr::parse(ps);
		if (rhs) {
			times_expr->lhs = std::move(expr);
			times_expr->rhs = std::move(rhs);
			expr = std::move(times_expr);
		} else {
			ps.error("unable to parse right hand side of times_expr");
			return nullptr;
		}
	}

	return expr;
}

ptr<expression> plus_expr::parse(parse_state_t &ps) {
	auto expr = times_expr::parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && (ps.token.tk == tk_plus || ps.token.tk == tk_minus)) {
		auto plus_expr = create<ast::plus_expr>(ps.token);

		eat_token();

		auto rhs = times_expr::parse(ps);
		if (rhs) {
			plus_expr->lhs = std::move(expr);
			plus_expr->rhs = std::move(rhs);
			expr = std::move(plus_expr);
		} else {
			ps.error("unable to parse right hand side of plus_expr");
			return nullptr;
		}
	}

	return expr;
}

ptr<expression> ineq_expr::parse(parse_state_t &ps) {
	auto lhs = plus_expr::parse(ps);
	if (lhs) {
		if (ps.line_broke()
				|| !(ps.token.tk == tk_gt
					|| ps.token.tk == tk_gte
					|| ps.token.tk == tk_lt
					|| ps.token.tk == tk_lte)) {
			/* there is no rhs */
			return lhs;
		}

		auto ineq_expr = create<ast::ineq_expr>(ps.token);

		eat_token();

		auto rhs = plus_expr::parse(ps);
		if (rhs) {
			ineq_expr->lhs = std::move(lhs);
			ineq_expr->rhs = std::move(rhs);
			return std::move(ineq_expr);
		} else {
			ps.error("unable to parse right hand side of ineq_expr");
			return nullptr;
		}
	} else {
		assert(!ps.status);
		return nullptr;
	}
}

ptr<expression> eq_expr::parse(parse_state_t &ps) {
	auto lhs = ineq_expr::parse(ps);
	if (lhs) {
		bool not_in = false;
		if (ps.token.tk == tk_not) {
			eat_token();
			expect_token(tk_in);
			not_in = true;
		}

		if (ps.line_broke() ||
				!(ps.token.tk == tk_in
					|| ps.token.tk == tk_equal
					|| ps.token.tk == tk_inequal)) {
			/* there is no rhs */
			return lhs;
		}

		auto eq_expr = create<ast::eq_expr>(ps.token);
		eq_expr->not_in = not_in;

		eat_token();

		auto rhs = ineq_expr::parse(ps);
		if (rhs) {
			eq_expr->lhs = std::move(lhs);
			eq_expr->rhs = std::move(rhs);
			return std::move(eq_expr);
		} else {
			ps.error("unable to parse right hand side of eq_expr");
			return nullptr;
		}
	} else {
		assert(!ps.status);
		return nullptr;
	}
}

ptr<expression> and_expr::parse(parse_state_t &ps) {
	auto expr = eq_expr::parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && (ps.token.tk == tk_and)) {
		auto and_expr = create<ast::and_expr>(ps.token);

		eat_token();

		auto rhs = eq_expr::parse(ps);
		if (rhs) {
			and_expr->lhs = std::move(expr);
			and_expr->rhs = std::move(rhs);
			expr = std::move(and_expr);
		} else {
			ps.error("unable to parse right hand side of and_expr");
			return nullptr;
		}
	}

	return expr;
}

ptr<expression> tuple_expr::parse(parse_state_t &ps) {
	auto start_token = ps.token;
	chomp_token(tk_lparen);
	auto expr = or_expr::parse(ps);
	if (ps.token.tk != tk_comma) {
		chomp_token(tk_rparen);
		return expr;
	} else {
		ps.advance();

		/* we've got a tuple */
		auto tuple_expr = create<ast::tuple_expr>(start_token);

		/* add the first value */
		tuple_expr->values.push_back(expr);

		/* now let's find the rest of the values */
		while (ps.token.tk != tk_rparen) {
			expr = or_expr::parse(ps);
			if (expr) {
				tuple_expr->values.push_back(expr);
				if (ps.token.tk == tk_comma) {
					eat_token();
				} else if (ps.token.tk != tk_rparen) {
					ps.error(
						"unexpected token " c_id("%s") " in tuple. expected comma or right-paren",
						ps.token.text.c_str());
					return nullptr;
				}
				// continue and read the next parameter
			} else {
				assert(!ps.status);
				return nullptr;
			}
		}
		chomp_token(tk_rparen);
		return tuple_expr;
	}
}

ptr<expression> or_expr::parse(parse_state_t &ps) {
	auto expr = and_expr::parse(ps);
	if (!expr) {
		assert(!ps.status);
		return nullptr;
	}

	while (!ps.line_broke() && (ps.token.tk == tk_or)) {
		auto or_expr = create<ast::or_expr>(ps.token);

		eat_token();

		auto rhs = and_expr::parse(ps);
		if (rhs) {
			or_expr->lhs = std::move(expr);
			or_expr->rhs = std::move(rhs);
			expr = std::move(or_expr);
		} else {
			ps.error("unable to parse right hand side of or_expr");
			return nullptr;
		}
	}

	return expr;
}

ptr<expression> expression::parse(parse_state_t &ps) {
	return or_expr::parse(ps);
}

ptr<expression> assignment::parse(parse_state_t &ps) {
	auto lhs = expression::parse(ps);
	if (lhs) {

#define handle_assign(tk_, type) \
		if (!ps.line_broke() && ps.token.tk == tk_) { \
			auto assignment = create<type>(ps.token); \
			chomp_token(tk_); \
			auto rhs = expression::parse(ps); \
			if (rhs) { \
				assignment->lhs = std::move(lhs); \
				assignment->rhs = std::move(rhs); \
				return std::move(assignment); \
			} else { \
				assert(!ps.status); \
				return nullptr; \
			} \
		}

		handle_assign(tk_assign, ast::assignment);
		handle_assign(tk_plus_eq, ast::plus_assignment);
		// handle_assign(tk_maybe_eq, ast::maybe_assignment);
		handle_assign(tk_minus_eq, ast::minus_assignment);
		handle_assign(tk_divide_by_eq, ast::divide_assignment);
		handle_assign(tk_times_eq, ast::times_assignment);
		handle_assign(tk_mod_eq, ast::mod_assignment);

		if (!ps.line_broke() && ps.token.tk == tk_becomes) {
			if (lhs->sk == sk_reference_expr) {
				auto var_decl = create<ast::var_decl>(lhs->token);
				var_decl->type = type_variable(lhs->token.location);
				chomp_token(tk_becomes);
				auto initializer = or_expr::parse(ps);
				if (initializer) {
					var_decl->initializer.swap(initializer);
					return var_decl;
				} else {
					assert(!ps.status);
					return nullptr;
				}
			} else {
				ps.error(":= may only come after a reference_expr");
				return nullptr;
			}
		} else {
			return lhs;
		}
		return lhs;
	} else {
		assert(!ps.status);
	}

	return nullptr;
}

ptr<param_list_decl> param_list_decl::parse(parse_state_t &ps) {
	/* reset the argument index */
	ps.argument_index = 0;

	auto param_list_decl = create<ast::param_list_decl>(ps.token);
	while (ps.token.tk != tk_rparen) {
		param_list_decl->params.push_back(var_decl::parse_param(ps));
		if (ps.token.tk == tk_comma) {
			eat_token();
		} else if (ps.token.tk != tk_rparen) {
			ps.error("unexpected token in param_list_decl");
			return nullptr;
		}
	}
	return param_list_decl;
}

ptr<param_list> param_list::parse(parse_state_t &ps) {
	auto param_list = create<ast::param_list>(ps.token);
	chomp_token(tk_lparen);
	int i = 0;
	while (ps.token.tk != tk_rparen) {
		++i;
		auto expr = expression::parse(ps);
		if (expr) {
			param_list->expressions.push_back(std::move(expr));
			if (ps.token.tk == tk_comma) {
				eat_token();
			} else if (ps.token.tk != tk_rparen) {
				ps.error("unexpected token " c_id("%s") " in parameter list", ps.token.text.c_str());
				return nullptr;
			}
			// continue and read the next parameter
		} else {
			assert(!ps.status);
			return nullptr;
		}
	}
	chomp_token(tk_rparen);

	return param_list;
}

ptr<block> block::parse(parse_state_t &ps) {
	auto block = create<ast::block>(ps.token);
	chomp_token(tk_indent);
	if (ps.token.tk == tk_outdent) {
		ps.error("empty blocks are not allowed, sorry. use pass.");
		return nullptr;
	}

	while (!!ps.status && ps.token.tk != tk_outdent) {
		assert(ps.token.tk != tk_none);
		while (ps.token.tk == tk_semicolon) {
			ps.advance();
		}
		if (!ps.line_broke()
				&& !(ps.prior_token.tk == tk_indent
					|| ps.prior_token.tk == tk_outdent)) {
			ps.error("statements must be separated by a newline (or a semicolon)");
		}
		auto statement = statement::parse(ps);
		if (statement) {
			block->statements.push_back(std::move(statement));
		} else {
			assert(!ps.status);
			return nullptr;
		}
	}

	expect_token(tk_outdent);
	ps.advance();
	return block;
}

ptr<if_block> if_block::parse(parse_state_t &ps) {
	auto if_block = create<ast::if_block>(ps.token);
	if (ps.token.tk == tk_if || ps.token.tk == tk_elif) {
		ps.advance();
	} else {
		ps.error("expected if or elif");
		return nullptr;
	}

	auto condition = assignment::parse(ps);
	if (condition) {
		if_block->condition = condition;
		auto block = block::parse(ps);
		if (block) {
			if_block->block.swap(block);

			if (ps.prior_token.tk == tk_outdent) {
				/* check the successive instructions for elif or else */
				if (ps.token.tk == tk_elif) {
					if_block->else_ = if_block::parse(ps);
				} else if (ps.token.tk == tk_else) {
					ps.advance();
					if_block->else_ = block::parse(ps);
				}
			}

			return if_block;
		} else {
			assert(!ps.status);
			return nullptr;
		}
	} else {
		assert(!ps.status);
		return nullptr;
	}
}

ptr<while_block> while_block::parse(parse_state_t &ps) {
	auto while_block = create<ast::while_block>(ps.token);
	chomp_token(tk_while);
	auto condition = expression::parse(ps);
	if (condition) {
		while_block->condition.swap(condition);
		auto block = block::parse(ps);
		if (block) {
			while_block->block.swap(block);
			return while_block;
		} else {
			assert(!ps.status);
			return nullptr;
		}
	} else {
		assert(!ps.status);
		return nullptr;
	}
}

ast::pattern_block::ref pattern_block::parse(parse_state_t &ps) {
	auto is_token = ps.token;
	chomp_token(tk_is);

	auto pattern_block = ast::create<ast::pattern_block>(is_token);
	pattern_block->type = parse_maybe_type(ps, {}, {}, {});

	if (!!ps.status) {
		auto block = block::parse(ps);
		if (block) {
			pattern_block->block.swap(block);
			return pattern_block;
		} else {
			assert(!ps.status);
			return nullptr;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<when_block> when_block::parse(parse_state_t &ps) {
	auto when_block = create<ast::when_block>(ps.token);
	chomp_token(tk_when);
	auto value = expression::parse(ps);
	if (!!ps.status) {
		when_block->value.swap(value);
		if (ps.token.tk == tk_indent) {
			/* this is a multi_pattern_block */
			chomp_token(tk_indent);
			while (ps.token.tk == tk_is) {
				auto pattern_block = pattern_block::parse(ps);
				if (!!ps.status) {
					when_block->pattern_blocks.push_back(pattern_block);
				}
			}
			chomp_token(tk_outdent);
			if (ps.token.tk == tk_else) {
				ps.advance();
				when_block->else_block = block::parse(ps);
			}
		} else {
			/* this is a single_pattern_block */
			auto pattern_block = pattern_block::parse(ps);
			when_block->pattern_blocks.push_back(pattern_block);
			if (ps.token.tk == tk_else) {
				ps.advance();
				when_block->else_block = block::parse(ps);
			}
		}
		if (when_block->pattern_blocks.size() == 0) {
			ps.error("when block did not have subsequent patterns to match");
		}
		return when_block;
	} else {
		assert(!ps.status);
		return nullptr;
	}
}

ptr<function_decl> function_decl::parse(parse_state_t &ps) {
	types::type::ref inbound_context;
	if (ps.token.tk == tk_lsquare) {
		ps.advance();
		if (ps.token.tk == tk_module) {
			ps.advance();
			inbound_context = _parse_type(ps, {}, {}, {});
			if (!!ps.status) {
				chomp_token(tk_rsquare);

				/* in an inbound context declaration, we transform all type
				 * variables to global scope */
				auto ftvs = inbound_context->get_ftvs();
				types::type::ref global = type_id(make_iid(GLOBAL_ID));
				types::type::map bindings;
				for (auto ftv : ftvs) {
					bindings[ftv] = global;
				}
				inbound_context = ::type_module(inbound_context->rebind(bindings));
				debug_above(5, log(log_info,
							"parsed module inbound context declaration %s",
							inbound_context->str().c_str()));
			}
		} else {
			ps.error("expected inbound module declaration");
		}
	}

	if (!!ps.status) {
		chomp_token(tk_def);

		if (!!ps.status) {
			auto function_decl = create<ast::function_decl>(ps.token);

			chomp_token(tk_identifier);
			chomp_token(tk_lparen);

			function_decl->inbound_context = inbound_context;
			function_decl->param_list_decl = param_list_decl::parse(ps);

			chomp_token(tk_rparen);
			if (ps.token.tk == tk_identifier ||
					ps.token.tk == tk_any ||
					ps.token.tk == tk_lsquare ||
					ps.token.tk == tk_lcurly ||
					ps.token.tk == tk_identifier)
			{
				function_decl->return_type = parse_maybe_type(ps, {}, {}, {});
			}

			return function_decl;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<function_defn> function_defn::parse(parse_state_t &ps) {
	auto function_decl = function_decl::parse(ps);

	if (!!ps.status) {
		assert(function_decl != nullptr);
		auto block = block::parse(ps);
		if (!!ps.status) {
			assert(block != nullptr);
			auto function_defn = create<ast::function_defn>(function_decl->token);
			function_defn->decl = function_decl;
			function_defn->block = block;
			return function_defn;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<module_decl> module_decl::parse(parse_state_t &ps) {
	auto module_decl = create<ast::module_decl>(ps.token);

	chomp_token(tk_module);

	expect_token(tk_identifier);
	module_decl->name = ps.token;
	eat_token();

	if (ps.token.tk == tk_version) {
		auto semver = semver::parse(ps);
		if (semver) {
			module_decl->semver.swap(semver);
		} else {
			/* ok for now */
		}
	}
	return module_decl;
}

ptr<semver> semver::parse(parse_state_t &ps) {
	if (ps.token.tk == tk_version) {
		auto semver = create<ast::semver>(ps.token);
		eat_token();
		return semver;
	} else {
		return nullptr;
	}

}

void parse_maybe_type_decl(parse_state_t &ps, identifier::refs &type_variables) {
	ps.advance();
	if (ps.token.tk == tk_lcurly) {
		ps.advance();
		while (true) {
			if (ps.token.tk == tk_identifier) {
				/* we found a type variable, let's stash it */
				type_variables.push_back(make_code_id(ps.token));
				ps.advance();
				if (ps.token.tk == tk_comma) {
					ps.advance();
				} else {
					continue;
				}
			} else if (ps.token.tk == tk_rcurly) {
				ps.advance();
				break;
			} else {
				ps.error("unexpected token found `" c_error("%s") "`", ps.token.text.c_str());
				break;
			}
		}
	}
}

identifier::ref make_code_id(const zion_token_t &token) {
	return make_ptr<code_id>(token);
}

identifier::ref make_type_id_code_id(const location location, atom var_name) {
	return make_ptr<type_id_code_id>(location, var_name);
}

types::type::refs parse_type_operands(
		parse_state_t &ps,
	   	identifier::ref supertype_id,
	   	identifier::refs type_variables,
	   	identifier::set generics)
{
	types::type::refs arguments;

	/* loop over the type arguments */
	while (!!ps.status && (ps.token.tk == tk_identifier || ps.token.tk == tk_any)) {
		/* we got an argument, recursively parse */
		auto next_type = parse_maybe_type(ps, supertype_id, type_variables, generics);
		if (!!ps.status) {
			arguments.push_back(next_type);

			if (ps.token.tk == tk_rcurly) {
				/* move on */
				break;
			} else if (ps.token.tk == tk_comma) {
				/* if we get a comma, move past it */
				ps.advance();
			} else {
				ps.error("expected ('}' or ','), got %s", tkstr(ps.token.tk));
			}
		}
	}

	if (ps.token.tk == tk_rcurly) {
		ps.advance();
	} else {
		ps.error("unexpected token found in type reference argument list, found %s",
				tkstr(ps.token.tk));
	}
	return arguments;
}

bool token_begins_type(token_kind tk) {
	return (
			tk == tk_has ||
			tk == tk_ref ||
			tk == tk_def ||
			tk == tk_any ||
			tk == tk_identifier ||
			tk == tk_lsquare ||
			tk == tk_lcurly);
}

types::type::ref _parse_function_type(parse_state_t &ps, identifier::set generics) {
	chomp_token(tk_def);
	chomp_token(tk_lparen);
	types::type::refs param_types;
	types::type::ref return_type;
	atom::map<int> name_index;
	int index = 0;

	while (!!ps.status) {
		if (ps.token.tk == tk_identifier) {
			auto var_name = ps.token;
			ps.advance();
			types::type::ref type = parse_maybe_type(ps, {}, {}, generics);
			if (!!ps.status) {
				param_types.push_back(type);
				if (name_index.find(var_name.text) != name_index.end()) {
					ps.error("duplicated parameter name: %s",
							var_name.text.c_str());
				} else {
					name_index[var_name.text] = index;
					++index;
				}
				if (ps.token.tk == tk_comma) {
					/* advance past a comma */
					ps.advance();
				}
			}
		} else if (ps.token.tk == tk_rparen) {
			ps.advance();
			break;
		} else {
			ps.error("expected a parameter name");
			return nullptr;
		}
	}

	if (!!ps.status) {
		/* now let's parse the return type */
		if (!ps.line_broke() && token_begins_type(ps.token.tk)) {
			return_type = parse_maybe_type(ps, {}, {}, generics);
		} else {
			return_type = type_void();
		}

		if (!!ps.status) {
			return type_function(
					type_variable(INTERNAL_LOC()),
					type_args(param_types),
					return_type);
		}
	}

	assert(!ps.status);
	return nullptr;
}

types::type::ref _parse_single_type(
		parse_state_t &ps,
	   	identifier::ref supertype_id,
	   	identifier::refs type_variables,
	   	identifier::set generics)
{
	if (!token_begins_type(ps.token.tk)) {
		ps.error("type references cannot begin with %s", ps.token.str().c_str());
		return nullptr;
	}

	switch (ps.token.tk) {
	case tk_has:
		{
			ps.advance();
			/* see if we're declaring a native structure with no memory management */
			bool native = false;
			if (ps.token.tk == tk_identifier && ps.token.text == "native") {
				native = true;
				ps.advance();
			}

			chomp_token(tk_indent);
			types::type::refs dimensions;
			types::name_index name_index;
			int index = 0;
			while (!!ps.status && ps.token.tk != tk_outdent) {
				if (!ps.line_broke() && ps.prior_token.tk != tk_indent) {
					ps.error("product type dimensions must be separated by a newline");
				}

				zion_token_t var_token;
				if (ps.token.tk == tk_var) {
					ps.advance();
					expect_token(tk_identifier);
					var_token = ps.token;
					name_index[var_token.text] = index++;
					ps.advance();
				} else {
					ps.error("not sure what's going on here");
					wat();
					expect_token(tk_identifier);
					var_token = ps.token;
				}

				types::type::ref dim_type = parse_maybe_type(ps, {}, {}, generics);
				if (!!ps.status) {
					dimensions.push_back(dim_type);
				}
			}
			chomp_token(tk_outdent);
			if (!!ps.status) {
				return ::type_struct(dimensions, name_index, !native /* managed */);
			} else {
				return nullptr;
			}
		}
		break;
	case tk_ref:
		{
		ps.advance();
			auto type = _parse_single_type(ps, supertype_id, type_variables, generics);
			if (!!ps.status) {
				return ::type_ref(type);
			}
		}
		break;
	case tk_def:
		return _parse_function_type(ps, generics);
	case tk_any:
		{
			/* parse generic refs */
			ps.advance();
            types::type::ref type;
			if (ps.token.tk == tk_identifier) {
				/* named generic */
				type = type_variable(make_code_id(ps.token));
				ps.advance();
            } else {
				/* no named generic */
				type = type_variable(ps.token.location);
			}
            return type;
		}
		break;
	case tk_identifier:
		{
			types::type::ref cur_type;
			auto id = make_code_id(ps.token);
			/* stash the identifier */
			if (generics.find(id) != generics.end()) {
				/* this type is marked as definitely unbound - aka generic. let's
				 * create a generic for it */
				cur_type = type_variable(id);
			} else {
				cur_type = type_id(id);
			}

			/* move on */
			ps.advance();

			types::type::refs arguments;
			if (ps.token.tk == tk_lcurly) {
				ps.advance();
				arguments = parse_type_operands(ps, supertype_id,
						type_variables, generics);
			}

			for (auto type_arg : arguments) {
				cur_type = type_operator(cur_type, type_arg);
			}

			return cur_type;
		}
		break;
	case tk_lsquare:
		{
			ps.advance();
			auto list_element_type = parse_maybe_type(ps, supertype_id,
					type_variables, generics);

			if (ps.token.tk != tk_rsquare) {
				ps.error("list type reference must end with a ']', found %s",
						ps.token.str().c_str());
				return nullptr;
			} else {
				ps.advance();
				return type_list_type(list_element_type);
			}
		}
		break;
	case tk_lcurly:
		{
			ps.advance();
			types::type::refs arguments = parse_type_operands(ps, supertype_id, type_variables, generics);
			// TODO: allow named members
			return ::type_struct(arguments, {}, true /* managed */);
		}
		break;
	default:
		panic("should have been caught above.");
	}

	not_impl();
	return nullptr;
}

types::type::ref _parse_type(
		parse_state_t &ps,
	   	identifier::ref supertype_id,
	   	identifier::refs type_variables,
	   	identifier::set generics)
{
	types::type::refs options;
	while (!!ps.status) {
		auto type = _parse_single_type(ps, supertype_id, type_variables, generics);

		if (!!ps.status) {
			options.push_back(type);
			if (ps.token.tk == tk_or) {
				ps.advance();
				continue;
			} else {
				break;
			}
		}
	}
	
	if (!!ps.status) {
		if (options.size() == 1) {
			return options[0];
		} else {
			types::type::ref sum_fn = ::type_sum(options);
			for (auto iter = type_variables.rbegin();
					iter != type_variables.rend();
					++iter)
			{
				sum_fn = ::type_lambda(*iter, sum_fn);
			}

			return sum_fn;
		}
	}
	assert(!ps.status);
	return nullptr;
}


types::type::ref parse_maybe_type(parse_state_t &ps,
	   	identifier::ref supertype_id,
	   	identifier::refs type_variables,
	   	identifier::set generics)
{
	types::type::ref type = _parse_type(ps, supertype_id, type_variables, generics);
	if (!!ps.status) {
		if (ps.token.tk == tk_maybe) {
			/* no named maybe generic */
			type = type_maybe(type);
			ps.advance();
			return type;
		} else {
			return type;
		}
	}
	assert(!ps.status);
	return nullptr;
}

type_decl::ref type_decl::parse(parse_state_t &ps) {
	auto token = ps.token;
	expect_token(tk_identifier);
	identifier::refs type_variables;
	parse_maybe_type_decl(ps, type_variables);

	if (!!ps.status) {
		return create<ast::type_decl>(token, type_variables);
	} else {
		return nullptr;
	}
}

ptr<type_def> type_def::parse(parse_state_t &ps) {
	chomp_token(tk_type);
	expect_token(tk_identifier);
	auto type_def = create<ast::type_def>(ps.token);
	type_def->type_decl = type_decl::parse(ps);
	if (!!ps.status) {
		type_def->type_algebra = ast::type_algebra::parse(ps, type_def->type_decl);
		if (!!ps.status) {
			return type_def;
		}
	}

	assert(!ps.status);
	return nullptr;
}

ptr<tag> tag::parse(parse_state_t &ps) {
	chomp_token(tk_tag);
	expect_token(tk_identifier);
	auto tag = create<ast::tag>(ps.token);
	ps.advance();
	return tag;
}

type_algebra::ref type_algebra::parse(
		parse_state_t &ps,
		ast::type_decl::ref type_decl)
{
	switch (ps.token.tk) {
	case tk_is:
		return type_sum::parse(ps, type_decl, type_decl->type_variables);
	case tk_has:
		return type_product::parse(ps, type_decl, type_decl->type_variables);
	case tk_matches:
		return type_alias::parse(ps, type_decl, type_decl->type_variables);
	default:
		ps.error(
				"type descriptions must begin with "
			   	c_id("is") ", " c_id("has") ", or " c_id("matches") ". (Found %s)",
				ps.token.str().c_str());
		return nullptr;
	}
}

type_sum::ref type_sum::parse(
		parse_state_t &ps,
		ast::type_decl::ref type_decl,
		identifier::refs type_variables_list)
{
	identifier::set type_variables = to_set(type_variables_list);
	auto is_token = ps.token;
	chomp_token(tk_is);
	bool expect_outdent = false;
	if (ps.token.tk == tk_indent) {
		/* take note of whether the user has indented or not */
		expect_outdent = true;
		ps.advance();
	}

	auto type = _parse_type(ps, make_code_id(type_decl->token),
			type_variables_list, type_variables);

	if (!!ps.status) {
		if (expect_outdent) {
			if (ps.token.tk == tk_lparen) {
				ps.error("subtypes of a supertype must be separated by the '" c_type("or") "' keyword");
				return nullptr;
			} else {
				chomp_token(tk_outdent);
			}
		}

		return create<type_sum>(type_decl->token, type);
	} else {
		return nullptr;
	}
}

type_product::ref type_product::parse(
		parse_state_t &ps,
		ast::type_decl::ref type_decl,
	   	identifier::refs type_variables)
{
	identifier::set generics = to_identifier_set(type_variables);
	expect_token(tk_has);
	auto type = _parse_single_type(ps, {}, {}, generics);
	return create<type_product>(type_decl->token, type, generics);
}

type_alias::ref type_alias::parse(
		parse_state_t &ps,
		ast::type_decl::ref type_decl,
	   	identifier::refs type_variables)
{
	chomp_token(tk_matches);

	identifier::set generics = to_identifier_set(type_variables);
	types::type::ref type = parse_maybe_type(ps, make_code_id(type_decl->token), type_variables, generics);
	if (!!ps.status) {
		auto type_alias = ast::create<ast::type_alias>(type_decl->token);
		type_alias->type = type;
		type_alias->type_variables = generics;
		return type_alias;
	}

	assert(!ps.status);
	return nullptr;
}

dimension::ref dimension::parse(parse_state_t &ps, identifier::set generics) {
	zion_token_t primary_token;
	atom name;
	if (ps.token.tk == tk_var) {
		ps.advance();
		expect_token(tk_identifier);
		primary_token = ps.token;
		name = primary_token.text;
		ps.advance();
	} else {
		ps.error("not sure what's going on here");
		wat();
		expect_token(tk_identifier);
		primary_token = ps.token;
	}

	types::type::ref type = parse_maybe_type(ps, {}, {}, generics);
	if (!!ps.status) {
		return ast::create<ast::dimension>(primary_token, name, type);
	}
	assert(!ps.status);
	return nullptr;
}

ptr<module> module::parse(parse_state_t &ps, bool global) {
	auto module_decl = module_decl::parse(ps);

	if (module_decl) {
		auto module = create<ast::module>(ps.token, ps.filename, global);
		module->decl.swap(module_decl);

		// Get links
		while (ps.token.tk == tk_link) {
			auto link_statement = link_statement_parse(ps);
			if (auto linked_module = dyncast<link_module_statement>(link_statement)) {
				module->linked_modules.push_back(linked_module);
			} else if (auto linked_function = dyncast<link_function_statement>(link_statement)) {
				module->linked_functions.push_back(linked_function);
			}
		}
		
		// Get functions or type defs
		while (!!ps.status) {
			if (ps.token.tk == tk_lsquare || ps.token.tk == tk_def) {
				auto function = function_defn::parse(ps);
				if (function) {
					module->functions.push_back(std::move(function));
				} else {
					assert(!ps.status);
				}
			} else if (ps.token.tk == tk_tag) {
				auto tag = tag::parse(ps);
				if (tag) {
					module->tags.push_back(std::move(tag));
				} else {
					assert(!ps.status);
				}
			} else if (ps.token.tk == tk_type) {
				auto type_def = type_def::parse(ps);
				if (type_def) {
					module->type_defs.push_back(std::move(type_def));
				} else {
					assert(!ps.status);
				}
			} else {
				break;
			}
		}

		if (ps.token.tk != tk_none) {
			if (!!ps.status) {
				ps.error("unexpected '" c_error("%s") "' at top-level module scope",
						tkstr(ps.token.tk));
			}
		}
		return module;
	} else {
		assert(!ps.status);
	}
	return nullptr;
}
