module runtime

get posix

link def dbg_se(v *void) void

# the zion runtime and garbage collector

#   The head of the singly-linked list of stack_entry_t's.  Functions push
#   and pop onto this in their prologue and epilogue.
#  
#   Since there is only a global list, this technique is not threadsafe.
link var llvm_gc_root_chain *stack_entry_t

var __head_var *var_t = __create_head_var()

var __debug_zion_runtime bool_t = __false__
var _zion_rt *char_t = "zion-rt: "r

var TYPE_KIND_TAG int32_t = 0r as int32_t
var TYPE_KIND_USE_OFFSETS int32_t = 1r as int32_t
var TYPE_KIND_USE_MARK_FN int32_t = 2r as int32_t

def on_assert_failure(msg *char_t) void
	# called when assertions fail
	posix.puts(msg)
	posix.raise(posix.SIGTRAP)

def get_member_by_index(v *var_t, index int_t) *var_t
	assert(v.type_info.type_kind == TYPE_KIND_USE_OFFSETS)

	# Get the var's type_info
	type_info_offsets := v.type_info as *type_info_offsets_t

	# Get the base of the object in order to compute the offset of the member
	base_ptr := v as *int8_t

	# Member offset computation
	offset := type_info_offsets.ref_offsets[index]

	# Compute the address of the child member slot
	var_ptr := &base_ptr[__int__(offset)] as **var_t

	# Return the address of the child member
	return var_ptr[0r]


var _bytes_allocated size_t = 0r as size_t
var _all_bytes_allocated size_t = 0r as size_t
var _var_allocation uint_t = 0r as uint_t

def mem_alloc(cb size_t, comment *char_t) *void
	runtime._bytes_allocated += cb
	runtime._all_bytes_allocated += cb
	# dbg_zrt(printf("memory allocation is at %ld %ld\n", _bytes_allocated, _all_bytes_allocated))

	# posix.puts("allocating "r)
	# posix.puts(__str__(cb))
	pb := posix.calloc(cb, 1r)
	# posix.puts("allocated 0x"r + __str__(pb as int_t, 16r) + " ("r + __str__(cb) + " bytes) for "r + comment)
	return pb

def mem_free(p *void, cb int_t) void
	_bytes_allocated -= cb
	pch := p as *int8_t
	pch_lim := &((p as *int8_t)[cb])
	while pch as int_t < pch_lim as int_t
		pch[0r] = 221r as int8_t # 0xDD
		pch = &pch[1r]

	# posix.free(p)
	# dbg_zrt(printf("memory allocation is at %ld %ld\n", _bytes_allocated, _all_bytes_allocated))

def get_total_allocated() int_t
	return _bytes_allocated

def check_node_existence(node *var_t, should_exist bool_t) void
	var p *var_t = runtime.__head_var
	assert(p == nil or p.prev == nil)

	if should_exist
		assert(p.next != nil)
		assert(node != nil)
		assert(node.prev != 3735928559r as *var_t)
		assert(node.next != 3735928559r as *var_t)
		assert(node.prev != nil)

	while p != nil
		if p == node
			if not should_exist
				# dbg_zrt(printf("node 0x%08lx of type %s already exists!\n", (intptr_t)node, node.type_info.name))
				assert(should_exist)
			else
				# found it, and that's expected.
				return
		p = p.next

	if should_exist
		# dbg_zrt(printf("node 0x%08lx #%lld of type %s does not exist in memory tracking list!\n", (intptr_t)node, (long long)node.allocation, node.type_info.name))
		assert(not should_exist)

def add_node(node *var_t) void
	assert(runtime.__head_var)
	# check_node_existence(node, __false__)

	if node.prev != nil or node.next != nil
		# dbg_zrt(printf("node 0x%08lx #%lld of type %s already has prev and next ptrs?!\n", (intptr_t)node, (long long)node.allocation, node.type_info.name))
		posix.exit(-1r)

	# assert(not __head_var.next or __head_var.next.prev == &__head_var)

	node.prev = __head_var
	node.next = __head_var.next
	if node.next != nil
		node.next.prev = node

	__head_var.next = node

	assert(__head_var.prev == nil)
	assert(__head_var.next.prev == __head_var)
	assert(node.prev.next == node)
	if node.next
		assert(node.next.prev == node)

	# check_node_existence(node, __true__)

def remove_node(node *var_t) void
	assert(node != runtime.__head_var)

	# posix.puts("removing node 0x"r + __str__(node as int_t, 16r))

	assert(node.mark == 0r)

	# check_node_existence(node, __true__)

	assert(node.prev.next == node)
	assert(node.next == nil or node.next.prev == node)

	node.prev.next = node.next
	if node.next != nil
		node.next.prev = node.prev
	node.next = 3735928559r as *var_t
	node.prev = 3735928559r as *var_t

	# check_node_existence(node, __false__)

def protect_node(node *var_t) void
	# check_node_existence(node, __true__)

	# remove this node from the heap list
	remove_node(node)

	assert(node.next == nil)
	assert(node.prev == nil)

	# insert it before the head node in the list, so that it is not
	# found during heap walks.
	node.prev = runtime.__head_var.prev
	node.next = runtime.__head_var
	runtime.__head_var.prev = node

	# check_node_existence(node, __false__)


def get_var_type_id(v *var_t) typeid_t
	if v != nil
		return v.type_info.type_id as typeid_t
	else
		# MEM_PANIC("attempt to get_var_type_id of a null value ", "", 116)
		return 0r as typeid_t

def __create_head_var() *var_t
	p := mem_alloc(sizeof(var_t), "__create_head_var"r) as *var_t
	runtime._var_allocation += 1r
	p.allocation = runtime._var_allocation
	# posix.puts("creating head var at 0x"r + __str__(p as int_t, 16r))
	return p

def dbg_type_info(type_info *type_info_t)
	if type_info
		posix.puts("type_id"r)
		posix.puts(__str__(type_info.type_id as int_t))
		posix.puts("type_kind"r)
		posix.puts(__str__(type_info.type_kind as int_t))
		posix.puts("size"r)
		posix.puts(__str__(type_info.size as int_t))
		posix.puts("name"r)
		posix.puts(type_info.name)
	else
		posix.puts("null type info"r)
		posix.puts("size"r)
		posix.puts(__str__(sizeof(var_t)))

def create_var(type_info *type_info_t) *var_t
	# dbg_type_info(type_info)

	# allocate the variable tracking object
	alloc_size := type_info ? type_info.size : sizeof(var_t)
	var obj *var_t = mem_alloc(alloc_size, type_info ? type_info.name : "<unknown>"r) as *var_t
	obj.type_info = type_info
	runtime._var_allocation += 1r

	# Mark any newly created objects so that just in case we happen to be in the middle of a GC run
	# we don't accidentally delete this object before its had a chance to get marked fairly.
	obj.mark = 1r

	# TODO: we could also check the allocation...
	obj.allocation = runtime._var_allocation

	add_node(obj)

	# dbg_zrt(printf("creating %s #%lld 0x%08lx\n", type_info.name, obj.allocation, (intptr_t)obj))

	return obj

#  Calls heap_visit(root, meta) for each GC root on the stack.
#         root and meta are exactly the values passed to
#         @llvm.gcroot.
# 
#  heap_visit could be a function to recursively mark live objects.  Or it
#  might copy them to another heap or generation.
# 
#  @param heap_visit A function to invoke for every GC root on the stack.
def visit_heap_roots(heap_visit def (obj *var_t) void)
	R := llvm_gc_root_chain as *stack_entry_plus_root_t
	while R != nil
		assert(R as int_t != 0r)
		assert(R.map.num_meta == 0r as int32_t)
		# posix.puts("R is 0x"r + __str__(&R.root0 as int_t, 16r))

		# For roots [num_meta, num_roots), the metadata pointer is null.
		i := 0r
		e := R.map.num_roots as int_t
		# posix.puts("found R.map.num_roots of "r + __str__(e))
		# posix.puts("R.next = 0x"r + __str__(R.next as int_t, 16r))

		# mem_dump(&R.root0 as *int_t, R.map.num_roots as int_t * sizeof(*var_t))
		assert(i <= e)
		while i != e
			node := (&R.root0 as **var_t)[i]
			if node == nil
				i += 1r
				continue

			# posix.puts(__str__(node as int_t, 16r))
			# posix.puts(__str__(node.type_info as int_t))
			assert(node.type_info != nil and node.type_info.name != nil)
			# posix.puts("visiting heap node 0x"r + __str__(node as int_t, 16r) + " of type "r + node.type_info.name)
			# we have a heap variable
			heap_visit(node)
			i += 1r

		R = (R.next as *stack_entry_plus_root_t)


def visit_allocations(visit def (obj *var_t) void)
	node := __head_var.next
	while node != nil
		# cache the next node in case our current node gets deleted as part of the fn
		next := node.next

		# visit the node
		visit(node)

		# move along
		node = next


def mark_allocation(obj *var_t)
	if obj == nil
		return

	# dbg_zrt(printf("heap variable is referenced on the stack at 0x%08llx and is a '%s'\n", (long long)obj, obj.type_info.name))
	if obj.mark != 0r
		# posix.puts("skipping mark of 0x"r + __str__(obj as int_t, 16r))
		return

	# posix.puts("marking allocation at 0x"r + __str__(obj as int_t, 16r) + " of type "r + obj.type_info.name)

	# mark this node in the heap so that we break any potential cycles
	obj.mark = 1r

	assert(obj.type_info)

	type_kind := obj.type_info.type_kind

	if type_kind == runtime.TYPE_KIND_TAG
		# tags don't have dependencies
		return
	elif type_kind == runtime.TYPE_KIND_USE_OFFSETS
		var type_info_offsets *type_info_offsets_t = obj.type_info as *type_info_offsets_t

		# we may be holding on to child nodes, let's recurse.
		var refs_count int_t = __int__(type_info_offsets.refs_count)

		j := 0r
		while j < refs_count
			# compute the offset to this referenced dimension
			var child *var_t = get_member_by_index(obj, j)
			mark_allocation(child)
			j += 1r
	elif type_kind == runtime.TYPE_KIND_USE_MARK_FN
		# call the type's mark function to recurse
		type_info_mark_fn := obj.type_info as *type_info_mark_fn_t
		type_info_mark_fn.mark_fn(obj)
	else
		posix.perror("found a heap variable with an invalid type_kind"r)
		posix.exit(1r)


def clear_mark_bit(obj *var_t)
	# posix.puts("clearing marked bit on 0x"r + __str__(obj as int_t, 16r))
	obj.mark = 0r


def finalize(obj *var_t)
	type_kind := obj.type_info.type_kind

	if type_kind == runtime.TYPE_KIND_TAG
		# tags can't have finalizers
		return
	elif type_kind == runtime.TYPE_KIND_USE_OFFSETS
		var type_info_offsets *type_info_offsets_t = obj.type_info as *type_info_offsets_t

		finalizer := type_info_offsets.finalize_fn
		if finalizer != nil
			finalizer(obj)

	elif type_kind == runtime.TYPE_KIND_USE_MARK_FN
		# call the type's mark function to recurse
		type_info_mark_fn := obj.type_info as *type_info_mark_fn_t
		finalizer := type_info_mark_fn.finalize_fn
		if finalizer != nil
			finalizer(obj)
			
	else
		posix.perror("found a heap variable with an invalid type_kind"r)
		posix.exit(1r)

def free_unmarked(obj *var_t)
	assert(obj != __head_var)
	if obj.mark == 0r
		# Protect newly allocated things (during GC) from being prematurely deleted
		if obj.allocation < _gc_generation
			finalize(obj)
			remove_node(obj)
			mem_free(obj as *void, obj.type_info.size)
	else
		# posix.puts("not freeing "r + dbghex(obj))
		pass

def dbghex(v *void) *char_t
	# LEAKLEAKLEAK
	return concat("0x"r, __str__(v as int_t, 16r))

var _gc_generation int_t = 0r

def gc()
	# dbg_se(llvm_gc_root_chain)
	last_generation := _gc_generation
	_gc_generation = runtime._var_allocation

	# posix.puts("running gc..."r)
	__debug_zion_runtime = posix.getenv("DBG_ZRT"r) != nil
	visit_allocations(clear_mark_bit)
	__visit_module_vars(mark_allocation)
	visit_heap_roots(mark_allocation)
	visit_allocations(free_unmarked)
	# report("after gc..."r)

def report(use_case *char_t)
	title := concat("Memory Report: "r, use_case)
	posix.puts(title)
	posix.free(title)

	bytes_allocated := __str__(runtime._bytes_allocated)
	all_bytes_allocated := __str__(runtime._all_bytes_allocated)

	message := concat("bytes_allocated = "r, bytes_allocated)
	posix.puts(message)
	posix.free(message)

	message = concat("all_bytes_allocated = "r, all_bytes_allocated)
	posix.puts(message)
	posix.free(message)
	posix.free(all_bytes_allocated)
	posix.free(bytes_allocated)

def print_var(node *var_t)
	# LEAKLEAKLEAK
	posix.puts(
		concat(
			concat(
				concat("heap variable exists at 0x"r,
					dbghex(node)),
				" and is a "r),
			node.type_info.name))

def heap_dump()
	posix.puts("dumping the heap..."r)
	visit_allocations(print_var)
