global

get runtime
get posix
get maybe
get buffer
get bool
get bytes
get str
get int
get float
get vector
get map
get math
get file
get crypto

link in "rt_typeid.o"

link def mem_dump(x *void, y int) void

var stdin *posix.FILE = posix.fdopen(0, "r")!
var stdout *posix.FILE = posix.fdopen(1, "a")!
var stderr *posix.FILE = posix.fdopen(2, "a")!

# initialization of modules is automatically generated.
# link def __init_modules() void

def print[T where is_maybe T](x T) void
	if x != null
		print(x)
	else
		write(stdout, "<null>\n")

def print[T where not (is_maybe T) and (not (T <: str))](x T) void
	write(stdout, str(x))
	write(stdout, "\n")

def print[T where not(is_maybe T) and (T <: str)](x T) void
	write(stdout, x)
	write(stdout, "\n")

def panic(x str) void
	write(stderr, x)
	posix.exit(-1)

def breakpoint() void
	posix.raise(posix.SIGTRAP)

def rand(max int) int
	# Note that this is not a great way to do this
	var r int = 0
	posix.arc4random_buf(&r, sizeof(int))
	if r < 0
		r = -r
	return r % max

type IntRange has
	var first int
	var lim int
	var step int

def range(lim int) IntRange
	return IntRange(0, lim, 1)

def range(first int, lim int) IntRange
	return IntRange(first, lim, 1)

def range(first int, lim int, step int) IntRange
	return IntRange(first, lim, step)

type IntRangeIter has
	var range IntRange
	var pos int

def __iter_begin__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.first)
	
def __iter_end__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.lim)

def __iter_valid__(i IntRangeIter, end IntRangeIter) bool
	assert(i.range as *void == end.range as *void)
	return i.pos < end.range.lim

def __iterate__(i IntRangeIter)
	i.pos += i.range.step

def __iter_item__(i IntRangeIter) int
	return i.pos

def readline() str?
	var buf *?char
	var linecap posix.int = 0

	if posix.getline(&buf, &linecap, stdin) == -1 or buf == null
		return Empty

	var lim = posix.strlen(buf) - 1
	while lim >= 0 and posix.isspace(buf[lim])
		lim -= 1
	length := lim + 1
	buf[length] = 0

	ret := str(OwningBuffer(buf, length), 0, length)
	# runtime.gc()
	return ret

def __box__[T where is_function T](fn T) __closure_t T
	return __closure_t(fn)
