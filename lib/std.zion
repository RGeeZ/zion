module _
link module runtime
link module posix
link module math
link module vector
link module map
link module iter as iter_module

link def hexdigit(val int_t) wchar_t

# initialization of modules is automatically generated.
# link def __init_modules() void

type int_t = integer_t{64, signed}
type uint_t = integer_t{64, unsigned}
type size_t = integer_t{64 /* TODO: inject correct size for platform from reader macro */, unsigned}

type int64_t = integer_t{64, signed}
type uint64_t = integer_t{64, unsigned}

type int32_t = integer_t{32, signed}
type uint32_t = integer_t{32, unsigned}

type int16_t = integer_t{16, signed}
type uint16_t = integer_t{16, unsigned}

type int8_t = integer_t{8, signed}
type uint8_t = integer_t{8, unsigned}

tag false
tag true

type bool is
	true or
	false

def __not__(b bool) bool
	return bool(__get_typeid__(b) != __get_typeid__(true))

def __not__(b bool_t) bool_t
	return b == 0r

def __not__(x int) bool
	return bool(x.raw == 0r)

def bool(x bool_t) bool
	# Since bool is a sum type, there is no default constructor
	# but since it also represents this obvious binary type, we should
	# have a default "boxing" function.
	return x ? true : false

def bool(x bool) bool
	return x

def bool(x int) bool
	return (x.raw == 0r) ? false : true

def bool(x str) bool
	return (x.raw[0r] as int_t != 0r) ? true : false

type str has
	# TODO: override str ctor to strdup strings
	var raw *__char__

def __init__() str
	return ""

def __finalize__(s str)
	posix.free(s.raw)

def __box__(s *__char__) str
	return str(mbstowcs(s))

def mbstowcs(mbs *__char__) *__wchar__
	# Converts from current locale's encoding to wide-char encoding. Allocates memory that
	# must be freed later.
	mbslen := posix.strlen(s)
	wcs_cb := C99.mbstowcs(nil, s, slen)
	if wcs_cb == -1r
		print("Failed to convert string!")
		sys.exit(1r)

	wcs := posix.malloc(wcs_cb + sizeof(__wchar__)) as *__wchar__
	if wcs == nil
		posix.puts("out of memory")
		sys.exit(-1r)

	C99.mbstowcs(wcs, s, strlen(str));
	return wcs

def str(s str) str
	return s

def str(x bool) str
	if x
		return "true"
	else
		return "false"

def int(s str) int
	return int(__int__(s.raw))

type int has
	var raw int_t

def __init__() int
	return 0

def int(x int) int
	return int(x.raw)

def int(x float) int
	return int(__int__(x.raw))

def str(x int) str
	return str(__str__(x.raw))

def str(i int_t) str
	return str(__str__(i))

type float has
	var raw __float__

def float(x float) float
	return x

def float(x int) float
	return float(__float__(x.raw))

def str(x float) str
	return str(__str__(x.raw))

def str(x __float__) str
	return str(__str__(x))

def mask(x int, y int) int
	return int(__mask__(x.raw, y.raw))

def __mod__(x int, y int) int
	return int(x.raw % y.raw)

def __plus__(x str, y str) str
	return str(concat(x.raw, y.raw))

def __plus__(x str, y int) str
	return str(concat(x.raw, str(y).raw))

def __plus__(x str, y int_t) str
	y_expanded := __str__(y)
	result := str(concat(x.raw, y_expanded))
	posix.free(y_expanded)
	return result

def __plus__(x str, y float) str
	sy := __str__(y.raw)
	ret := str(concat(x.raw, sy))
	posix.free(sy)
	return ret

def __plus__(x float, y float) float
	return float(x.raw + y.raw)

def __plus__(x float, y int) float
	return float(x.raw + y.raw)

def __plus__(x int, y float) float
	return float(x.raw + y.raw)

def __plus__(x int, y int) int
	return int(x.raw + y.raw)

def __minus__(x int, y int) int
	return int(x.raw - y.raw)

def __minus__(x float, y int) float
	return float(x.raw - __float__(y.raw))

def __minus__(x int, y float) float
	return float(__float__(x.raw) - y.raw)

def __minus__(x float, y float) float
	return float(x.raw - y.raw)

def __positive__(x int) int
	return x

def __positive__(x float) float
	return x

def __negative__(x int) int
	return int(-x.raw)

def __negative__(x float) float
	return float(-x.raw)

def __divide__(x int, y int) int
	return int(x.raw / y.raw)

def __divide__(x float, y int) float
	return float(x.raw / __float__(y.raw))

def __divide__(x int, y float) float
	return float(__float__(x.raw) / y.raw)

def __divide__(x float, y float) float
	return float(x.raw / y.raw)

def __times__(x int, y int) int
	return int(x.raw * y.raw)

def __times__(x float, y int) float
	return float(x.raw * __float__(y.raw))

def __times__(x int, y float) float
	return float(__float__(x.raw) * y.raw)

def __times__(x float, y float) float
	return float(x.raw * y.raw)

# def __eq__(x *any, y nil) bool_t
# return __is_nil__(x)

# def __eq__(y nil, x *any) bool_t
# return __is_nil__(x)

# def __eq__(x __str__, y nil) bool_t
# return __is_nil__(x)

# def __eq__(x *any T, y *any T) bool_t
# 	return x as int_t == y as int_t

def __eq__(x int, y int) bool
	return x.raw == y.raw ? true : false

def __eq__(x int32_t, y int32_t) bool_t
	return x as int_t == y as int_t

def __eq__(x int16_t, y int16_t) bool_t
	return x as int_t == y as int_t

def __eq__(x int8_t, y int8_t) bool_t
	return x as int_t == y as int_t

def __eq__(x int, y float) bool
	return __float__(x.raw) == y.raw ? true : false

def __eq__(x float, y int) bool
	return x.raw == __float__(y.raw) ? true : false

def __eq__(x float, y float) bool
	return x.raw == y.raw ? true : false

def __eq__(x str, y str) bool
	return posix.strcmp(x.raw, y.raw) == 0r ? true : false

def __ineq__(x str, y str) bool
	return posix.strcmp(x.raw, y.raw) != 0r ? true : false

# def __ineq__(x *any, y nil) bool_t
# TODO: optimize
# return __is_non_nil__(x)

# def __ineq__(x __str__, y nil) bool_t
# return __is_non_nil__(x)

# def __ineq__(y nil, x *any) bool_t
# TODO: optimize
# 	return __is_non_nil__(x)

# def __ineq__(x *any T, y *any T) bool_t
# 	return x as int_t != y as int_t

def __ineq__(x int, y int) bool
	return x.raw != y.raw ? true : false

def __ineq__(x int32_t, y int32_t) bool_t
	return x as int_t != y as int_t

def __ineq__(x int16_t, y int16_t) bool_t
	return x as int_t != y as int_t

def __ineq__(x int8_t, y int8_t) bool_t
	return x as int_t != y as int_t

def __ineq__(x int, y float) bool
	return __float__(x.raw) != y.raw ? true : false

def __ineq__(x float, y int) bool
	return x.raw != __float__(y.raw) ? true : false

def __ineq__(x float, y float) bool
	return x.raw != y.raw ? true : false

def __lt__(x int, y int) bool
	return bool(x.raw < y.raw)

def __lte__(x int, y int) bool
	return bool(x.raw <= y.raw)

def __gt__(x int, y int) bool
	return bool(x.raw > y.raw)

def __gte__(x int, y int) bool
	return bool(x.raw >= y.raw)

def __lt__(x int, y float) bool
	return bool(__float__(x.raw) < y.raw)

def __lte__(x int, y float) bool
	return bool(__float__(x.raw) <= y.raw)

def __gt__(x int, y float) bool
	return bool(__float__(x.raw) > y.raw)

def __gte__(x int, y float) bool
	return bool(__float__(x.raw) >= y.raw)

def __lt__(x float, y int) bool
	return bool(x.raw < __float__(y.raw))

def __lte__(x float, y int) bool
	return bool(x.raw < __float__(y.raw))

def __gt__(x float, y int) bool
	return bool(x.raw > __float__(y.raw))

def __lt__(x float, y float) bool
	return bool(x.raw < y.raw)

def __gt__(x float, y float) bool
	return bool(x.raw > y.raw)

def __lte__(x float, y float) bool
	return bool(x.raw <= y.raw)

def __gte__(x float, y float) bool
	return bool(x.raw >= y.raw)

def __gte__(x float, y int) bool
	return bool(x.raw >= __float__(y.raw))

def print(x any) void
	posix.puts(str(x).raw)

def breakpoint() void
	posix.raise(posix.SIGTRAP)

type list{T} has
	var value T
	var next list{T}?

def nth(l list{any T}?, index int) any T?
	if l
		if index == 0
			return l.value
		else
			return nth(l.next, index - 1)

	return nil

def len(l list{any T}?) int
	if l
		return len(l.next) + 1
	return 0

def conj(maybe_list list{any T}?, item any T) list{any T}
	if l := maybe_list
		return list(item, l)
	return list(item, nil)


def str(l list{any T}?) str
	return "[" + join(l, ", ") + "]"

type bytes has
	var data *int8_t
	var cb int_t

def len(b bytes) int
	return int(b.cb)

def alloc(cb int) bytes
	return alloc(cb.raw)

def alloc(cb int_t) bytes
	return bytes(posix.calloc(1r, cb) as *int8_t, cb)

def __finalize__(b bytes)
	posix.free(b.data)

def str(b *int8_t, length int_t, encoding str) str
	dest_len := length + 1r
	dest := posix.calloc(1r, dest_len)
	posix.memcpy(dest as *int8_t, b as *int8_t, length)
	return str(dest as *__char__)

def rand(max int) int
	var r int_t = 0r
	posix.arc4random_buf(&r, sizeof(__int__))
	if r < 0r
		r = -r
	return int(r % max.raw)

def __bool__(x [any T] or str or int or bool) bool_t
	assert(x as *void != nil)
	when x
		is true
			return __true__
		is false
			return __false__
		is int
			return x.raw != 0r
		is str
			return x.raw[0r] as int_t != 0r
		is [any T]
			return (x as *vector.vector_t).size != 0r

	node := x as *runtime.var_t
	print("failed to match type of object at 0x"
		+ hexdigest(&node, sizeof(*runtime.var_t))
		+ " and is a " + str(node.type_info.name)
		+ " with type ID " + str(node.type_info.type_id as int_t))
	assert(__false__)
	return __false__

type IntRange has
	var first int_t
	var lim int_t
	var step int_t

def range(lim int) IntRange
	return IntRange(0r, lim.raw, 1r)

def range(first int, lim int) IntRange
	return IntRange(first.raw, lim.raw, 1r)

def range(first int, lim int, step int) IntRange
	return IntRange(first.raw, lim.raw, step.raw)

type IntRangeIter has
	var range IntRange
	var pos int_t

def __iter_begin__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.first)
	
def __iter_end__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.lim)

def __iter_valid__(i IntRangeIter, end IntRangeIter) bool_t
	assert(i.range as *void == end.range as *void)
	return i.pos < end.range.lim

def __iterate__(i IntRangeIter)
	i.pos += i.range.step

def __iter_item__(i IntRangeIter) int
	return int(i.pos)

def str(buffer *__char__, length int_t) str
	# Create a managed string from a direct memory access
	retstr := posix.malloc(length + 1r) as *__char__
	posix.memcpy(retstr as *int8_t, buffer as *int8_t, length)
	retstr[length] = 0r as __char__
	return str(retstr)

def hexdigest(b bytes) str
	return hexdigest(b.data, b.cb)

def hexdigest(data *void, cb int_t) str
	s := posix.malloc(cb * 2r + 1r) as *__char__
	iter := data as *int8_t
	end := &iter[cb]
	i := 0r
	while iter < end
		# append to our hexdigest
		s[i] = hexdigit(iter[0r] as int_t / 16r) as __char__
		s[i + 1r] = hexdigit(__mask__(iter[0r] as int_t, 15r)) as __char__

		# advance iteration
		i += 2r
		iter = &iter[1r]

	s[i] = 0r as __char__
	return str(s as *__char__)
