module _
link module runtime
link module posix
link module math
link module vector
link module map
link module iter as iter_module
link module main

# initialization of modules is automatically generated.
# link def __init_modules() void

tag false
tag true

type bool is
	true or
	false

type TypeID has
	var id __typeid__

def str(t TypeID) str
	return str(__int__(t.id))

def assert(condition bool)
	if not condition
		print("assertion failed!")
		posix.exit(-1r)

def typeid(t any) TypeID
	return TypeID(__get_typeid__(t))

def __ineq__(x TypeID, y TypeID) bool
	return bool(x.id != y.id)

def __bool__(b bool) __bool__
	return __get_typeid__(b) == __get_typeid__(true)

def __bool__(x int) __bool__
	return __bool__(x != 0)

def __not__(b bool) bool
	return bool(__get_typeid__(b) != __get_typeid__(true))

def __not__(x int) bool
	return x == 0

def bool(x __bool__) bool
	# Since bool is a sum type, there is no default constructor
	# but since it also represents this obvious binary type, we should
	# have a default "boxing" function.
	if x
		return true
	else
		return false

type str has
	# TODO: override str ctor to strdup strings
	var raw __str__

def __finalize__(s str)
	posix.free(s.raw as __bytes)

def __box__(s __str__) str
	return str(posix.strdup(s))

def str(s str) str
	return s

def str(x bool) str
	if x
		return "true"
	else
		return "false"

def int(s str) int
	return int(__int__(s.raw))

type int has
	var raw __int__

def int(x int) int
	return x

def int(x float) int
	return int(__int__(x.raw))

def str(x int) str
	return str(__str__(x.raw))

def str(i __int__) str
	return str(__str__(i))

type float has
	var raw __float__

def float(x float) float
	return x

def float(x int) float
	return float(__float__(x.raw))

def str(x float) str
	return str(__str__(x.raw))

def str(x __float__) str
	return str(__str__(x))

def mask(x int, y int) int
	return int(__mask__(x.raw, y.raw))

def __mod__(x int, y int) int
	return int(x.raw % y.raw)

def __plus__(x str, y str) str
	return str(x.raw + y.raw)

def __plus__(x str, y int) str
	return str(x.raw + str(y).raw)

def __plus__(x str, y float) str
	return str(x.raw + str(y).raw)

def __plus__(x float, y float) float
	return float(x.raw + y.raw)

def __plus__(x float, y int) float
	return float(x.raw + y.raw)

def __plus__(x int, y float) float
	return float(x.raw + y.raw)

def __plus__(x int, y int) int
	return int(x.raw + y.raw)

def __minus__(x int, y int) int
	return int(x.raw - y.raw)

def __minus__(x float, y int) float
	return float(x.raw - __float__(y.raw))

def __minus__(x int, y float) float
	return float(__float__(x.raw) - y.raw)

def __minus__(x float, y float) float
	return float(x.raw - y.raw)

def __positive__(x int) int
	return x

def __positive__(x float) float
	return x

def __negative__(x int) int
	return int(-x.raw)

def __negative__(x float) float
	return float(-x.raw)

def __divide__(x int, y int) int
	return int(x.raw / y.raw)

def __divide__(x float, y int) float
	return float(x.raw / __float__(y.raw))

def __divide__(x int, y float) float
	return float(__float__(x.raw) / y.raw)

def __divide__(x float, y float) float
	return float(x.raw / y.raw)

def __times__(x int, y int) int
	return int(x.raw * y.raw)

def __times__(x float, y int) float
	return float(x.raw * __float__(y.raw))

def __times__(x int, y float) float
	return float(__float__(x.raw) * y.raw)

def __times__(x float, y float) float
	return float(x.raw * y.raw)

def __eq__(x any, y nil) __bool__
	return __isnil(x as *var_t)

def __eq__(y nil, x any) __bool__
	return __isnil(x as *var_t)

def __isnil(x *any) __bool__
	return not x

def __eq__(x int, y int) bool
	return bool(x.raw == y.raw)

def __eq__(x int, y float) bool
	return bool(__float__(x.raw) == y.raw)

def __eq__(x float, y int) bool
	return bool(x.raw == __float__(y.raw))

def __eq__(x float, y float) bool
	return bool(x.raw == y.raw)

def __eq__(x str, y str) bool
	return bool(x.raw == y.raw)

def __ineq__(x str, y str) bool
	return bool(x.raw == y.raw)

def __ineq__(x any, y nil) bool
	# TODO: optimize
	return not bool(__isnil(x as __var_ref))

def __ineq__(y nil, x any) bool
	# TODO: optimize
	return not bool(__isnil(x as __var_ref))

def __ineq__(x int, y int) bool
	return bool(x.raw != y.raw)

def __ineq__(x int, y float) bool
	return bool(__float__(x.raw) != y.raw)

def __ineq__(x float, y int) bool
	return bool(x.raw != __float__(y.raw))

def __ineq__(x float, y float) bool
	return bool(x.raw != y.raw)

def __lt__(x int, y int) bool
	return bool(x.raw < y.raw)

def __lte__(x int, y int) bool
	return bool(x.raw <= y.raw)

def __gt__(x int, y int) bool
	return bool(x.raw > y.raw)

def __gte__(x int, y int) bool
	return bool(x.raw >= y.raw)

def __lt__(x int, y float) bool
	return bool(__float__(x.raw) < y.raw)

def __lte__(x int, y float) bool
	return bool(__float__(x.raw) <= y.raw)

def __gt__(x int, y float) bool
	return bool(__float__(x.raw) > y.raw)

def __gte__(x int, y float) bool
	return bool(__float__(x.raw) >= y.raw)

def __lt__(x float, y int) bool
	return bool(x.raw < __float__(y.raw))

def __lte__(x float, y int) bool
	return bool(x.raw < __float__(y.raw))

def __gt__(x float, y int) bool
	return bool(x.raw > __float__(y.raw))

def __lt__(x float, y float) bool
	return bool(x.raw < y.raw)

def __gt__(x float, y float) bool
	return bool(x.raw > y.raw)

def __lte__(x float, y float) bool
	return bool(x.raw <= y.raw)

def __gte__(x float, y float) bool
	return bool(x.raw >= y.raw)

def __gte__(x float, y int) bool
	return bool(x.raw >= __float__(y.raw))

def print(x any) void
	posix.puts(str(x).raw)

type list{T} has
	var value T
	var next list{T}?

def __bool__(l [any]) __bool__
	if l is nil
		return __false__
	else
		return __true__

def nth(l list{any T}?, index int) any T?
	if l
		if index == 0
			return l.value
		else
			return nth(l.next, index - 1)

	return nil

def len(l list{any T}?) int
	if l
		return len(l.next) + 1
	return 0

def conj(maybe_list list{any T}?, item any T) list{any T}
	if l := maybe_list
		return list(item, l)
	return list(item, nil)


def str(l list{any T}?) str
	return "[" + join(l, ", ") + "]"

def join(l [any T], delim str) str
	iter_l := l
	s := ""
	var seen_one __bool__ = __false__
	while __true__
		if node := iter_l
			if seen_one
				s += delim
			else
				seen_one = __true__

			s += str(node.value)
			iter_l = node.next
		else
			break
	return s

type ListIter{V} has
	var list [V]

def iter(l [any V]) ListIter{any V}
	return ListIter(l)

def next(list_iter ListIter{any V}) iter/Step{any V, ListIter{any V}}?
	if item := list_iter.list
		return iter_module.Step(item.value, ListIter(item.next))
	else
		return nil as iter/Step{any V, ListIter{any V}}?

type bytes has
	var data __bytes
	var cb __int__

def len(b bytes) int
	return int(b.cb)

def alloc(cb int) bytes
	return bytes(posix.calloc(1r, cb.raw), cb.raw)

def __finalize__(b bytes)
	posix.free(b.data)

def str(b __bytes, length __int__, encoding str) str
	dest_len := length + 1r
	dest := posix.calloc(1r, dest_len)
	posix.memcpy(dest, b, length)
	return str(dest as __str__)

