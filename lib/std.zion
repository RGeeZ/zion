global

get runtime
get posix
get maybe
get buffer
get bool
get bytes
get str
get int
get float
get vector
get map
get math
get file
get crypto
get functional

link in "rt_typeid.o"

link def mem_dump(x *void, y int) void

var stdin *posix.FILE = posix.fdopen(0, "r")!
var stdout *posix.FILE = posix.fdopen(1, "a")!
var stderr *posix.FILE = posix.fdopen(2, "a")!

# initialization of modules is automatically generated.
# link def __init_modules() void

def print[T where is_maybe T](x T) void {
    if x != null {
        print(x)
    } else {
        write(stdout, "<null>\n")
    }
}

def print[T, Args, R where not (is_maybe T) and not (T === str) and not (T <: def (..Args) R)](x T) void {
    write(stdout, str(x))
    write(stdout, "\n")
}

def print[T where not(is_maybe T) and (T === str)](x T) void {
    write(stdout, x)
    write(stdout, "\n")
}

def panic(x str) void {
    write(stderr, x)
    posix.exit(-1)
}

def breakpoint() void {
    posix.raise(posix.SIGTRAP)
}

def rand(max int) int {
    # Note that this is not a great way to do this
    var r int = 0
    posix.arc4random_buf(&r, sizeof(int))
    if r < 0 {
        r = -r
    }
    return r % max
}

type IntRange has {
    var first int
    var lim int
    var step int
}
    

def range(lim int) IntRange {
    return IntRange(0, lim, 1)
}

def range(first int, lim int) IntRange {
    return IntRange(first, lim, 1)
}

def range(first int, lim int, step int) IntRange {
    return IntRange(first, lim, step)
}

type IntRangeIter has {
    var range IntRange
    var pos int
}

def __iter_begin__(range IntRange) IntRangeIter {
    return IntRangeIter(range, range.first)
}
    
def __iter_end__(range IntRange) IntRangeIter {
    return IntRangeIter(range, range.lim)
}

def __iter_valid__(i IntRangeIter, end IntRangeIter) bool {
    return i.pos < end.range.lim
}

def __iterate__(i IntRangeIter) {
    i.pos += i.range.step
}

def __iter_item__(i IntRangeIter) int {
    return i.pos
}

def __box__[Args, Ret](fn def _(..Args) Ret) def (..Args) Ret {
    return __closure_t(fn) as! def (..Args) Ret
}

def __eq__(x (), y ()) true {
    return true
}
