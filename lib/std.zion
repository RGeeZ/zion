global

get runtime
get posix
get math
get vector
get map

link in "rt_str.o"
link in "rt_int.o"
link in "rt_float.o"
link in "rt_typeid.o"

link def hexdigit(val int_t) wchar_t
link def __int__(x float_t) int_t to __int_float
link def __int__(x *wchar_t) int_t to __int_from_wcs
link def __int__(x *char_t) int_t to __int_from_mbs
link def __float__(x int_t) float_t to __float_int
link def __float__(x float_t) float_t to __float_float
link def __float__(x *char_t) float_t to __float_from_utf8
link def __float__(x *wchar_t) float_t to __float_from_utf32
link def mem_dump(x *void, y int_t) void to mem_dump
link def __wcs__(x int_t) *wchar_t to __wcs_int
link def __wcs__(x int_t, y int_t) *wchar_t to __wcs_int_radix
link def __wcs__(x float_t) *wchar_t to __wcs_float
link def __wcs__(x typeid_t) *wchar_t to __wcs_type_id
link def __wcs__(x *char_t) *wchar_t to __wcs_str
link def __ineq__(x typeid_t, y typeid_t) bool_t to __type_id_ineq_type_id
link def concat(x *char_t, y *char_t) *char_t to __mbs_concat
link def concat(x *wchar_t, y *wchar_t) *wchar_t to __wcs_concat
link def __not__(x int_t) bool_t to __int_not
link def __plus__(x int_t, y int_t) int_t to __int_plus_int
link def __minus__(x int_t, y int_t) int_t to __int_minus_int
link def __times__(x int_t, y int_t) int_t to __int_times_int
link def __divide__(x int_t, y int_t) int_t to __int_divide_int
link def __mod__(x int_t, y int_t) int_t to __int_modulus_int
link def __mask__(x int_t, y int_t) int_t to __int_mask_int
link def __negative__(x int_t) int_t to __int_neg
link def __positive__(x int_t) int_t to __int_pos
link def __negative__(x float_t) float_t to __float_neg
link def __positive__(x float_t) float_t to __float_pos
link def __plus__(x int_t, y float_t) float_t to __int_plus_float
link def __minus__(x int_t, y float_t) float_t to __int_minus_float
link def __times__(x int_t, y float_t) float_t to __int_times_float
link def __divide__(x int_t, y float_t) float_t to __int_divide_float
link def __plus__(x float_t, y int_t) float_t to __float_plus_int
link def __minus__(x float_t, y int_t) float_t to __float_minus_int
link def __times__(x float_t, y int_t) float_t to __float_times_int
link def __divide__(x float_t, y int_t) float_t to __float_divide_int
link def __plus__(x float_t, y float_t) float_t to __float_plus_float
link def __minus__(x float_t, y float_t) float_t to __float_minus_float
link def __times__(x float_t, y float_t) float_t to __float_times_float
link def __divide__(x float_t, y float_t) float_t to __float_divide_float
link def __gt__(x float_t, y float_t) bool_t to __float_gt_float
link def __lt__(x float_t, y float_t) bool_t to __float_lt_float
link def __gte__(x float_t, y float_t) bool_t to __float_gte_float
link def __lte__(x float_t, y float_t) bool_t to __float_lte_float
link def __gt__(x int_t, y int_t) bool_t to __int_gt_int
link def __lt__(x int_t, y int_t) bool_t to __int_lt_int
link def __gte__(x int_t, y int_t) bool_t to __int_gte_int
link def __lte__(x int_t, y int_t) bool_t to __int_lte_int
link def __ineq__(x int_t, y int_t) bool_t to __int_ineq_int
link def __ineq__(x float_t, y float_t) bool_t to __float_ineq_float
link def __eq__(x int_t, y int_t) bool_t to __int_eq_int
link def __eq__(x float_t, y float_t) bool_t to __float_eq_float
link def __eq__(x typeid_t, y typeid_t) bool_t to __type_id_eq_type_id
link def __eq__(x *char_t, y *char_t) bool_t to __mbs_eq_mbs
link def __eq__(x *wchar_t, y *wchar_t) bool_t to __wcs_eq_wcs
link def __type_id_eq_type_id(x typeid_t, y typeid_t) bool_t to __type_id_eq_type_id
link def __int__(x typeid_t) int_t to __type_id_int

# initialization of modules is automatically generated.
# link def __init_modules() void

tag false
tag true

type bool is
	true or
	false

def __not__(b bool) bool
	return bool(__get_typeid__(b) != __get_typeid__(true))

def __not__(b bool_t) bool_t
	return b == 0r

def __not__(x int) bool
	return bool(x.raw == 0r)

def bool(x bool_t) bool
	# Since bool is a sum type, there is no default constructor
	# but since it also represents this obvious binary type, we should
	# have a default "boxing" function.
	return x ? true : false

def bool(x bool) bool
	return x

def bool(x int) bool
	return (x.raw == 0r) ? false : true

def bool(x str) bool
	return (x.raw[0r] as int_t != 0r) ? true : false

type str has
	# TODO: override str ctor to strdup strings
	var raw *__char__

def __init__() str
	return ""

def __finalize__(s str)
	posix.free(s.raw)

def __box__(s *__char__) str
	return str(mbstowcs(s))

def mbstowcs(mbs *__char__) *__wchar__
	# Converts from current locale's encoding to wide-char encoding. Allocates memory that
	# must be freed later.
	mbslen := posix.strlen(s)
	wcs_cb := C99.mbstowcs(nil, s, slen)
	if wcs_cb == -1r
		print("Failed to convert string!")
		sys.exit(1r)

	wcs := posix.malloc(wcs_cb + sizeof(__wchar__)) as *__wchar__
	if wcs == nil
		posix.puts("out of memory")
		sys.exit(-1r)

	C99.mbstowcs(wcs, s, strlen(str));
	return wcs

def str(s str) str
	return s

def str(x bool) str
	if x
		return "true"
	else
		return "false"

def int(s str) int
	return int(__int__(s.raw))

type int has
	var raw int_t

def __init__() int
	return 0

def int(x int) int
	return int(x.raw)

def int(x float) int
	return int(__int__(x.raw))

def str(x int) str
	return str(__str__(x.raw))

def str(i int_t) str
	return str(__str__(i))

type float has
	var raw __float__

def float(x float) float
	return x

def float(x int) float
	return float(__float__(x.raw))

def str(x float) str
	return str(__str__(x.raw))

def str(x __float__) str
	return str(__str__(x))

def mask(x int, y int) int
	return int(__mask__(x.raw, y.raw))

def __mod__(x int, y int) int
	return int(x.raw % y.raw)

def __plus__(x str, y str) str
	return str(concat(x.raw, y.raw))

def __plus__(x str, y int) str
	return str(concat(x.raw, str(y).raw))

def __plus__(x str, y int_t) str
	y_expanded := __str__(y)
	result := str(concat(x.raw, y_expanded))
	posix.free(y_expanded)
	return result

def __plus__(x str, y float) str
	sy := __str__(y.raw)
	ret := str(concat(x.raw, sy))
	posix.free(sy)
	return ret

def __plus__(x float, y float) float
	return float(x.raw + y.raw)

def __plus__(x float, y int) float
	return float(x.raw + y.raw)

def __plus__(x int, y float) float
	return float(x.raw + y.raw)

def __plus__(x int, y int) int
	return int(x.raw + y.raw)

def __minus__(x int, y int) int
	return int(x.raw - y.raw)

def __minus__(x float, y int) float
	return float(x.raw - __float__(y.raw))

def __minus__(x int, y float) float
	return float(__float__(x.raw) - y.raw)

def __minus__(x float, y float) float
	return float(x.raw - y.raw)

def __positive__(x int) int
	return x

def __positive__(x float) float
	return x

def __negative__(x int) int
	return int(-x.raw)

def __negative__(x float) float
	return float(-x.raw)

def __divide__(x int, y int) int
	return int(x.raw / y.raw)

def __divide__(x float, y int) float
	return float(x.raw / __float__(y.raw))

def __divide__(x int, y float) float
	return float(__float__(x.raw) / y.raw)

def __divide__(x float, y float) float
	return float(x.raw / y.raw)

def __times__(x int, y int) int
	return int(x.raw * y.raw)

def __times__(x float, y int) float
	return float(x.raw * __float__(y.raw))

def __times__(x int, y float) float
	return float(__float__(x.raw) * y.raw)

def __times__(x float, y float) float
	return float(x.raw * y.raw)

# def __eq__(x *any, y nil) bool_t
# return __is_nil__(x)

# def __eq__(y nil, x *any) bool_t
# return __is_nil__(x)

# def __eq__(x __str__, y nil) bool_t
# return __is_nil__(x)

# def __eq__(x *any T, y *any T) bool_t
# 	return x as int_t == y as int_t

def __eq__(x int, y int) bool
	return x.raw == y.raw ? true : false

def __eq__(x int32_t, y int32_t) bool_t
	return x as int_t == y as int_t

def __eq__(x int16_t, y int16_t) bool_t
	return x as int_t == y as int_t

def __eq__(x int8_t, y int8_t) bool_t
	return x as int_t == y as int_t

def __eq__(x int, y float) bool
	return __float__(x.raw) == y.raw ? true : false

def __eq__(x float, y int) bool
	return x.raw == __float__(y.raw) ? true : false

def __eq__(x float, y float) bool
	return x.raw == y.raw ? true : false

def __eq__(x str, y str) bool
	return posix.strcmp(x.raw, y.raw) == 0r ? true : false

def __ineq__(x str, y str) bool
	return posix.strcmp(x.raw, y.raw) != 0r ? true : false

# def __ineq__(x *any, y nil) bool_t
# TODO: optimize
# return __is_non_nil__(x)

# def __ineq__(x __str__, y nil) bool_t
# return __is_non_nil__(x)

# def __ineq__(y nil, x *any) bool_t
# TODO: optimize
# 	return __is_non_nil__(x)

# def __ineq__(x *any T, y *any T) bool_t
# 	return x as int_t != y as int_t

def __ineq__(x int, y int) bool
	return x.raw != y.raw ? true : false

def __ineq__(x int32_t, y int32_t) bool_t
	return x as int_t != y as int_t

def __ineq__(x int16_t, y int16_t) bool_t
	return x as int_t != y as int_t

def __ineq__(x int8_t, y int8_t) bool_t
	return x as int_t != y as int_t

def __ineq__(x int, y float) bool
	return __float__(x.raw) != y.raw ? true : false

def __ineq__(x float, y int) bool
	return x.raw != __float__(y.raw) ? true : false

def __ineq__(x float, y float) bool
	return x.raw != y.raw ? true : false

def __lt__(x int, y int) bool
	return bool(x.raw < y.raw)

def __lte__(x int, y int) bool
	return bool(x.raw <= y.raw)

def __gt__(x int, y int) bool
	return bool(x.raw > y.raw)

def __gte__(x int, y int) bool
	return bool(x.raw >= y.raw)

def __lt__(x int, y float) bool
	return bool(__float__(x.raw) < y.raw)

def __lte__(x int, y float) bool
	return bool(__float__(x.raw) <= y.raw)

def __gt__(x int, y float) bool
	return bool(__float__(x.raw) > y.raw)

def __gte__(x int, y float) bool
	return bool(__float__(x.raw) >= y.raw)

def __lt__(x float, y int) bool
	return bool(x.raw < __float__(y.raw))

def __lte__(x float, y int) bool
	return bool(x.raw < __float__(y.raw))

def __gt__(x float, y int) bool
	return bool(x.raw > __float__(y.raw))

def __lt__(x float, y float) bool
	return bool(x.raw < y.raw)

def __gt__(x float, y float) bool
	return bool(x.raw > y.raw)

def __lte__(x float, y float) bool
	return bool(x.raw <= y.raw)

def __gte__(x float, y float) bool
	return bool(x.raw >= y.raw)

def __gte__(x float, y int) bool
	return bool(x.raw >= __float__(y.raw))

def print(x any) void
	posix.puts(str(x).raw)

def breakpoint() void
	posix.raise(posix.SIGTRAP)

type list{T} has
	var value T
	var next list{T}?

def nth(l list{any T}?, index int) any T?
	if l
		if index == 0
			return l.value
		else
			return nth(l.next, index - 1)

	return nil

def len(l list{any T}?) int
	if l
		return len(l.next) + 1
	return 0

def conj(maybe_list list{any T}?, item any T) list{any T}
	if l := maybe_list
		return list(item, l)
	return list(item, nil)


def str(l list{any T}?) str
	return "[" + join(l, ", ") + "]"

type bytes has
	var data *int8_t
	var cb int_t

def len(b bytes) int
	return int(b.cb)

def alloc(cb int) bytes
	return alloc(cb.raw)

def alloc(cb int_t) bytes
	return bytes(posix.calloc(1r, cb) as *int8_t, cb)

def __finalize__(b bytes)
	posix.free(b.data)

def str(b *int8_t, length int_t, encoding str) str
	dest_len := length + 1r
	dest := posix.calloc(1r, dest_len)
	posix.memcpy(dest as *int8_t, b as *int8_t, length)
	return str(dest as *__char__)

def rand(max int) int
	var r int_t = 0r
	posix.arc4random_buf(&r, sizeof(int_t))
	if r < 0r
		r = -r
	return int(r % max.raw)

def __bool__(x [any T] or str or int or bool) bool_t
	assert(x as *void != nil)
	when x
		is true
			return __true__
		is false
			return __false__
		is int
			return x.raw != 0r
		is str
			return x.raw[0r] as int_t != 0r
		is [any T]
			return (x as *vector.vector_t).size != 0r

	node := x as *runtime.var_t
	print("failed to match type of object at 0x"
		+ hexdigest(&node, sizeof(*runtime.var_t))
		+ " and is a " + str(node.type_info.name)
		+ " with type ID " + str(node.type_info.type_id as int_t))
	assert(__false__)
	return __false__

type IntRange has
	var first int_t
	var lim int_t
	var step int_t

def range(lim int) IntRange
	return IntRange(0r, lim.raw, 1r)

def range(first int, lim int) IntRange
	return IntRange(first.raw, lim.raw, 1r)

def range(first int, lim int, step int) IntRange
	return IntRange(first.raw, lim.raw, step.raw)

type IntRangeIter has
	var range IntRange
	var pos int_t

def __iter_begin__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.first)
	
def __iter_end__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.lim)

def __iter_valid__(i IntRangeIter, end IntRangeIter) bool_t
	assert(i.range as *void == end.range as *void)
	return i.pos < end.range.lim

def __iterate__(i IntRangeIter)
	i.pos += i.range.step

def __iter_item__(i IntRangeIter) int
	return int(i.pos)

def str(buffer *__char__, length int_t) str
	# Create a managed string from a direct memory access
	retstr := posix.malloc(length + 1r) as *__char__
	posix.memcpy(retstr as *int8_t, buffer as *int8_t, length)
	retstr[length] = 0r as __char__
	return str(retstr)

def hexdigest(b bytes) str
	return hexdigest(b.data, b.cb)

def hexdigest(data *void, cb int_t) str
	s := posix.malloc(cb * 2r + 1r) as *__char__
	iter := data as *int8_t
	end := &iter[cb]
	i := 0r
	while iter < end
		# append to our hexdigest
		s[i] = hexdigit(iter[0r] as int_t / 16r) as __char__
		s[i + 1r] = hexdigit(__mask__(iter[0r] as int_t, 15r)) as __char__

		# advance iteration
		i += 2r
		iter = &iter[1r]

	s[i] = 0r as __char__
	return str(s as *__char__)
