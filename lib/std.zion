global

get runtime
get posix
get maybe
get buffer
get bool
get bytes
get str
get int
get float
get vector
get map
get math
get file
get crypto
get functional

link in "rt_typeid.o"

link fn mem_dump(x *void, y int) void

var stdin *posix.FILE = posix.fdopen(0, "r")!
var stdout *posix.FILE = posix.fdopen(1, "a")!
var stderr *posix.FILE = posix.fdopen(2, "a")!

# initialization of modules is automatically generated.
# link fn __init_modules() void

fn print[T where is_maybe T](x T) void {
    if x != null {
        print(x)
    } else {
        write(stdout, "<null>\n")
    }
}

fn print[T, Args, R where not (is_maybe T) and not (T === str) and not (T <: fn (..Args) R)](x T) void {
    write(stdout, str(x))
    write(stdout, "\n")
}

fn print[T where not(is_maybe T) and (T === str)](x T) void {
    write(stdout, x)
    write(stdout, "\n")
}

fn panic(x str) void {
    write(stderr, x)
    posix.exit(-1)
}

fn breakpoint() void {
    posix.raise(posix.SIGTRAP)
}

fn rand(max int) int {
    # Note that this is not a great way to do this
    var r int = 0
    posix.arc4random_buf(&r, sizeof(int))
    if r < 0 {
        r = -r
    }
    return r % max
}

type IntRange has {
    var first int
    var lim int
    var step int
}
    

fn range(lim int) IntRange {
    return IntRange(0, lim, 1)
}

fn range(first int, lim int) IntRange {
    return IntRange(first, lim, 1)
}

fn range(first int, lim int, step int) IntRange {
    return IntRange(first, lim, step)
}

type IntRangeIter has {
    var range IntRange
    var pos int
}

fn __iter_begin__(range IntRange) IntRangeIter {
    return IntRangeIter(range, range.first)
}
    
fn __iter_end__(range IntRange) IntRangeIter {
    return IntRangeIter(range, range.lim)
}

fn __iter_valid__(i IntRangeIter, end IntRangeIter) bool {
    return i.pos < end.range.lim
}

fn __iterate__(i IntRangeIter) {
    i.pos += i.range.step
}

fn __iter_item__(i IntRangeIter) int {
    return i.pos
}

fn __box__[Args, Ret](f fn _(..Args) Ret) fn (..Args) Ret {
    return __closure_t(f) as! fn (..Args) Ret
}

fn __eq__(x (), y ()) true {
    return true
}
