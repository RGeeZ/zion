data Bool {
    False
    True
}

fn not(x) {
    if x {
        return False
    } else {
        return True
    }
}

class HasDefault a {
    fn new() a
}

class Show a {
    fn str(a) [Char]
}

instance Show () {
    fn str(a) => "()"
}

instance Show Int {
    fn str(x) {
        return "0"
    }
}

instance Show Ref a {
    fn str(a) => str(!a)
}

data Ref a {
    Ref(a)
}

instance Show Ref {
    fn str(x) {
        s := new [Char]
        concat(s, "Ref(")
        concat(s, str(x))
        concat(s, ")")
        return s
    }
}

class LoadableValue f {
    fn load_value(f a) a
}

instance LoadableValue Ref {
    fn load_value(a) => match a {
        Ref(a) => a
    }
}

instance LoadableValue * {
    load_value = __builtin_ptr_load
}

class Eq a {
    fn ==(a, a) Bool
    fn !=(a, a) Bool
    /*default {
        fn ==(a, b) {
            return not (a != b)
        }
        fn !=(a, b) {
            return not (a == b)
        }
    }*/
}

instance Eq *a {
    == = __builtin_ptr_eq
    != = __builtin_ptr_ne
}

instance Eq Ref a {
    fn ==(a, b) => !a == !b
    fn !=(a, b) => !a != !b
}

instance Eq Int {
    == = __builtin_int_eq
    != = __builtin_int_ne
}

instance Eq Float {
    == = __builtin_float_eq
    != = __builtin_float_ne
}

instance Eq Maybe a {
    fn ==(a, b) => match (a, b) {
        (Nothing, Nothing) => True
        (Just(a), Just(b)) => a == b
        _ => False
    }
    fn !=(a, b) => not (a == b)
}


instance Eq [a] {
    fn ==(xs, ys) {
        if !xs.size != !ys.size {
            return False
        }
        size := !xs.size
        var i = 0
        while !i < size {
            if xs[!i] != ys[!i] {
                return False
            }
        }
        return True
    }
    fn !=(xs, ys) {
        if !xs.size != !ys.size {
            return True
        }
        size := !(xs.size)
        var i = 0
        while !i < size {
            if xs[!i] != ys[!i] {
                return True
            }
        }
        return False
    }
}

class Num a {
    has Eq
    fn from_int(Int) a
    fn +(a, a) a
    fn *(a, a) a
    fn -(a, a) a
    fn /(a, a) a
    fn abs(a) a
    fn negate(a) a
}

data Ordering {
    EQ
    LT
    GT
}

class Ord a {
    fn compare(a, a) Ordering
    fn <(a, a) Bool
    fn <=(a, a) Bool
    fn >(a, a) Bool
    fn >=(a, a) Bool
}

instance Ord Int {
    < = __builtin_int_lt
    <= = __builtin_int_lte
    > = __builtin_int_gt
    >= = __builtin_int_gte

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
}

instance Num Int {
    from_int = id
    + = __builtin_add_int
    * = __builtin_multiply_int
    - = __builtin_subtract_int
    / = __builtin_divide_int
    negate = __builtin_negate_int
    abs = __builtin_abs_int
}

instance Num Float {
    from_int = __builtin_int_to_float
    + = __builtin_add_float
    * = __builtin_multiply_float
    - = __builtin_subtract_float
    / = __builtin_divide_float
    negate = __builtin_negate_float
    abs = __builtin_abs_float
}

data Maybe t {
    Just(t)
    Nothing
}

instance Show Maybe a {
    fn str(ma) {
        match ma {
            Just(a) {
                s := new [Char]
                concat(s, "Just(")
                concat(s, str(a))
                concat(s, ")")
                return s
            }
            Nothing {
                return "Nothing"
            }
        }
    }
}

class Functor f {
    fn fmap(fn (a) b, f a) f b
}

data ExitCode {
    ExitOK
    ExitError(Int)
}

data Either a b {
    Left(a)
    Right(b)
}

struct Vector a {
    array Ref (*(Ref a))
    size Ref Int
    capacity Ref Int
}

instance Show [a] {
    fn str(xs) {
        y := new [Char]
        for x in xs {
            concat(y, str(x))
        }
        return y
    }
}

class HasLength a {
    fn len(a) Int
}

instance HasLength [a] {
    fn len(v) => !v.size
}

fn alloc(count Int) *a {
    return __builtin_calloc(sizeof(a) * count)
}

fn __getptritem__(ptr, index) {
    return !__builtin_add_ptr(ptr, index)
}

fn __getitem__(vec, index) {
    size := len(vec)
    if index < 0 {
        return Nothing
    } else if index >= size {
        return Nothing
    } else {
        return Just(!__getptritem__(!vec.array, index))
    }
}

fn append(vec [a], val a) {
    if !vec.array == null {
        vec.array = alloc(4)
        vec.size = 1
        vec.capacity = 4

        # array := load_value(vec.array)
        # (array[0]) = Ref(val)
    }
}

instance HasDefault [a] {
    fn new() {
        return Vector(Ref(null), Ref(0), Ref(0))
    }
}

class Iterable f {
    fn iter(f a) fn () Maybe a
}

instance Iterable Vector {
    fn iter(vec) {
        index := Ref(-1)
        return fn() {
            index = !index + 1
            return vec[!index]
        }
    }
}

let unit = ()
fn id(x) => x
fn print(x) => __builtin_print(str(x))
fn panic(x) {
    print(x)
    __builtin_exit(1)
}

fn concat(xs [a], ys [a]) {
    for y in ys {
        append(xs, y)
    }
}
