module _
link module runtime
link module posix
link module math
link module vector
link module map
link module iter as iter_module

link def hexdigit(val __int__) __int__

# initialization of modules is automatically generated.
# link def __init_modules() void

tag false
tag true

type bool is
	true or
	false

type TypeID has
	var id __typeid__

def str(t TypeID) str
	return str(__int__(t.id))

def typeid(t any) TypeID
	return TypeID(__get_typeid__(t))

def __ineq__(x TypeID, y TypeID) bool
	return bool(x.id != y.id)

def __not__(b bool) bool
	return bool(__get_typeid__(b) != __get_typeid__(true))

def __not__(b __bool__) __bool__
	return b as __int__ == 0r

def __not__(x int) bool
	return bool(x.raw == 0r)

def bool(x __bool__) bool
	# Since bool is a sum type, there is no default constructor
	# but since it also represents this obvious binary type, we should
	# have a default "boxing" function.
	return x ? true : false

def bool(x bool) bool
	return x

def bool(x int) bool
	return (x.raw == 0r) ? false : true

def bool(x str) bool
	return (x.raw[0r] as __int__ != 0r) ? true : false

type str has
	# TODO: override str ctor to strdup strings
	var raw *__char__

def __init__() str
	return ""

def __finalize__(s str)
	posix.free(s.raw)

def __box__(s *__char__) str
	return str(posix.strdup(s))

def str(s str) str
	return s

def str(x bool) str
	if x
		return "true"
	else
		return "false"

def int(s str) int
	return int(__int__(s.raw))

type int has
	var raw __int__

def __init__() int
	return 0

def int(x int) int
	return int(x.raw)

def int(x float) int
	return int(__int__(x.raw))

def str(x int) str
	return str(__str__(x.raw))

def str(i __int__) str
	return str(__str__(i))

type float has
	var raw __float__

def float(x float) float
	return x

def float(x int) float
	return float(__float__(x.raw))

def str(x float) str
	return str(__str__(x.raw))

def str(x __float__) str
	return str(__str__(x))

def mask(x int, y int) int
	return int(__mask__(x.raw, y.raw))

def __mod__(x int, y int) int
	return int(x.raw % y.raw)

def __plus__(x str, y str) str
	return str(concat(x.raw, y.raw))

def __plus__(x str, y int) str
	return str(concat(x.raw, str(y).raw))

def __plus__(x str, y __int__) str
	y_expanded := __str__(y)
	result := str(concat(x.raw, y_expanded))
	posix.free(y_expanded)
	return result

def __plus__(x str, y float) str
	sy := __str__(y.raw)
	ret := str(concat(x.raw, sy))
	posix.free(sy)
	return ret

def __plus__(x float, y float) float
	return float(x.raw + y.raw)

def __plus__(x float, y int) float
	return float(x.raw + y.raw)

def __plus__(x int, y float) float
	return float(x.raw + y.raw)

def __plus__(x int, y int) int
	return int(x.raw + y.raw)

def __minus__(x int, y int) int
	return int(x.raw - y.raw)

def __minus__(x float, y int) float
	return float(x.raw - __float__(y.raw))

def __minus__(x int, y float) float
	return float(__float__(x.raw) - y.raw)

def __minus__(x float, y float) float
	return float(x.raw - y.raw)

def __positive__(x int) int
	return x

def __positive__(x float) float
	return x

def __negative__(x int) int
	return int(-x.raw)

def __negative__(x float) float
	return float(-x.raw)

def __divide__(x int, y int) int
	return int(x.raw / y.raw)

def __divide__(x float, y int) float
	return float(x.raw / __float__(y.raw))

def __divide__(x int, y float) float
	return float(__float__(x.raw) / y.raw)

def __divide__(x float, y float) float
	return float(x.raw / y.raw)

def __times__(x int, y int) int
	return int(x.raw * y.raw)

def __times__(x float, y int) float
	return float(x.raw * __float__(y.raw))

def __times__(x int, y float) float
	return float(__float__(x.raw) * y.raw)

def __times__(x float, y float) float
	return float(x.raw * y.raw)

# def __eq__(x *any, y nil) __bool__
# return __is_nil__(x)

# def __eq__(y nil, x *any) __bool__
# return __is_nil__(x)

# def __eq__(x __str__, y nil) __bool__
# return __is_nil__(x)

# def __eq__(x *any T, y *any T) __bool__
# 	return x as __int__ == y as __int__

def __eq__(x int, y int) bool
	return x.raw == y.raw ? true : false

def __eq__(x __int32__, y __int32__) __bool__
	return x as __int__ == y as __int__

def __eq__(x __int16__, y __int16__) __bool__
	return x as __int__ == y as __int__

def __eq__(x __int8__, y __int8__) __bool__
	return x as __int__ == y as __int__

def __eq__(x int, y float) bool
	return __float__(x.raw) == y.raw ? true : false

def __eq__(x float, y int) bool
	return x.raw == __float__(y.raw) ? true : false

def __eq__(x float, y float) bool
	return x.raw == y.raw ? true : false

def __eq__(x str, y str) bool
	return posix.strcmp(x.raw, y.raw) == 0r ? true : false

def __ineq__(x str, y str) bool
	return posix.strcmp(x.raw, y.raw) != 0r ? true : false

# def __ineq__(x *any, y nil) __bool__
# TODO: optimize
# return __is_non_nil__(x)

# def __ineq__(x __str__, y nil) __bool__
# return __is_non_nil__(x)

# def __ineq__(y nil, x *any) __bool__
# TODO: optimize
# 	return __is_non_nil__(x)

# def __ineq__(x *any T, y *any T) __bool__
# 	return x as __int__ != y as __int__

def __ineq__(x int, y int) bool
	return x.raw != y.raw ? true : false

def __ineq__(x __int32__, y __int32__) __bool__
	return x as __int__ != y as __int__

def __ineq__(x __int16__, y __int16__) __bool__
	return x as __int__ != y as __int__

def __ineq__(x __int8__, y __int8__) __bool__
	return x as __int__ != y as __int__

def __ineq__(x int, y float) bool
	return __float__(x.raw) != y.raw ? true : false

def __ineq__(x float, y int) bool
	return x.raw != __float__(y.raw) ? true : false

def __ineq__(x float, y float) bool
	return x.raw != y.raw ? true : false

def __lt__(x int, y int) bool
	return bool(x.raw < y.raw)

def __lte__(x int, y int) bool
	return bool(x.raw <= y.raw)

def __gt__(x int, y int) bool
	return bool(x.raw > y.raw)

def __gte__(x int, y int) bool
	return bool(x.raw >= y.raw)

def __lt__(x int, y float) bool
	return bool(__float__(x.raw) < y.raw)

def __lte__(x int, y float) bool
	return bool(__float__(x.raw) <= y.raw)

def __gt__(x int, y float) bool
	return bool(__float__(x.raw) > y.raw)

def __gte__(x int, y float) bool
	return bool(__float__(x.raw) >= y.raw)

def __lt__(x float, y int) bool
	return bool(x.raw < __float__(y.raw))

def __lte__(x float, y int) bool
	return bool(x.raw < __float__(y.raw))

def __gt__(x float, y int) bool
	return bool(x.raw > __float__(y.raw))

def __lt__(x float, y float) bool
	return bool(x.raw < y.raw)

def __gt__(x float, y float) bool
	return bool(x.raw > y.raw)

def __lte__(x float, y float) bool
	return bool(x.raw <= y.raw)

def __gte__(x float, y float) bool
	return bool(x.raw >= y.raw)

def __gte__(x float, y int) bool
	return bool(x.raw >= __float__(y.raw))

def print(x any) void
	posix.puts(str(x).raw)

def breakpoint() void
	posix.raise(posix.SIGTRAP)

type list{T} has
	var value T
	var next list{T}?

def nth(l list{any T}?, index int) any T?
	if l
		if index == 0
			return l.value
		else
			return nth(l.next, index - 1)

	return nil

def len(l list{any T}?) int
	if l
		return len(l.next) + 1
	return 0

def conj(maybe_list list{any T}?, item any T) list{any T}
	if l := maybe_list
		return list(item, l)
	return list(item, nil)


def str(l list{any T}?) str
	return "[" + join(l, ", ") + "]"

type bytes has
	var data *__int8__
	var cb __int__

def len(b bytes) int
	return int(b.cb)

def alloc(cb int) bytes
	return alloc(cb.raw)

def alloc(cb __int__) bytes
	return bytes(posix.calloc(1r, cb) as *__int8__, cb)

def __finalize__(b bytes)
	posix.free(b.data)

def str(b *__int8__, length __int__, encoding str) str
	dest_len := length + 1r
	dest := posix.calloc(1r, dest_len)
	posix.memcpy(dest as *__int8__, b as *__int8__, length)
	return str(dest as *__char__)

def rand(max int) int
	var r __int__ = 0r
	posix.arc4random_buf(&r, sizeof(__int__))
	if r < 0r
		r = -r
	return int(r % max.raw)

def __bool__(x [any T] or str or int or bool) __bool__
	assert(x as *void != nil)
	when x
		is true
			return __true__
		is false
			return __false__
		is int
			return x.raw != 0r
		is str
			return x.raw[0r] as __int__ != 0r
		is [any T]
			return (x as *vector.vector_t).size != 0r

	node := x as *runtime.var_t
	print("failed to match type of object at 0x"
		+ hexdigest(&node, sizeof(*runtime.var_t))
		+ " and is a " + str(node.type_info.name)
		+ " with type ID " + str(node.type_info.type_id as __int__))
	assert(__false__)
	return __false__

type IntRange has
	var first __int__
	var lim __int__
	var step __int__

def range(lim int) IntRange
	return IntRange(0r, lim.raw, 1r)

def range(first int, lim int) IntRange
	return IntRange(first.raw, lim.raw, 1r)

def range(first int, lim int, step int) IntRange
	return IntRange(first.raw, lim.raw, step.raw)

type IntRangeIter has
	var range IntRange
	var pos __int__

def __iter_begin__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.first)
	
def __iter_end__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.lim)

def __iter_valid__(i IntRangeIter, end IntRangeIter) __bool__
	assert(i.range as *void == end.range as *void)
	return i.pos < end.range.lim

def __iterate__(i IntRangeIter)
	i.pos += i.range.step

def __iter_item__(i IntRangeIter) int
	return int(i.pos)

def str(buffer *__char__, length __int__) str
	# Create a managed string from a direct memory access
	retstr := posix.malloc(length + 1r) as *__char__
	posix.memcpy(retstr as *__int8__, buffer as *__int8__, length)
	retstr[length] = 0r as __char__
	return str(retstr)

def hexdigest(b bytes) str
	return hexdigest(b.data, b.cb)

def hexdigest(data *void, cb __int__) str
	s := posix.malloc(cb * 2r + 1r) as *__int16__
	iter := data as *__int8__
	end := &iter[cb]
	i := 0r
	while iter < end
		# append to our hexdigest
		s[i] = hexdigit(iter[0r] as __int__ / 16r) as __char__
		s[i + 1r] = hexdigit(__mask__(iter[0r] as __int__, 15r)) as __char__

		# advance iteration
		i += 2r
		iter = &iter[1r]

	s[i] = 0r as __char__
	return str(s as *__char__)
