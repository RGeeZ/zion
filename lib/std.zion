global

get runtime
get posix
get bool
get bytes
get str
get utf8
get int
get float
get vector
get map
get math

link in "rt_typeid.o"

link def mem_dump(x *void, y int_t) void
link def __type_id_eq_type_id(x typeid_t, y typeid_t) int_t

def typeid(t any) typeid_t
	return __get_typeid__(t)

# initialization of modules is automatically generated.
# link def __init_modules() void

def mbstowcs(mbs *char_t) *wchar_t
	# Converts from current locale's encoding to wide-char encoding. Allocates memory that
	# must be freed later.
	mbslen := posix.strlen(mbs)
	wcs_cb := posix.mbstowcs(null, mbs, 0r)
	if wcs_cb == -1r
		posix.puts("Failed to convert string from multi-byte to wide char!"r)
		posix.exit(1r)
	wcs_size := wcs_cb + 1r
	cb := sizeof(wchar_t) * wcs_size
	wcs := posix.malloc(cb) as *wchar_t
	if wcs == null
		posix.puts("out of memory - set a breakpoint on `exit` in order to debug"r)
		posix.exit(-1r)

	posix.mbstowcs(wcs, mbs, wcs_size)
	return wcs

def wcstombs(wcs *wchar_t) *char_t
	# Converts from wide char encoding to current locale's encoding
	# must be freed later.
	wcslen := posix.wcslen(wcs)
	mbs_cb := posix.wcstombs(null, wcs, wcslen)
	if mbs_cb == -1r
		posix.puts("Failed to convert string from wide char to multi-byte!"r)
		breakpoint()
		posix.exit(1r)

	mbs_size := mbs_cb + 1r
	cb := sizeof(char_t) * mbs_size
	mbs := posix.malloc(cb) as *char_t
	if mbs == null
		posix.puts("out of memory - set a breakpoint on `exit` in order to debug"r)
		posix.exit(-1r)

	posix.wcstombs(mbs, wcs, mbs_size)
	return mbs

def print(x any) void
	posix.puts(wcstombs(str(x).raw))

def breakpoint() void
	posix.raise(posix.SIGTRAP)

def rand(max int) int
	var r int_t = 0r
	posix.arc4random_buf(&r, sizeof(int_t))
	if r < 0r
		r = -r
	return int(r % max.raw)

def __bool__(x [any T] or str or int or bool) bool_t
	assert(x as *void != null)
	when x
		is true
			return __true__
		is false
			return __false__
		is int
			return x.raw != 0r
		is str
			return x.raw[0r] as int_t != 0r
		is [any T]
			return (x as *vector.vector_t).size != 0r

	node := x as *var_t
	print("failed to match type of object at 0x"
		+ hexdigest(&node, sizeof(*var_t))
		+ " and is a " + str(mbstowcs(node.type_info.name))
		+ " with type ID " + str(node.type_info.type_id))
	assert(__false__)
	return __false__

type IntRange has
	var first int_t
	var lim int_t
	var step int_t

def range(lim int) IntRange
	return IntRange(0r, lim.raw, 1r)

def range(first int, lim int) IntRange
	return IntRange(first.raw, lim.raw, 1r)

def range(first int, lim int, step int) IntRange
	return IntRange(first.raw, lim.raw, step.raw)

type IntRangeIter has
	var range IntRange
	var pos int_t

def __iter_begin__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.first)
	
def __iter_end__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.lim)

def __iter_valid__(i IntRangeIter, end IntRangeIter) bool_t
	assert(i.range as *void == end.range as *void)
	return i.pos < end.range.lim

def __iterate__(i IntRangeIter)
	i.pos += i.range.step

def __iter_item__(i IntRangeIter) int
	return int(i.pos)
