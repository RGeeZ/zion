import map {Map}
import set {Set}
export {Map, Set}


link pkg "bdw-gc"

data Bool {
    False
    True
}

fn not(x Bool) {
    if x {
        return False
    } else {
        return True
    }
}

class HasDefault a {
    fn new() a
}

instance HasDefault Int {
    fn new() => 0
}

class HasDefaultGet collection key value {
    # Get an item from the collection, falling back to the
    # default if the key does not allow the implementation to
    # resolve the value otherwise.
    fn get(collection, key, value) value
}

newtype String = String(*Char, Int)

class Repr a {
    fn repr(a) String
}

class Show a {
    fn str(a) String
}

instance Show () {
    fn str(a) => "()"
}

instance Repr () {
    fn repr(a) => "()"
}

fn strlen(sz *Char) Int => __builtin_ffi_1("zion_strlen", sz)

instance Show Int {
    fn str(x Int) {
        let sz = __builtin_ffi_1("zion_itoa", x)
        return String(sz, strlen(sz))
    }
}

instance Repr Int {
    repr = str
}

instance Show Float {
    fn str(x) {
        let sz = __builtin_ffi_1("zion_ftoa", x)
        let length = __builtin_ffi_1("zion_strlen", sz)
        return String(sz, length)
    }
}

instance Repr Float {
    repr = str
}

instance Show (var a) {
    fn str(var a) => str(a)
}

instance Show String {
    str = id
}

instance Repr String {
    fn repr(s) {
        # TODO: maybe make this a DFA or something
        let text = (
            replace(
                replace(
                    replace(
                        replace(
                            replace(
                                replace(s, "\"", "\\\""),
                                "\n",
                                "\\n"),
                            "\t",
                            "\\t"),
                        "\b",
                        "\\b"),
                    "\r",
                    "\\r"),
                "\f",
                "\\f"))
        return "\"${text}\""
    }
}

instance Show (* Char) {
    fn str(a) => String(a, __builtin_ffi_1("zion_strlen", a))
}

fn has_substring(haystack String, needle String) Bool {
    let String(haystack, _) = haystack
    let String(needle, _) = needle
    return __builtin_ffi_2("strstr", haystack, needle) != null as *Char
}

fn strstr_index(haystack *Char, haystack_len Int, needle *Char, needle_len Int) Int {
    if haystack_len < needle_len {
        return -1
    }

    let pos = __builtin_ffi_2("strstr", haystack, needle) as *Char
    return pos != null ? (pos as! Int) - (haystack as! Int) : -1
}

fn has_prefix(haystack String, needle String) Bool {
    let String(haystack, _) = haystack
    let String(needle, len) = needle
    return __builtin_ffi_3("strncmp", haystack, needle, len) == 0
}

fn has_suffix(haystack String, needle String) Bool {
    let String(haystack, len_haystack) = haystack
    let String(needle, len_needle) = needle
    if len_haystack < len_needle {
        return False
    }
    return __builtin_ffi_3(
        "memcmp",
        __builtin_ptr_add(haystack, len_haystack - len_needle),
        needle,
        len_needle) == 0
}

fn replace(source String, term String, new_term String) String {
    let String(sz, len) = source
    let String(needle, needle_len) = term
    var i = 0
    var start_span = 0
    let result = []
    while i < len {
        let cur_start = __builtin_ptr_add(sz, i)
        let next_index = strstr_index(cur_start, len - i, needle, needle_len)
        if next_index == -1 {
            append(result, String(cur_start, len - i))
            i += len - i
        } else {
            if next_index > 0 {
                append(result, String(cur_start, next_index))
                i += next_index
            }
            append(result, new_term)
            i += needle_len
        }
    }
    assert(i == len)
    return join("", result)
}

fn join(delim_ String, xs) String {
    let results = []
    var total = 0
    var cur_delim_len = 0
    let delim_len = len(delim_)
    var count = 0
    for x in xs {
        count += 1
        let s = str(x)
        append(results, s)
        total = total + len(s)
        cur_delim_len = delim_len
    }
    total += len(delim_) * (count - 1)
    let buf = alloc(total + 1)
    var i = 0
    for r in results {
        if i > 0 {
            for ch in delim_ {
                buf[i] = ch
                i = i + 1
            }
        }
        for ch in r {
            buf[i] = ch
            i = i + 1
        }
    }
    buf[i] = '\0'

    return String(buf, i)
}

instance Show [a] {
    fn str(xs) {
        let strs = []
        for x in xs {
            append(strs, str(x))
        }
        return "[${join(", ", strs)}]"
    }
}

fn putch(ch Char) () {
    (__builtin_ffi_2("zion_write_char", 1, ch) as Int)!
}

fn print(x) () {
    # TODO: this is not great because it is two syscalls, instead of one. This
    # could lead to interleaved writes.
    let String(sz, length) = "${str(x)}\n"
    (__builtin_ffi_3("write", 1, sz, length) as Int)!
}

data Ref a {
    Ref(a)
}


class LoadableValue f {
    fn load_value(f a) a
}

class StorableValue g {
    fn store_value(g q, q) ()
}

instance LoadableValue Ref {
    fn load_value(a) {
        let Ref(x) = a
        return x
    }
}

instance StorableValue Ref {
    fn store_value(ra Ref a, a a) () {
        __builtin_store_ref(ra, a)
    }
}

instance LoadableValue * {
    fn load_value(a) => __builtin_ptr_load(a)
}

class Eq a {
    fn ==(a, a) Bool
    fn !=(a, a) Bool
    /*default {
        fn ==(a, b) {
            return not (a != b)
        }
        fn !=(a, b) {
            return not (a == b)
        }
    }*/
}

instance Eq (*a) {
    fn ==(a, b) => __builtin_ptr_eq(a, b)
    fn !=(a, b) => __builtin_ptr_ne(a, b)
}

instance Eq (Ref a) {
    fn ==(a, b) => !a == !b
    fn !=(a, b) => !a != !b
}

instance Eq Int {
    fn ==(a, b) => __builtin_int_eq(a, b)
    fn !=(a, b) => __builtin_int_ne(a, b)
}

instance Eq Float {
    fn ==(a, b) => __builtin_float_eq(a, b)
    fn !=(a, b) => __builtin_float_ne(a, b)
}

instance Eq (Maybe a) {
    fn ==(a, b) => match (a, b) {
        (Nothing, Nothing) => True
        (Just(a), Just(b)) => a == b
        _ => False
    }
    fn !=(a, b) => not (a == b)
}

instance Eq Char {
    fn ==(a, b) => __builtin_char_eq(a, b)
    fn !=(a, b) => __builtin_char_ne(a, b)
}

instance Eq String {
    fn ==(a, b) {
        let String(a, alen) = a
        let String(b, blen) = b

        if alen != blen {
            return False
        } else {
            return __builtin_memcmp(a, b, alen) == 0
        }
    }

    fn !=(a, b) => not (a == b)
}

fn concat(a String, b String) String {
    let String(xs, xlen) = a
    let String(ys, ylen) = b

    let zlen = xlen + ylen
    if xlen == 0 {
        return b
    } else if ylen == 0 {
        return a
    } else {
        let zs = __builtin_calloc(zlen) as *Char
        __builtin_memcpy(zs, xs, xlen)
        __builtin_memcpy(__builtin_ptr_add(zs, xlen), ys, ylen)
        return String(zs, zlen)
    }
}

class Bitwise a {
    fn &(a, a) a
    fn |(a, a) a
    fn ^(a, a) a
}

instance Bitwise Int {
    fn &(a, b) => __builtin_int_bitwise_and(a, b)
    fn |(a, b) => __builtin_int_bitwise_or(a, b)
    fn ^(a, b) => __builtin_int_bitwise_xor(a, b)
}

class Num a {
    # TODO: test "has Eq" with no "a"
    has Eq a
    fn from_int(Int) a
    fn +(a, a) a
    fn *(a, a) a
    fn -(a, a) a
    fn /(a, a) a
    fn abs(a) a
    fn negate(a) a
}

class Bounded a {
    fn min_bound() a
    fn max_bound() a
}

data Ordering {
    EQ
    LT
    GT
}

class Ord a {
    fn compare(a, a) Ordering
    fn <(a, a) Bool
    fn <=(a, a) Bool
    fn >(a, a) Bool
    fn >=(a, a) Bool
    fn min(a, a) a
    fn max(a, a) a
}


instance Ord Int {
    fn <(a, b) => __builtin_int_lt(a, b)
    fn <=(a, b) => __builtin_int_lte(a, b)
    fn >(a, b) => __builtin_int_gt(a, b)
    fn >=(a, b) => __builtin_int_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }

    fn min(a, b) {
        return (a < b) ? a : b
    }
    fn max(a, b) {
        return (a > b) ? a : b
    }
}

instance Ord Char {
    fn <(a, b) => __builtin_char_lt(a, b)
    fn <=(a, b) => __builtin_char_lte(a, b)
    fn >(a, b) => __builtin_char_gt(a, b)
    fn >=(a, b) => __builtin_char_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
    fn min(a, b) {
        return (a < b) ? a : b
    }
    fn max(a, b) {
        return (a > b) ? a : b
    }
}

instance Ord Float {
    fn <(a, b) => __builtin_float_lt(a, b)
    fn <=(a, b) => __builtin_float_lte(a, b)
    fn >(a, b) => __builtin_float_gt(a, b)
    fn >=(a, b) => __builtin_float_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
    fn min(a, b) {
        return (a < b) ? a : b
    }
    fn max(a, b) {
        return (a > b) ? a : b
    }
}

instance Num Int {
    from_int = id
    fn +(a, b) => __builtin_add_int(a, b)
    fn -(a, b) => __builtin_subtract_int(a, b)
    fn *(a, b) => __builtin_multiply_int(a, b)
    fn /(a, b) => __builtin_divide_int(a, b)
    fn negate(a) => __builtin_negate_int(a)
    fn abs(a) => __builtin_abs_int(a)
}

instance Num Char {
    fn from_int(a) => __builtin_int_to_char(a)
    fn +(a, b) => __builtin_add_char(a, b)
    fn -(a, b) => __builtin_subtract_char(a, b)
    fn *(a, b) => __builtin_multiply_char(a, b)
    fn /(a, b) => __builtin_divide_char(a, b)
    fn negate(a) => __builtin_negate_char(a)
    fn abs(a) => __builtin_abs_char(a)
}

instance Bounded Int {
    fn min_bound() => __builtin_min_int
    fn max_bound() => __builtin_max_int
}

instance Num Float {
    fn from_int(a) => __builtin_int_to_float(a)
    fn +(a, b) => __builtin_add_float(a, b)
    fn -(a, b) => __builtin_subtract_float(a, b)
    fn *(a, b) => __builtin_multiply_float(a, b)
    fn /(a, b) => __builtin_divide_float(a, b)
    fn negate(a) => __builtin_negate_float(a)
    fn abs(a) => __builtin_abs_float(a)
}

class ConvertibleToInt a {
    fn int(a) Int
}

instance ConvertibleToInt Char {
    fn int(a) Int {
        return __builtin_ffi_1("zion_char_to_int", a)
    }
}

instance ConvertibleToInt Float {
    fn int(a) Int {
        return __builtin_float_to_int(a)
    }
}

class Modular a {
    fn %(a, a) a
}

instance Modular Int {
    fn %(p, q) {
        return __builtin_mod_int(p, q)
    }
}

data Maybe t {
    Just(t)
    Nothing
}

instance Show (Maybe a) {
    fn str(ma) => match ma {
        Just(a) => "Just(${a})"
        Nothing => "Nothing"
    }
}

class Functor f {
    fn fmap(fn (a) b, f a) f b
}

data Either a b {
    Left(a)
    Right(b)
}

struct Vector a {
    # TODO: make sure offset in struct is correct RE dim_offset
    array var (*a)
    size var Int
    capacity var Int
}

fn reset(xs [a]) {
    let Vector(_, var size, _) = xs
    size = 0
}

fn resize(xs [a], new_len Int, default a) () {
    let Vector(_, var size, _) = xs
    assert(not (new_len < 0))
    while size < new_len {
        append(xs, default)
    }
    if new_len < size {
        size = new_len
    }
}

instance Show Char {
    fn str(ch) {
        let ys = __builtin_calloc(1)
        ys[0] = ch
        return String(ys, 1)
    }
}

class HasLength a {
    fn len(a) Int
}

instance HasLength [a] {
    fn len(v) {
        let Vector(_, var size, _) = v
        return size
    }
}

instance HasLength String {
    fn len(s) {
        let String(_, l) = s
        return l
    }
}

class HasCapacity a {
    fn cap(a) Int
}

instance HasCapacity [a] {
    fn cap(a) {
        let Vector(_, _, var capacity) = a
        return capacity
    }
}

fn alloc(count Int) *a {
    return __builtin_calloc(sizeof(a) * count)
}

class HasIndexableItems collection index value {
    fn get_indexed_item(collection, index) value
}

instance HasIndexableItems (* a) Int a {
    fn get_indexed_item(p, index) {
        return !__builtin_ptr_add(p, index)
    }
}

instance HasIndexableItems [a] Int a {
    fn get_indexed_item(vec Vector a, index Int) a {
        let Vector(var array, var size, _) = vec
        assert(size > index)
        assert(array != null)
        return array[index]
    }
}

class HasRemovableItems collection key {
    # Remove an item idempotently
    fn remove(collection, key) ()
}

class HasSetMembership collection value {
    fn in(value, collection) Bool
    fn not_in(value, collection) Bool
}

class HasInsertableItems collection value {
    fn insert(collection, value) ()
}

class HasAssignableIndexableItems collection index value {
    fn set_indexed_item(collection, index, value) ()
}

instance HasAssignableIndexableItems (* a) Int a {
    fn set_indexed_item(p *a, index Int, a) {
        __builtin_store_ptr(__builtin_ptr_add(p, index), a)
    }
}

instance HasAssignableIndexableItems (Vector a) Int a {
    fn set_indexed_item(v Vector a, index Int, a a) {
        let Vector(var array, _, _) = v
        array[index] = a
    }
}

instance Eq [a] {
    fn ==(xs, ys) {
        let Vector(var xs_array, var xs_size, _) = xs
        let Vector(var ys_array, var ys_size, _) = ys
        if xs_size != ys_size {
            return False
        }
        var i = 0
        while i < xs_size {
            if xs_array[i] != ys_array[i] {
                return False
            }
            i += 1
        }
        return True
    }
    fn !=(xs, ys) {
        let Vector(var xs_array, var xs_size, _) = xs
        let Vector(var ys_array, var ys_size, _) = ys
        if xs_size != ys_size {
            return True
        }
        var i = 0
        while i < xs_size {
            if xs_array[i] != ys_array[i] {
                return True
            }
            i += 1
        }
        return False
    }
}

fn append(vec [a], val a) {
    let Vector(var array, var size, var capacity) = vec
    if array == null {
        array = alloc(4)
        size = 1
        capacity = 4
        array[0] = val
        return
    }

    if capacity <= size {
        reserve(vec, capacity * 2)
    }

    if capacity == 0 {
        __builtin_goodbye
    }

    __builtin_store_ptr(__builtin_ptr_add(array, size), val)
    size = size + 1
    assert(size <= capacity)
}

fn reserve(vec [a], new_capacity Int) {
    let Vector(var array, var size, var capacity) = vec
    if capacity >= new_capacity {
        return
    }
    let new_array = alloc(new_capacity)
    __builtin_memcpy(
        new_array as! *Char,
        array as! *Char,
        sizeof(a) * size)
    capacity = new_capacity
    array = new_array
}

instance HasDefault [a] {
    fn new() => Vector(Ref(null), Ref(0), Ref(0))
}

class Iterable collection item {
    fn iter(collection) fn () Maybe item
}

instance Iterable (fn () Maybe a) a {
    iter = id
}

instance Iterable [a] a {
    fn iter(vec Vector a) {
        var index = -1
        return fn() {
            index += 1
            if index >= len(vec) {
                return Nothing
            } else {
                return Just(vec[index])
            }
        }
    }
}

instance Iterable String Char {
    fn iter(s) {
        var index = -1
        let String(buf, length) = s
        return fn() {
            index += 1
            if index >= length {
                return Nothing
            } else {
                return Just(buf[index])
            }
        }
    }
}

fn isspace(ch Char) Bool {
    return __builtin_ffi_1("isspace", int(ch))
}

class CanSliceFrom collection sliced_collection  {
    fn get_slice_from(collection, Int) sliced_collection
}

class CanSliceFromTo collection sliced_collection {
    fn get_slice_from_to(collection, Int, Int) sliced_collection
}

instance CanSliceFrom String String {
    fn get_slice_from(s, index) {
        let String(sz, cb) = s
        var index = min(index, cb)
        if index < 0 or index >= cb {
            return ""
        }
        let new_len = cb - index
        assert(new_len > 0)
        return String(__builtin_ffi_2("GC_strndup", __builtin_ptr_add(sz, index), new_len), new_len)
    }
}

instance CanSliceFromTo String String {
    fn get_slice_from_to(s, index, lim) {
        let String(sz, cb) = s
        var index = min(index, cb)
        var lim = min(lim, cb)
        if index < 0 or index >= cb {
            return ""
        }
        let new_len = lim - index
        if new_len <= 0 {
            return ""
        }
        return String(__builtin_ffi_2("GC_strndup", __builtin_ptr_add(sz, index), new_len), new_len)
    }
}

fn strip(s String) String {
    let String(sz, cb) = s
    var i = 0
    while i < cb {
        if not isspace(sz[i]) {
            break
        }
        i += 1
    }
    var j = cb - 1
    while j > i {
        if not isspace(sz[j]) {
            break
        }
        j -= 1
    }
    return s[i:j+1]
}

fn chomp(s String) String {
    let String(sz, cb) = s
    # Find index of first non-space character from end
    var j = cb
    while j > 0 {
        if not isspace(sz[j-1]) {
            return s[:j]
        } else {
            j -= 1
            continue
        }
    }
    return ""
}

let unit = ()
fn id(x) => x

fn panic(x) {
    print(x)
    __builtin_ffi_1("exit", 1)
}

struct Range a {
    range_min a
    step_size a
    range_max a
}

fn range(max Int) {
    return Range(0, 1, max-1)
}

instance Iterable (Range a) a {
    fn iter(ri) {
        var index = ri.range_min
        return fn () {
            let cur_index = index;
            if cur_index <= ri.range_max {
                index = cur_index + ri.step_size
                return Just(cur_index)
            } else {
                return Nothing
            }
        }
    }
}

fn compose(f, g) => fn (x) => f(g(x))

fn map(f fn (a) b, iterable) fn () Maybe b {
    let iterator = iter(iterable)
    return fn () => match iterator() {
        Just(x) => Just(f(x))
        Nothing => Nothing
    }
}

fn filter(f fn (a) Bool, xs_input) fn () Maybe a {
    let xs = iter(xs_input)
    return fn() {
        while match xs() {
            Just(a) {
                if f(a) {
                    return Just(a)
                }
            }
            Nothing { return Nothing }
        }
        /* TODO: make it so that we don't get a
         * "not all control paths return a value" */
        return Nothing
    }
}

fn enumerate(xs) fn () Maybe (Int, a) {
    var i = -1
    let iterator = iter(xs)
    return fn () {
       match iterator() {
           Just(x) {
               i += 1
               return Just((i, x))
           }
           Nothing {
               return Nothing
           }
       }
   }
}

# WithResources are expected by `with` blocks without `else` blocks. In other
# words, `with` blocks without follow-up `else` blocks cannot fail to provide
# the resource.
newtype WithResource resource = WithResource(resource, fn () ())

# `WithElseResource`s are expected by `with` blocks that have `else` blocks. The
# input to a `with` block can fail to acquire the resource, and thus pass
# control to the `else` block.
data WithElseResource resource error {
    ResourceAcquired(WithResource resource)
    ResourceFailure(error)
}

fn resource_acquired(resource, cleanup fn () ()) {
    return ResourceAcquired(WithResource(resource, cleanup))
}

newtype Buffer = Buffer(*Char, Int)
class Serializeable a {
    fn serialize(a) Buffer
}

instance Serializeable Buffer {
    serialize = id
}

instance Serializeable String {
    fn serialize(str) {
        let String(sz, l) = str
        # Assume utf-8 here.
        return Buffer(sz, l)
    }
}

