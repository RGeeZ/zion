class HasDefault a {
    fn new() a
}

data Ref a {
    Ref(a)
}

data Bool {
    False
    True
}

class Eq a {
    fn ==(a, a) Bool
    fn !=(a, a) Bool
    /*default {
        fn ==(a, b) {
            return a != b
        }
        fn !=(a, b) {
            return not (a == b)
        }
    }*/
}

instance Eq Int {
    == = __builtin_int_eq
    != = __builtin_int_ne
}

instance Eq Float {
    == = __builtin_float_eq
    != = __builtin_float_ne
}

class Num a {
    has Eq
    fn from_int(Int) a
    fn +(a, a) a
    fn *(a, a) a
    fn -(a, a) a
    fn /(a, a) a
    fn abs(a) a
    fn negate(a) a
}

data Ordering {
    EQ
    LT
    GT
}

class Ord a {
    fn compare(a, a) Ordering
    fn <(a, a) Bool
    fn <=(a, a) Bool
    fn >(a, a) Bool
    fn >=(a, a) Bool
}

instance Num Int {
    from_int = id
    + = __builtin_add_int
    * = __builtin_multiply_int
    - = __builtin_subtract_int
    / = __builtin_divide_int
    negate = __builtin_negate_int
    abs = __builtin_abs_int
}

instance Num Float {
    from_int = __builtin_int_to_float
    + = __builtin_add_float
    * = __builtin_multiply_float
    - = __builtin_subtract_float
    / = __builtin_divide_float
    negate = __builtin_negate_float
    abs = __builtin_abs_float
}

data Maybe t {
    Just(t)
    Nothing
}

class Functor f {
    fn fmap(fn (a) b, f a) f b
}

/*
instance Functor Maybe {
    fn fmap(f, m) {
        return Nothing
    }
}
*/

data ExitCode {
    ExitOK
    ExitError(Int)
}

data Either a b {
    Left(a)
    Right(b)
}

let unit = ()
let id = fn (x) => x
