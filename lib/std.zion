global

get runtime
get posix
get maybe
get resource
get either
get buffer
get bool
get bytes
get str
get int
get float
get vector
get map
get math
get file
get crypto
get functional

link in "rt_typeid.o"

link fn mem_dump(x *void, y int) void

var stdin *posix.FILE = posix.fdopen(0, "r")!
var stdout *posix.FILE = posix.fdopen(1, "a")!
var stderr *posix.FILE = posix.fdopen(2, "a")!

# initialization of modules is automatically generated.
# link fn __init_modules() void

fn id[A](a A) A => a

fn print() {
    write(stdout, "\n")
}

fn print[T where is_maybe T](x T) {
    if x != null {
        print(x)
    } else {
        write(stdout, "<null>\n")
    }
}

fn print[T, Args, R where not (T <: Maybe any) and not (is_maybe T) and not (T === str) and not (T <: fn (..Args) R)](x T) {
    write(stdout, str(x))
    write(stdout, "\n")
}

fn print[T where not(T <: Maybe any) and (T === str)](x T) {
    write(stdout, x)
    write(stdout, "\n")
}

fn panic(x str) {
    write(stderr, x)
    posix.exit(-1)
}

fn breakpoint() {
    posix.raise(posix.SIGTRAP)
}

fn rand(max int) int {
    var r = 0 as uint
    posix.arc4random_buf(&r, sizeof(uint))
    return r % max
}

type IntRange has {
    var first int
    var lim int
    var step int
}

fn range(lim int) IntRange {
    return IntRange(0, lim, 1)
}

fn range(first int, lim int) IntRange {
    return IntRange(first, lim, 1)
}

fn range(first int, lim int, step int) IntRange {
    return IntRange(first, lim, step)
}

type IntRangeIter has {
    var range IntRange
    var pos int
}

fn __iter_begin__(range IntRange) IntRangeIter {
    return IntRangeIter(range, range.first)
}
    
fn __iter_end__(range IntRange) IntRangeIter {
    return IntRangeIter(range, range.lim)
}

fn __iter_valid__(i IntRangeIter, end IntRangeIter) bool {
    return i.pos < end.range.lim
}

fn __iterate__(i IntRangeIter) {
    i.pos += i.range.step
}

fn __iter_item__(i IntRangeIter) int {
    return i.pos
}

fn __box__[Args, Ret](f fn _(..Args) Ret) fn (..Args) Ret {
    return __closure_t(f) as! fn (..Args) Ret
}

fn __eq__(x (), y ()) true {
    return true
}
