data Bool {
    False
    True
}

fn not(x) {
    if x {
        return False
    } else {
        return True
    }
}

class HasDefault a {
    fn new() a
}

class Show a {
    fn str(a) [Char]
}

instance Show () {
    fn str(a) => "()"
}

instance Show Int {
    fn str(x) {
        sz := __builtin_itoa(x)
        length := __builtin_strlen(sz)
        return Vector(Ref(sz), Ref(length), Ref(0))
    }
}

instance Show Ref a {
    fn str(a) => str(!a)
}

data Ref a {
    Ref(a)
}

instance Show Ref {
    fn str(x) {
        s := new [Char]
        concat(s, "Ref(")
        concat(s, str(x))
        concat(s, ")")
        return s
    }
}

class LoadableValue f {
    fn load_value(f a) a
}

class StorableValue f {
    fn store_value(f a, a) ()
}

instance LoadableValue Ref {
    fn load_value(a) => match a {
        Ref(a) => a
    }
}

instance StorableValue Ref {
    fn store_value(ra Ref a, a a) () {
        __builtin_store_ref(ra, a)
    }
}

instance LoadableValue * {
    fn load_value(a) => __builtin_ptr_load(a)
}

class Eq a {
    fn ==(a, a) Bool
    fn !=(a, a) Bool
    /*default {
        fn ==(a, b) {
            return not (a != b)
        }
        fn !=(a, b) {
            return not (a == b)
        }
    }*/
}

instance Eq *a {
    fn ==(a, b) => __builtin_ptr_eq(a, b)
    fn !=(a, b) => __builtin_ptr_ne(a, b)
}

instance Eq Ref a {
    fn ==(a, b) => !a == !b
    fn !=(a, b) => !a != !b
}

instance Eq Int {
    fn ==(a, b) => __builtin_int_eq(a, b)
    fn !=(a, b) => __builtin_int_ne(a, b)
}

instance Eq Float {
    fn ==(a, b) => __builtin_float_eq(a, b)
    fn !=(a, b) => __builtin_float_ne(a, b)
}

instance Eq Maybe a {
    fn ==(a, b) => match (a, b) {
        (Nothing, Nothing) => True
        (Just(a), Just(b)) => a == b
        _ => False
    }
    fn !=(a, b) => not (a == b)
}

instance Eq Char {
    fn ==(a, b) => __builtin_char_eq(a, b)
    fn !=(a, b) => __builtin_char_ne(a, b)
}

class Num a {
    has Eq
    fn from_int(Int) a
    fn +(a, a) a
    fn *(a, a) a
    fn -(a, a) a
    fn /(a, a) a
    fn abs(a) a
    fn negate(a) a
}

class Bounded a {
    fn min_bound() a
    fn max_bound() a
}

data Ordering {
    EQ
    LT
    GT
}

class Ord a {
    fn compare(a, a) Ordering
    fn <(a, a) Bool
    fn <=(a, a) Bool
    fn >(a, a) Bool
    fn >=(a, a) Bool
}

instance Ord Int {
    fn <(a, b) => __builtin_int_lt(a, b)
    fn <=(a, b) => __builtin_int_lte(a, b)
    fn >(a, b) => __builtin_int_gt(a, b)
    fn >=(a, b) => __builtin_int_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
}

instance Ord Char {
    fn <(a, b) => __builtin_char_lt(a, b)
    fn <=(a, b) => __builtin_char_lte(a, b)
    fn >(a, b) => __builtin_char_gt(a, b)
    fn >=(a, b) => __builtin_char_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
}

instance Ord Float {
    fn <(a, b) => __builtin_float_lt(a, b)
    fn <=(a, b) => __builtin_float_lte(a, b)
    fn >(a, b) => __builtin_float_gt(a, b)
    fn >=(a, b) => __builtin_float_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
}

instance Num Int {
    from_int = id
    fn +(a, b) => __builtin_add_int(a, b)
    fn *(a, b) => __builtin_multiply_int(a, b)
    fn -(a, b) => __builtin_subtract_int(a, b)
    fn /(a, b) => __builtin_divide_int(a, b)
    fn negate(a) => __builtin_negate_int(a)
    fn abs(a) => __builtin_abs_int(a)
}

instance Num Char {
    fn from_int(a) => __builtin_int_to_char(a)
    fn +(a, b) => __builtin_add_char(a, b)
    fn *(a, b) => __builtin_multiply_char(a, b)
    fn -(a, b) => __builtin_subtract_char(a, b)
    fn /(a, b) => __builtin_divide_char(a, b)
    fn negate(a) => __builtin_negate_char(a)
    fn abs(a) => __builtin_abs_char(a)
}

instance Bounded Int {
    fn min_bound() => __builtin_min_int
    fn max_bound() => __builtin_max_int
}

instance Num Float {
    fn from_int(a) => __builtin_int_to_float(a)
    fn +(a, b) => __builtin_add_float(a, b)
    fn *(a, b) => __builtin_multiply_float(a, b)
    fn -(a, b) => __builtin_subtract_float(a, b)
    fn /(a, b) => __builtin_divide_float(a, b)
    fn negate(a) => __builtin_negate_float(a)
    fn abs(a) => __builtin_abs_float(a)
}

data Maybe t {
    Just(t)
    Nothing
}

instance Show Maybe a {
    fn str(ma) {
        match ma {
            Just(a) {
                s := new [Char]
                concat(s, "Just(")
                concat(s, str(a))
                concat(s, ")")
                return s
            }
            Nothing {
                return "Nothing"
            }
        }
    }
}

class Functor f {
    fn fmap(fn (a) b, f a) f b
}

data Either a b {
    Left(a)
    Right(b)
}

struct Vector a {
    # TODO: make sure offset in struct is correct RE dim_offset
    array Ref (*a)
    size Ref Int
    capacity Ref Int
}

fn __string_ref(sz *Char, size Int) [Char] {
    return Vector(Ref(sz), Ref(size), Ref(0))
}

instance Show Char {
    fn str(ch) {
        y := new [Char]
        append(y, ch)
        return y
    }
}

instance Show [Char] {
    fn str(xs) => xs
}

/*
instance Show [a] {
    fn str(xs) {
        y := new [Char]
        for x in xs {
            concat(y, str(x))
        }
        return y
    }
}
*/

class HasLength a {
    fn len(a) Int
}

instance HasLength [a] {
    fn len(v) => !v.size
}

fn alloc(count Int) *a {
    return __builtin_calloc(sizeof(a) * count)
}

class HasIndexableItems f {
    fn get_indexed_item(f a, Int) a
}

instance HasIndexableItems * {
    fn get_indexed_item(p *a, index Int) a {
        return !__builtin_add_ptr(p, index)
    }
}

instance HasIndexableItems Vector {
    fn get_indexed_item(vec Vector a, index Int) a {
        return (!vec.array)[index]
    }
}

class HasAssignableIndexableItems f {
    fn set_indexed_item(f a, Int, a) ()
}

instance HasAssignableIndexableItems * {
    fn set_indexed_item(p *a, index Int, a a) {
        __builtin_store_ptr(__builtin_add_ptr(p, index), a)
    }
}

instance HasAssignableIndexableItems Vector {
    fn set_indexed_item(v Vector a, index Int, a a) {
        (!v.array)[index] = a
    }
}

instance Eq [a] {
    fn ==(xs, ys) {
        if !xs.size != !ys.size {
            return False
        }
        size := !xs.size
        var i = 0
        while !i < size {
            if xs[!i] != ys[!i] {
                return False
            }
            i = !i + 1
        }
        return True
    }
    fn !=(xs, ys) {
        if !xs.size != !ys.size {
            return True
        }
        size := !(xs.size)
        var i = 0
        while !i < size {
            if xs[!i] != ys[!i] {
                return True
            }
            i = !i + 1
        }
        return False
    }
}

fn append(vec [a], val a) {
    if !vec.array == null {
        vec.array = alloc(4)
        vec.size = 1
        vec.capacity = 4
        vec[0] = val
        return
        # __builtin_store_ptr(__builtin_add_ptr(!vec.array, 0), val)
    }

    if !vec.capacity == 0 {
        __builtin_hello
        /* TODO: handle constant strings */
    }

    __builtin_store_ptr(__builtin_add_ptr(!vec.array, !vec.size), val)
    vec.size = !vec.size + 1
}

fn reserve(vec [a], cap Int) {

}

instance HasDefault [a] {
    fn new() {
        return Vector(Ref(null), Ref(0), Ref(0))
    }
}

class Iterable f {
    fn iter(f a) fn () Maybe a
}

instance Iterable Vector {
    fn iter(vec Vector a) {
        index := Ref(-1)
        return fn() {
            index = !index + 1
            if !index >= len(vec) {
                return Nothing
            } else {
                return Just(vec[!index])
            }
        }
    }
}

let unit = ()
fn id(x) => x

fn print(x) {
    return match str(x) {
        Vector(Ref(sz), _, _) {
            if sz == null {
                __builtin_goodbye
            }
            __builtin_print(sz)
        }
    }
}

fn panic(x) {
    print(x)
    __builtin_exit(1)
}

fn concat(xs [a], ys [a]) {
    __builtin_hello
    for y in ys {
        __builtin_hello
        append(xs, y)
    }
}

struct Range a {
    range_min a
    step_size a
    range_max a
}

fn range(max Int) {
    return Range(0, max-1, 1)
}

instance Iterable Range {
    fn iter(ri) {
        index := Ref(ri.range_min)
        return fn () {
            cur_index := !index;
            if cur_index <= ri.range_max {
                index = cur_index + ri.step_size
                return Just(cur_index)
            } else {
                return Nothing
            }
        }
    }
}
