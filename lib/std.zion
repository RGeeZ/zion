link pkg "bdw-gc"

data Bool {
    False
    True
}

fn not(x) {
    if x {
        return False
    } else {
        return True
    }
}

class HasDefault a {
    fn new() a
}

newtype String = (*Char, Int)

class Show a {
    fn str(a) String
}

instance Show () {
    fn str(a) => "()"
}

instance Show Int {
    fn str(x) {
        sz := __builtin_itoa(x)
        length := __builtin_strlen(sz)
        return String((sz, length))
    }
}

instance Show Float {
    fn str(x) {
        sz := __builtin_ftoa(x)
        length := __builtin_strlen(sz)
        return String((sz, length))
    }
}

instance Show Ref a {
    fn str(a) => str(!a)
}

instance Show String {
    str = id
}

instance Show * Char {
    fn str(a) {
        return String((a, __builtin_strlen(a)))
    }
}

fn join(delim_ String, xs) String {
    results := []
    var total = 0
    var cur_delim_len = 0
    delim_len := len(delim_)
    var count = 0
    for x in xs {
        count = !count + 1
        s := str(x)
        append(results, s)
        total = !total + len(s)
        cur_delim_len = delim_len
    }
    total = !total + len(delim_) * (!count - 1)
    buf := alloc(!total + 1)
    var i = 0
    for r in results {
        if !i > 0 {
            for ch in StringIterable(delim_) {
                buf[!i] = ch
                i = !i + 1
            }
        }
        for ch in StringIterable(r) {
            buf[!i] = ch
            i = !i + 1
        }
    }
    buf[!i] = from_int(0)

    return String((buf, !i))
}

instance Show [a] {
    fn str(xs) {
        strs := []
        for x in xs {
            append(strs, str(x))
        }
        return concat(concat("[", join(", ", strs)), "]")
    }
}

fn putch(ch Char) () {
    __builtin_write_char(1, ch)
}

fn print(x) () {
    String((sz, length)) := str(x)
    __builtin_write(1, sz, length)
    __builtin_write_char(1, '\n')
}

data Ref a {
    Ref(a)
}


class LoadableValue f {
    fn load_value(f a) a
}

class StorableValue f {
    fn store_value(f a, a) ()
}

instance LoadableValue Ref {
    fn load_value(a) {
        Ref(x) := a
        return x
    }
}

instance StorableValue Ref {
    fn store_value(ra Ref a, a a) () {
        __builtin_store_ref(ra, a)
    }
}

instance LoadableValue * {
    fn load_value(a) => __builtin_ptr_load(a)
}

class Eq a {
    fn ==(a, a) Bool
    fn !=(a, a) Bool
    /*default {
        fn ==(a, b) {
            return not (a != b)
        }
        fn !=(a, b) {
            return not (a == b)
        }
    }*/
}

instance Eq *a {
    fn ==(a, b) => __builtin_ptr_eq(a, b)
    fn !=(a, b) => __builtin_ptr_ne(a, b)
}

instance Eq Ref a {
    fn ==(a, b) => !a == !b
    fn !=(a, b) => !a != !b
}

instance Eq Int {
    fn ==(a, b) => __builtin_int_eq(a, b)
    fn !=(a, b) => __builtin_int_ne(a, b)
}

instance Eq Float {
    fn ==(a, b) => __builtin_float_eq(a, b)
    fn !=(a, b) => __builtin_float_ne(a, b)
}

instance Eq Maybe a {
    fn ==(a, b) => match (a, b) {
        (Nothing, Nothing) => True
        (Just(a), Just(b)) => a == b
        _ => False
    }
    fn !=(a, b) => not (a == b)
}

instance Eq Char {
    fn ==(a, b) => __builtin_char_eq(a, b)
    fn !=(a, b) => __builtin_char_ne(a, b)
}

instance Eq String {
    fn ==(a, b) {
        String((a, alen)) := a
        String((b, blen)) := b

        if alen != blen {
            return False
        } else {
            return __builtin_memcmp(a, b, alen) == 0
        }
    }

    fn !=(a, b) => not (a == b)
}

fn concat(a, b) {
    String((xs, xlen)) := a
    String((ys, ylen)) := b

    zlen := xlen + ylen
    if xlen == 0 {
        return b
    } else if ylen == 0 {
        return a
    } else {
        zs := __builtin_calloc(zlen) as *Char
        __builtin_memcpy(zs, xs, xlen)
        __builtin_memcpy(__builtin_ptr_add(zs, xlen), ys, ylen)
        return String((zs, zlen))
    }
}

class Num a {
    has Eq
    fn from_int(Int) a
    fn +(a, a) a
    fn *(a, a) a
    fn -(a, a) a
    fn /(a, a) a
    fn abs(a) a
    fn negate(a) a
}

class Bounded a {
    fn min_bound() a
    fn max_bound() a
}

data Ordering {
    EQ
    LT
    GT
}

class Ord a {
    fn compare(a, a) Ordering
    fn <(a, a) Bool
    fn <=(a, a) Bool
    fn >(a, a) Bool
    fn >=(a, a) Bool
}

instance Ord Int {
    fn <(a, b) => __builtin_int_lt(a, b)
    fn <=(a, b) => __builtin_int_lte(a, b)
    fn >(a, b) => __builtin_int_gt(a, b)
    fn >=(a, b) => __builtin_int_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
}

instance Ord Char {
    fn <(a, b) => __builtin_char_lt(a, b)
    fn <=(a, b) => __builtin_char_lte(a, b)
    fn >(a, b) => __builtin_char_gt(a, b)
    fn >=(a, b) => __builtin_char_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
}

instance Ord Float {
    fn <(a, b) => __builtin_float_lt(a, b)
    fn <=(a, b) => __builtin_float_lte(a, b)
    fn >(a, b) => __builtin_float_gt(a, b)
    fn >=(a, b) => __builtin_float_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
}

instance Num Int {
    from_int = id
    fn +(a, b) => __builtin_add_int(a, b)
    fn -(a, b) => __builtin_subtract_int(a, b)
    fn *(a, b) => __builtin_multiply_int(a, b)
    fn /(a, b) => __builtin_divide_int(a, b)
    fn negate(a) => __builtin_negate_int(a)
    fn abs(a) => __builtin_abs_int(a)
}

instance Num Char {
    fn from_int(a) => __builtin_int_to_char(a)
    fn +(a, b) => __builtin_add_char(a, b)
    fn -(a, b) => __builtin_subtract_char(a, b)
    fn *(a, b) => __builtin_multiply_char(a, b)
    fn /(a, b) => __builtin_divide_char(a, b)
    fn negate(a) => __builtin_negate_char(a)
    fn abs(a) => __builtin_abs_char(a)
}

instance Bounded Int {
    fn min_bound() => __builtin_min_int
    fn max_bound() => __builtin_max_int
}

instance Num Float {
    fn from_int(a) => __builtin_int_to_float(a)
    fn +(a, b) => __builtin_add_float(a, b)
    fn -(a, b) => __builtin_subtract_float(a, b)
    fn *(a, b) => __builtin_multiply_float(a, b)
    fn /(a, b) => __builtin_divide_float(a, b)
    fn negate(a) => __builtin_negate_float(a)
    fn abs(a) => __builtin_abs_float(a)
}

class Modular a {
    fn %(a, a) a
}

instance Modular Int {
    fn %(p, q) {
        return __builtin_mod_int(p, q)
    }
}

data Maybe t {
    Just(t)
    Nothing
}

instance Show Maybe a {
    fn str(ma) {
        match ma {
            Just(a) {
                return concat(concat("Just(", str(a)), ")")
            }
            Nothing {
                return "Nothing"
            }
        }
    }
}

class Functor f {
    fn fmap(fn (a) b, f a) f b
}

data Either a b {
    Left(a)
    Right(b)
}

struct Vector a {
    # TODO: make sure offset in struct is correct RE dim_offset
    array Ref (*a)
    size Ref Int
    capacity Ref Int
}

instance Show Char {
    fn str(ch) {
        ys := __builtin_calloc(1)
        ys[0] = ch
        return String((ys, 1))
    }
}

class HasLength a {
    fn len(a) Int
}

instance HasLength [a] {
    fn len(v) => !v.size
}

instance HasLength String {
    fn len(s) {
        String((_, l)) := s
        return l
    }
}

fn alloc(count Int) *a {
    return __builtin_calloc(sizeof(a) * count)
}

class HasIndexableItems f {
    fn get_indexed_item(f a, Int) a
}

instance HasIndexableItems * {
    fn get_indexed_item(p *a, index Int) a {
        return !__builtin_ptr_add(p, index)
    }
}

instance HasIndexableItems Vector {
    fn get_indexed_item(vec Vector a, index Int) a {
        assert(!vec.size > index)
        assert(!vec.array != null)
        return (!vec.array)[index]
    }
}

class HasAssignableIndexableItems f {
    fn set_indexed_item(f a, Int, a) ()
}

instance HasAssignableIndexableItems * {
    fn set_indexed_item(p *a, index Int, a a) {
        __builtin_store_ptr(__builtin_ptr_add(p, index), a)
    }
}

instance HasAssignableIndexableItems Vector {
    fn set_indexed_item(v Vector a, index Int, a a) {
        (!v.array)[index] = a
    }
}

instance Eq [a] {
    fn ==(xs, ys) {
        if !xs.size != !ys.size {
            return False
        }
        size := !xs.size
        var i = 0
        while !i < size {
            if xs[!i] != ys[!i] {
                return False
            }
            i = !i + 1
        }
        return True
    }
    fn !=(xs, ys) {
        if !xs.size != !ys.size {
            return True
        }
        size := !(xs.size)
        var i = 0
        while !i < size {
            if xs[!i] != ys[!i] {
                return True
            }
            i = !i + 1
        }
        return False
    }
}

fn append(vec [a], val a) {
    if !vec.array == null {
        vec.array = alloc(4)
        vec.size = 1
        vec.capacity = 4
        vec[0] = val
        return
        # __builtin_store_ptr(__builtin_ptr_add(!vec.array, 0), val)
    }

    if !vec.capacity <= !vec.size {
        new_capacity := !vec.capacity * 2
        new_array := alloc(new_capacity)
        __builtin_memcpy(
            new_array as! *Char,
            (!vec.array) as! *Char,
            sizeof(a) * !vec.size)
        vec.capacity = new_capacity
        vec.array = new_array
    }

    if !vec.capacity == 0 {
        __builtin_goodbye
    }

    __builtin_store_ptr(__builtin_ptr_add(!vec.array, !vec.size), val)
    vec.size = !vec.size + 1
    assert(!vec.size <= !vec.capacity)
}

fn reserve(vec [a], cap Int) {
    # TODO: impl
}

instance HasDefault [a] {
    fn new() {
        return Vector(Ref(null), Ref(0), Ref(0))
    }
}

class Iterable f {
    fn iter(f a) fn () Maybe a
}

newtype Iterator a = fn () Maybe a

instance Iterable Iterator {
    fn iter(i) {
        Iterator(f) := i
        return f
    }
}

instance Iterable Vector {
    fn iter(vec Vector a) {
        index := Ref(-1)
        return fn() {
            index = !index + 1
            if !index >= len(vec) {
                return Nothing
            } else {
                return Just(vec[!index])
            }
        }
    }
}

newtype StringIterable a = String

instance Iterable StringIterable {
    fn iter(s) {
        index := Ref(-1)
        StringIterable(String((buf, length))) := s
        return fn() {
            index = !index + 1
            if !index >= length {
                return Nothing
            } else {
                return Just(buf[!index])
            }
        }
    }
}

let unit = ()
fn id(x) => x

fn panic(x) {
    print(x)
    __builtin_exit(1)
}

class MutatingConcat a {
    fn mutating_concat(a, a) ()
}

instance MutatingConcat [a] {
    fn mutating_concat(xs [a], ys [a]) {
        # resize(xs, len(xs) + len(ys))
        for y in ys {
            append(xs, y)
        }
    }
}

struct Range a {
    range_min a
    step_size a
    range_max a
}

fn range(max Int) {
    return Range(0, 1, max-1)
}

instance Iterable Range {
    fn iter(ri) {
        index := Ref(ri.range_min)
        return fn () {
            cur_index := !index;
            if cur_index <= ri.range_max {
                index = cur_index + ri.step_size
                return Just(cur_index)
            } else {
                return Nothing
            }
        }
    }
}

fn sqrt(x) => __builtin_sqrt(x)
fn compose(f, g) => fn (x) => f(g(x))

fn sum(xs) {
    var s = from_int(0)
    for x in xs {
        s = !s + x
    }
    return !s
}

fn map(f fn (a) b, iterable) Iterator b {
    iterator := iter(iterable)
    return Iterator(fn () => match iterator() {
        Just(x) => Just(f(x))
        Nothing => Nothing
    })
}

fn filter(f fn (a) Bool, xs_input) Iterator a {
    xs := iter(xs_input)
    return Iterator(fn() {
        while match xs() {
            Just(a) {
                if f(a) {
                    return Just(a)
                }
            }
            Nothing { return Nothing }
        }
        /* TODO: make it so that we don't get a
         * "not all control paths return a value" */
        return Nothing
    })
}
