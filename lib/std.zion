data Bool {
    False
    True
}

fn not(x) {
    if x {
        return False
    } else {
        return True
    }
}

class HasDefault a {
    fn new() a
}

newtype String = (*Char, Int)

class Show a {
    fn str(a) String
}

instance Show () {
    fn str(a) => "()"
}

instance Show Int {
    fn str(x) {
        sz := __builtin_itoa(x)
        length := __builtin_strlen(sz)
        return String((sz, length))
    }
}

instance Show Ref a {
    fn str(a) => str(!a)
}

instance Show String {
    str = id
}

instance Show * Char {
    fn str(a) {
        return from_string_literal(a)
    }
}

fn print(x) () {
    match str(x) {
        String((sz, length)) {
            __builtin_write(1, sz, length)
            __builtin_write_char(1, '\n')
        }
    }
}

data Ref a {
    Ref(a)
}


class LoadableValue f {
    fn load_value(f a) a
}

class StorableValue f {
    fn store_value(f a, a) ()
}

instance LoadableValue Ref {
    fn load_value(a) => match a {
        Ref(x) => x
    }
}

instance StorableValue Ref {
    fn store_value(ra Ref a, a a) () {
        __builtin_store_ref(ra, a)
    }
}

instance LoadableValue * {
    fn load_value(a) => __builtin_ptr_load(a)
}

class Eq a {
    fn ==(a, a) Bool
    fn !=(a, a) Bool
    /*default {
        fn ==(a, b) {
            return not (a != b)
        }
        fn !=(a, b) {
            return not (a == b)
        }
    }*/
}

instance Eq *a {
    fn ==(a, b) => __builtin_ptr_eq(a, b)
    fn !=(a, b) => __builtin_ptr_ne(a, b)
}

instance Eq Ref a {
    fn ==(a, b) => !a == !b
    fn !=(a, b) => !a != !b
}

instance Eq Int {
    fn ==(a, b) => __builtin_int_eq(a, b)
    fn !=(a, b) => __builtin_int_ne(a, b)
}

instance Eq Float {
    fn ==(a, b) => __builtin_float_eq(a, b)
    fn !=(a, b) => __builtin_float_ne(a, b)
}

instance Eq Maybe a {
    fn ==(a, b) => match (a, b) {
        (Nothing, Nothing) => True
        (Just(a), Just(b)) => a == b
        _ => False
    }
    fn !=(a, b) => not (a == b)
}

instance Eq Char {
    fn ==(a, b) => __builtin_char_eq(a, b)
    fn !=(a, b) => __builtin_char_ne(a, b)
}

instance Eq String {
    fn ==(a, b) {
        match a {
            String((a, alen)) {
                match b {
                    String((b, blen)) {
                        if alen != blen {
                            return False
                        } else {
                            return __builtin_memcmp(a, b, alen) == 0
                        }
                    }
                }
            }
        }
    }

    fn !=(a, b) => not (a == b)
}

class Addition a {
    fn +(a, a) a
}

instance Addition String {
    fn +(a, b) {
        match a {
            String((xs, xlen)) {
                match b {
                    String((ys, ylen)) {
                        zlen := xlen + ylen
                        if xlen == 0 {
                            return b
                        } else if ylen == 0 {
                            return a
                        } else {
                            zs := __builtin_calloc(zlen) as *Char
                            __builtin_memcpy(zs, xs, xlen)
                            __builtin_memcpy(__builtin_ptr_add(zs, xlen), ys, ylen)
                            return String((zs, zlen))
                        }
                    }
                }
            }
        }
    }
}

class FromStringLiteral a {
    fn from_string_literal(*Char) a
}

instance FromStringLiteral *Char {
    from_string_literal = id
}

instance FromStringLiteral String {
    fn from_string_literal(sz) {
        return String((sz, __builtin_strlen(sz)))
    }
}

class Num a {
    has Eq
    has Addition
    fn from_int(Int) a
    fn *(a, a) a
    fn -(a, a) a
    fn /(a, a) a
    fn abs(a) a
    fn negate(a) a
}

class Bounded a {
    fn min_bound() a
    fn max_bound() a
}

data Ordering {
    EQ
    LT
    GT
}

class Ord a {
    fn compare(a, a) Ordering
    fn <(a, a) Bool
    fn <=(a, a) Bool
    fn >(a, a) Bool
    fn >=(a, a) Bool
}

instance Ord Int {
    fn <(a, b) => __builtin_int_lt(a, b)
    fn <=(a, b) => __builtin_int_lte(a, b)
    fn >(a, b) => __builtin_int_gt(a, b)
    fn >=(a, b) => __builtin_int_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
}

instance Ord Char {
    fn <(a, b) => __builtin_char_lt(a, b)
    fn <=(a, b) => __builtin_char_lte(a, b)
    fn >(a, b) => __builtin_char_gt(a, b)
    fn >=(a, b) => __builtin_char_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
}

instance Ord Float {
    fn <(a, b) => __builtin_float_lt(a, b)
    fn <=(a, b) => __builtin_float_lte(a, b)
    fn >(a, b) => __builtin_float_gt(a, b)
    fn >=(a, b) => __builtin_float_gte(a, b)

    fn compare(a, b) {
        if a < b {
            return LT
        } else if b < a {
            return GT
        } else {
            return EQ
        }
    }
}

instance Addition Int {
    fn +(a, b) => __builtin_add_int(a, b)
}

instance Num Int {
    from_int = id
    fn *(a, b) => __builtin_multiply_int(a, b)
    fn -(a, b) => __builtin_subtract_int(a, b)
    fn /(a, b) => __builtin_divide_int(a, b)
    fn negate(a) => __builtin_negate_int(a)
    fn abs(a) => __builtin_abs_int(a)
}

instance Addition Char {
    fn +(a, b) => __builtin_add_char(a, b)
}

instance Num Char {
    fn from_int(a) => __builtin_int_to_char(a)
    fn *(a, b) => __builtin_multiply_char(a, b)
    fn -(a, b) => __builtin_subtract_char(a, b)
    fn /(a, b) => __builtin_divide_char(a, b)
    fn negate(a) => __builtin_negate_char(a)
    fn abs(a) => __builtin_abs_char(a)
}

instance Bounded Int {
    fn min_bound() => __builtin_min_int
    fn max_bound() => __builtin_max_int
}

instance Addition Float {
    fn +(a, b) => __builtin_add_float(a, b)
}

instance Num Float {
    fn from_int(a) => __builtin_int_to_float(a)
    fn *(a, b) => __builtin_multiply_float(a, b)
    fn -(a, b) => __builtin_subtract_float(a, b)
    fn /(a, b) => __builtin_divide_float(a, b)
    fn negate(a) => __builtin_negate_float(a)
    fn abs(a) => __builtin_abs_float(a)
}

data Maybe t {
    Just(t)
    Nothing
}

instance Show Maybe a {
    fn str(ma) {
        match ma {
            Just(a) {
                return "Just(" + str(a) + ")"
            }
            Nothing {
                return "Nothing"
            }
        }
    }
}

class Functor f {
    fn fmap(fn (a) b, f a) f b
}

data Either a b {
    Left(a)
    Right(b)
}

struct Vector a {
    # TODO: make sure offset in struct is correct RE dim_offset
    array Ref (*a)
    size Ref Int
    capacity Ref Int
}

instance Show Char {
    fn str(ch) {
        ys := __builtin_calloc(1)
        ys[0] = ch
        return String((ys, 1))
    }
}

class HasLength a {
    fn len(a) Int
}

instance HasLength [a] {
    fn len(v) => !v.size
}

instance HasLength String {
    fn len(s) => match s {
        String((sz, l)) => l
    }
}

fn alloc(count Int) *a {
    return __builtin_calloc(sizeof(a) * count)
}

class HasIndexableItems f {
    fn get_indexed_item(f a, Int) a
}

instance HasIndexableItems * {
    fn get_indexed_item(p *a, index Int) a {
        return !__builtin_ptr_add(p, index)
    }
}

instance HasIndexableItems Vector {
    fn get_indexed_item(vec Vector a, index Int) a {
        return (!vec.array)[index]
    }
}

class HasAssignableIndexableItems f {
    fn set_indexed_item(f a, Int, a) ()
}

instance HasAssignableIndexableItems * {
    fn set_indexed_item(p *a, index Int, a a) {
        __builtin_store_ptr(__builtin_ptr_add(p, index), a)
    }
}

instance HasAssignableIndexableItems Vector {
    fn set_indexed_item(v Vector a, index Int, a a) {
        (!v.array)[index] = a
    }
}

instance Eq [a] {
    fn ==(xs, ys) {
        if !xs.size != !ys.size {
            return False
        }
        size := !xs.size
        var i = 0
        while !i < size {
            if xs[!i] != ys[!i] {
                return False
            }
            i = !i + 1
        }
        return True
    }
    fn !=(xs, ys) {
        if !xs.size != !ys.size {
            return True
        }
        size := !(xs.size)
        var i = 0
        while !i < size {
            if xs[!i] != ys[!i] {
                return True
            }
            i = !i + 1
        }
        return False
    }
}

fn append(vec [a], val a) {
    if !vec.array == null {
        vec.array = alloc(4)
        vec.size = 1
        vec.capacity = 4
        vec[0] = val
        return
        # __builtin_store_ptr(__builtin_ptr_add(!vec.array, 0), val)
    }

    if !vec.capacity <= !vec.size {
        __builtin_goodbye
    }

    if !vec.capacity == 0 {
        __builtin_hello
        /* TODO: handle constant strings */
    }

    __builtin_store_ptr(__builtin_ptr_add(!vec.array, !vec.size), val)
    vec.size = !vec.size + 1
    assert(!vec.size <= !vec.capacity)
}

fn reserve(vec [a], cap Int) {

}

instance HasDefault [a] {
    fn new() {
        return Vector(Ref(null), Ref(0), Ref(0))
    }
}

class Iterable f {
    fn iter(f a) fn () Maybe a
}

instance Iterable Vector {
    fn iter(vec Vector a) {
        index := Ref(-1)
        return fn() {
            index = !index + 1
            if !index >= len(vec) {
                return Nothing
            } else {
                return Just(vec[!index])
            }
        }
    }
}

let unit = ()
fn id(x) => x

fn panic(x) {
    print(x)
    __builtin_exit(1)
}

fn concat(xs [a], ys [a]) {
    # resize(xs, len(xs) + len(ys))
    for y in ys {
        append(xs, y)
    }
}

struct Range a {
    range_min a
    step_size a
    range_max a
}

fn range(max Int) {
    return Range(0, max-1, 1)
}

instance Iterable Range {
    fn iter(ri) {
        index := Ref(ri.range_min)
        return fn () {
            cur_index := !index;
            if cur_index <= ri.range_max {
                index = cur_index + ri.step_size
                return Just(cur_index)
            } else {
                return Nothing
            }
        }
    }
}
