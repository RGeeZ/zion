module _
link module runtime
link module posix
link module math
link module vector
link module map
link module iter as iter_module

# initialization of modules is automatically generated.
# link def __init_modules() void

tag false
tag true

type bool is
	true or
	false

type TypeID has
	var id __typeid__

def str(t TypeID) str
	return str(__int__(t.id))

def typeid(t any) TypeID
	return TypeID(__get_typeid__(t))

def __ineq__(x TypeID, y TypeID) __bool__
	return x.id != y.id

def __bool__(b bool) __bool__
	return b as *runtime.var_t == true as *runtime.var_t

def __bool__(x int) __bool__
	return x.raw != 0r

def __not__(b bool) __bool__
	return __get_typeid__(b) != __get_typeid__(true)

def __not__(b __bool__) __bool__
	return b as __int__ == 0r

def __not__(x int) __bool__
	return x == 0

def bool(x __bool__) bool
	# Since bool is a sum type, there is no default constructor
	# but since it also represents this obvious binary type, we should
	# have a default "boxing" function.
	if x
		return true
	else
		return false

type str has
	# TODO: override str ctor to strdup strings
	var raw *__char__

def __finalize__(s str)
	posix.free(s.raw)

def __box__(s *__char__) str
	return str(posix.strdup(s))

def str(s str) str
	return s

def str(x bool) str
	if x
		return "true"
	else
		return "false"

def int(s str) int
	return int(__int__(s.raw))

type int has
	var raw __int__

def int(x int) int
	return x

def int(x float) int
	return int(__int__(x.raw))

def str(x int) str
	return str(__str__(x.raw))

def str(i __int__) str
	return str(__str__(i))

type float has
	var raw __float__

def float(x float) float
	return x

def float(x int) float
	return float(__float__(x.raw))

def str(x float) str
	return str(__str__(x.raw))

def str(x __float__) str
	return str(__str__(x))

def mask(x int, y int) int
	return int(__mask__(x.raw, y.raw))

def __mod__(x int, y int) int
	return int(x.raw % y.raw)

def __plus__(x str, y str) str
	return str(x.raw + y.raw)

def __plus__(x str, y int) str
	return str(x.raw + str(y).raw)

def __plus__(x str, y __int__) str
	y_expanded := __str__(y)
	result := str(x.raw + y_expanded)
	posix.free(y_expanded)
	return result

def __plus__(x str, y float) str
	return str(x.raw + str(y).raw)

def __plus__(x float, y float) float
	return float(x.raw + y.raw)

def __plus__(x float, y int) float
	return float(x.raw + y.raw)

def __plus__(x int, y float) float
	return float(x.raw + y.raw)

def __plus__(x int, y int) int
	return int(x.raw + y.raw)

def __minus__(x int, y int) int
	return int(x.raw - y.raw)

def __minus__(x float, y int) float
	return float(x.raw - __float__(y.raw))

def __minus__(x int, y float) float
	return float(__float__(x.raw) - y.raw)

def __minus__(x float, y float) float
	return float(x.raw - y.raw)

def __positive__(x int) int
	return x

def __positive__(x float) float
	return x

def __negative__(x int) int
	return int(-x.raw)

def __negative__(x float) float
	return float(-x.raw)

def __divide__(x int, y int) int
	return int(x.raw / y.raw)

def __divide__(x float, y int) float
	return float(x.raw / __float__(y.raw))

def __divide__(x int, y float) float
	return float(__float__(x.raw) / y.raw)

def __divide__(x float, y float) float
	return float(x.raw / y.raw)

def __times__(x int, y int) int
	return int(x.raw * y.raw)

def __times__(x float, y int) float
	return float(x.raw * __float__(y.raw))

def __times__(x int, y float) float
	return float(__float__(x.raw) * y.raw)

def __times__(x float, y float) float
	return float(x.raw * y.raw)

# def __eq__(x *any, y nil) __bool__
# return __is_nil__(x)

# def __eq__(y nil, x *any) __bool__
# return __is_nil__(x)

# def __eq__(x __str__, y nil) __bool__
# return __is_nil__(x)

# def __eq__(x *any T, y *any T) __bool__
# 	return x as __int__ == y as __int__

def __eq__(x int, y int) __bool__
	return x.raw == y.raw

def __eq__(x __int32__, y __int32__) __bool__
	return x as __int__ == y as __int__

def __eq__(x __int16__, y __int16__) __bool__
	return x as __int__ == y as __int__

def __eq__(x __int8__, y __int8__) __bool__
	return x as __int__ == y as __int__

def __eq__(x int, y float) __bool__
	return __float__(x.raw) == y.raw

def __eq__(x float, y int) __bool__
	return x.raw == __float__(y.raw)

def __eq__(x float, y float) __bool__
	return x.raw == y.raw

def __eq__(x str, y str) __bool__
	return posix.strcmp(x.raw, y.raw) == 0r

def __ineq__(x str, y str) __bool__
	return posix.strcmp(x.raw, y.raw) != 0r

# def __ineq__(x *any, y nil) __bool__
# TODO: optimize
# return __is_non_nil__(x)

# def __ineq__(x __str__, y nil) __bool__
# return __is_non_nil__(x)

# def __ineq__(y nil, x *any) __bool__
# TODO: optimize
# 	return __is_non_nil__(x)

# def __ineq__(x *any T, y *any T) __bool__
# 	return x as __int__ != y as __int__

def __ineq__(x int, y int) __bool__
	return x.raw != y.raw

def __ineq__(x __int32__, y __int32__) __bool__
	return x as __int__ != y as __int__

def __ineq__(x __int16__, y __int16__) __bool__
	return x as __int__ != y as __int__

def __ineq__(x __int8__, y __int8__) __bool__
	return x as __int__ != y as __int__

def __ineq__(x int, y float) __bool__
	return __float__(x.raw) != y.raw

def __ineq__(x float, y int) __bool__
	return x.raw != __float__(y.raw)

def __ineq__(x float, y float) __bool__
	return x.raw != y.raw

def __lt__(x int, y int) __bool__
	return x.raw < y.raw

def __lte__(x int, y int) __bool__
	return x.raw <= y.raw

def __gt__(x int, y int) __bool__
	return x.raw > y.raw

def __gte__(x int, y int) __bool__
	return x.raw >= y.raw

def __lt__(x int, y float) __bool__
	return __float__(x.raw) < y.raw

def __lte__(x int, y float) __bool__
	return __float__(x.raw) <= y.raw

def __gt__(x int, y float) __bool__
	return __float__(x.raw) > y.raw

def __gte__(x int, y float) __bool__
	return __float__(x.raw) >= y.raw

def __lt__(x float, y int) __bool__
	return x.raw < __float__(y.raw)

def __lte__(x float, y int) __bool__
	return x.raw < __float__(y.raw)

def __gt__(x float, y int) __bool__
	return x.raw > __float__(y.raw)

def __lt__(x float, y float) __bool__
	return x.raw < y.raw

def __gt__(x float, y float) __bool__
	return x.raw > y.raw

def __lte__(x float, y float) __bool__
	return x.raw <= y.raw

def __gte__(x float, y float) __bool__
	return x.raw >= y.raw

def __gte__(x float, y int) __bool__
	return x.raw >= __float__(y.raw)

def print(x any) void
	posix.puts(str(x).raw)

def breakpoint() void
	posix.raise(posix.SIGTRAP)

type list{T} has
	var value T
	var next list{T}?

def nth(l list{any T}?, index int) any T?
	if l
		if index == 0
			return l.value
		else
			return nth(l.next, index - 1)

	return nil

def len(l list{any T}?) int
	if l
		return len(l.next) + 1
	return 0

def conj(maybe_list list{any T}?, item any T) list{any T}
	if l := maybe_list
		return list(item, l)
	return list(item, nil)


def str(l list{any T}?) str
	return "[" + join(l, ", ") + "]"

type ListIter{V} has
	var list [V]

def iter(l [any V]) ListIter{any V}
	return ListIter(l)

def next(list_iter ListIter{any V}) iter.Step{any V, ListIter{any V}}?
	if item := list_iter.list
		return iter_module.Step(item.value, ListIter(item.next))
	else
		return nil as iter.Step{any V, ListIter{any V}}?

type bytes has
	var data *__int8__
	var cb __int__

def len(b bytes) int
	return int(b.cb)

def alloc(cb int) bytes
	return bytes(posix.calloc(1r, cb.raw) as *__int8__, cb.raw)

def __finalize__(b bytes)
	posix.free(b.data)

def str(b *__int8__, length __int__, encoding str) str
	dest_len := length + 1r
	dest := posix.calloc(1r, dest_len)
	posix.memcpy(dest as *__int8__, b as *__int8__, length)
	return str(dest as *__char__)

def rand(max int) int
	var r __int__ = 0r
	posix.arc4random_buf(&r, sizeof(__int__))
	if r < 0r
		r = -r
	return int(r % max.raw)
