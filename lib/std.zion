global

get runtime
get posix
get bool
get bytes
get str
get utf8
get int
get float
get vector
get map
get math
get file

link in "rt_typeid.o"

link def mem_dump(x *void, y int) void
link def __type_id_eq_type_id(x typeid, y typeid) int

var stdin *posix.FILE = posix.fdopen(0, "r")!
var stdout *posix.FILE = posix.fdopen(1, "a")!
var stderr *posix.FILE = posix.fdopen(2, "a")!

def typeid(t) typeid
	return __get_typeid__(t)

# initialization of modules is automatically generated.
# link def __init_modules() void

def mbstowcs(mbs *char) *wchar
	# Converts from current locale's encoding to wide-char encoding. Allocates memory that
	# must be freed later.
	let mbslen = posix.strlen(mbs)
	let wcs_cb = posix.mbstowcs(null, mbs, 0)
	if wcs_cb == -1
		posix.puts("Failed to convert string from multi-byte to wide char!")
		posix.exit(1)
	let wcs_size = wcs_cb + 1
	let cb = sizeof(wchar) * wcs_size
	let wcs = posix.malloc(cb) as *?wchar
	if wcs == null
		posix.puts("out of memory - set a breakpoint on `exit` in order to debug")
		posix.exit(-1)
		# TODO: create syntax for not reached
		return null as *wchar
	else
		posix.mbstowcs(wcs, mbs, wcs_size)
		return wcs

def wcstombs(wcs *wchar) *char
	# Converts from wide char encoding to current locale's encoding
	# must be freed later.
	let wcslen = posix.wcslen(wcs)
	let mbs_cb = posix.wcstombs(null, wcs, wcslen)
	if mbs_cb == -1
		posix.puts("Failed to convert string from wide char to multi-byte!")
		breakpoint()
		posix.exit(1)

	let mbs_size = mbs_cb + 1
	let cb = sizeof(char) * mbs_size
	let mbs = posix.malloc(cb) as *?char
	if mbs == null
		posix.puts("out of memory - set a breakpoint on `exit` in order to debug")
		posix.exit(-1)
		# TODO: create syntax for not reached
		return null as *char
	else
		posix.wcstombs(mbs, wcs, mbs_size)
		return mbs

def print(x) void
	posix.fputs(utf8(str(x)).raw, stdout)
	posix.fputs("\n", stdout)

def panic(x str) void
	write(stderr, x)
	posix.exit(-1)

tag NoLF

def print(x, _ NoLF) void
	posix.fputs(utf8(str(x)).raw, stdout)

def breakpoint() void
	posix.raise(posix.SIGTRAP)

def rand(max int) int
	# Note that this is not a great way to do this
	var r int = 0
	posix.arc4random_buf(&r, sizeof(int))
	if r < 0
		r = -r
	return r % max


def __bool__(x Int or str or [any T]) bool
	assert(x as *void != null)
	when x
		is Int
			return x.raw != 0
		is str
			return x.raw[0] as int != 0
		is [any T]
			return (x as *vector.vector_t).size != 0

type IntRange has
	var first int
	var lim int
	var step int

def range(lim int) IntRange
	return IntRange(0, lim, 1)

def range(first int, lim int) IntRange
	return IntRange(first, lim, 1)

def range(first int, lim int, step int) IntRange
	return IntRange(first, lim, step)

type IntRangeIter has
	var range IntRange
	var pos int

def __iter_begin__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.first)
	
def __iter_end__(range IntRange) IntRangeIter
	return IntRangeIter(range, range.lim)

def __iter_valid__(i IntRangeIter, end IntRangeIter) bool
	assert(i.range as *void == end.range as *void)
	return i.pos < end.range.lim

def __iterate__(i IntRangeIter)
	i.pos += i.range.step

def __iter_item__(i IntRangeIter) int
	return i.pos

def input() str?
	var buf *?char
	var linecap int = 0

	if posix.getline(&buf, &linecap, stdin) == -1 or buf == null
		return null

	var lim = posix.strlen(buf) - 1
	while lim >= 0 and posix.isspace(buf[lim])
		lim -= 1
	buf[lim + 1] = 0

	assert(buf != null)
	ret := str(mbstowcs(buf))
	posix.free(buf)
	# runtime.gc()
	return ret
