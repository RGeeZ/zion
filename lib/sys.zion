# __host_int relies on the compiler being built on the target platform. So,
# this is only as portable as the compiler build, for now.

newtype FileDescriptor = FileDescriptor(Int)

let stdin = 0 as! FileDescriptor
let stdout = 1 as! FileDescriptor
let stderr = 2 as! FileDescriptor

instance Repr FileDescriptor {
    fn repr(fd) {
        let FileDescriptor(fd) = fd
        return repr(fd)
    }
}

newtype Errno = Errno(Int)

instance Show Errno {
    fn str(errno) {
        let Errno(errno) = errno
        let buffer = alloc(1024) as *Char
        let res = __builtin_ffi_3("strerror_r", errno, buffer, 1024) as *Char
        return String(res, strlen(res))
    }
}

newtype OpenFlags = OpenFlags(Int)
let O_RDONLY   =  __host_int(O_RDONLY) as! OpenFlags  /* open for reading only */
let O_WRONLY   =  __host_int(O_WRONLY) as! OpenFlags  /* open for writing only */
let O_RDWR     =  __host_int(O_RDWR) as! OpenFlags  /* open for reading and writing */
let O_ACCMODE  =  __host_int(O_ACCMODE) as! OpenFlags  /* mask for above modes */
let O_CREAT    =  __host_int(O_CREAT) as! OpenFlags
let O_EXCL     =  __host_int(O_EXCL) as! OpenFlags
let O_NOCTTY   =  __host_int(O_NOCTTY) as! OpenFlags
let O_TRUNC    = __host_int(O_TRUNC) as! OpenFlags
let O_APPEND   = __host_int(O_APPEND) as! OpenFlags
let O_NONBLOCK = __host_int(O_NONBLOCK) as! OpenFlags


newtype CreateMode = CreateMode(Int)
let S_IRWXU = __host_int(S_IRWXU) as! CreateMode /* user (file owner) has read, write, and execute permission */
let S_IRUSR = __host_int(S_IRUSR) as! CreateMode /* user has read permission */
let S_IWUSR = __host_int(S_IWUSR) as! CreateMode /* user has write permission */
let S_IXUSR = __host_int(S_IXUSR) as! CreateMode /* user has execute permission */
let S_IRWXG = __host_int(S_IRWXG) as! CreateMode /* group has read, write, and execute permission */
let S_IRGRP = __host_int(S_IRGRP) as! CreateMode /* group has read permission */
let S_IWGRP = __host_int(S_IWGRP) as! CreateMode /* group has write permission */
let S_IXGRP = __host_int(S_IXGRP) as! CreateMode /* group has execute permission */
let S_IRWXO = __host_int(S_IRWXO) as! CreateMode /* others have read, write, and execute permission */
let S_IROTH = __host_int(S_IROTH) as! CreateMode /* others have read permission */
let S_IWOTH = __host_int(S_IWOTH) as! CreateMode /* others have write permission */
let S_IXOTH = __host_int(S_IXOTH) as! CreateMode /* others have execute permission */

instance Bitwise OpenFlags {
    fn &(a, b) {
        let OpenFlags(a_) = a
        let OpenFlags(b_) = b
        return OpenFlags(__builtin_int_bitwise_and(a_, b_))
    }
    fn |(a, b) {
        let OpenFlags(a) = a
        let OpenFlags(b) = b
        return OpenFlags(__builtin_int_bitwise_or(a, b))
    }
    fn ^(a, b) {
        let OpenFlags(a) = a
        let OpenFlags(b) = b
        return OpenFlags(__builtin_int_bitwise_xor(a, b))
    }
}

instance Bitwise CreateMode {
    fn &(a, b) {
        let CreateMode(a_) = a
        let CreateMode(b_) = b
        return CreateMode(__builtin_int_bitwise_and(a_, b_))
    }
    fn |(a, b) {
        let CreateMode(a) = a
        let CreateMode(b) = b
        return CreateMode(__builtin_int_bitwise_or(a, b))
    }
    fn ^(a, b) {
        let CreateMode(a) = a
        let CreateMode(b) = b
        return CreateMode(__builtin_int_bitwise_xor(a, b))
    }
}

class FileOpen params error {
    fn open(params) WithElseResource FileDescriptor error
}

newtype File = File(String, OpenFlags, CreateMode)

instance FileOpen File Errno {
    fn open(params) {
        let File(String(sz_filename, _), OpenFlags(flags), CreateMode(mode)) = params
        return match __builtin_ffi_3("open", sz_filename, flags, mode) {
            -1 => ResourceFailure(Errno(__builtin_ffi_0("zion_errno")))
            fd => ResourceAcquired(WithResource(FileDescriptor(fd), fn () {
                (__builtin_ffi_1("close", fd) as Int)!
            }))
        }
    }
}

fn unlink(filename String) Int {
    let String(filename, _) = filename
    return __builtin_ffi_1("unlink", filename)
}

fn close(fd Int) Int {
    return __builtin_ffi_1("close", fd)
}

fn creat(filename, mode CreateMode) Int {
    let String(filename, _) = filename
    let CreateMode(mode) = mode
    return __builtin_ffi_2("creat", filename, mode)
}

fn read(fd FileDescriptor, buffer *Char, nbyte Int) Int {
    let FileDescriptor(fd) = fd
    return __builtin_ffi_3("read", fd, buffer, nbyte)
}

# For now all writes are blocking
fn write(file, buffer) Either () Errno {
    let Buffer(pb, cb) = serialize(buffer)
    var cur = 0
    while cur < cb {
        match write_buffer(file, __builtin_ptr_add(pb, cur), cb - cur) {
            Right(errno) {
                return Right(errno)
            }
            Left(bytes_written) {
                cur += bytes_written
            }
        }
    }
    return Left()
}

class WriteBuffer file {
    fn write_buffer(file, *Char, Int) Either Int Errno
}

instance WriteBuffer FileDescriptor {
    fn write_buffer(fd, pb, cb) {
        let FileDescriptor(fd) = fd
        return match __builtin_ffi_3("write", fd, pb, cb) {
            -1 => Right(Errno(__builtin_ffi_0("zion_errno")))
            cb => Left(cb)
        }
    }
}
