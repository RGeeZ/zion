# __host_int relies on the compiler being built on the target platform. So,
# this is only as portable as the compiler build, for now.

newtype OpenFlags = OpenFlags(Int)
let O_RDONLY   =  __host_int(O_RDONLY) as! OpenFlags  /* open for reading only */
let O_WRONLY   =  __host_int(O_WRONLY) as! OpenFlags  /* open for writing only */
let O_RDWR     =  __host_int(O_RDWR) as! OpenFlags  /* open for reading and writing */
let O_ACCMODE  =  __host_int(O_ACCMODE) as! OpenFlags  /* mask for above modes */
let O_CREAT    =  __host_int(O_CREAT) as! OpenFlags
let O_EXCL     =  __host_int(O_EXCL) as! OpenFlags
let O_NOCTTY   =  __host_int(O_NOCTTY) as! OpenFlags
let O_TRUNC    = __host_int(O_TRUNC) as! OpenFlags
let O_APPEND   = __host_int(O_APPEND) as! OpenFlags
let O_NONBLOCK = __host_int(O_NONBLOCK) as! OpenFlags


newtype CreateMode = CreateMode(Int)
let S_IRWXU = __host_int(S_IRWXU) as! CreateMode /* user (file owner) has read, write, and execute permission */
let S_IRUSR = __host_int(S_IRUSR) as! CreateMode /* user has read permission */
let S_IWUSR = __host_int(S_IWUSR) as! CreateMode /* user has write permission */
let S_IXUSR = __host_int(S_IXUSR) as! CreateMode /* user has execute permission */
let S_IRWXG = __host_int(S_IRWXG) as! CreateMode /* group has read, write, and execute permission */
let S_IRGRP = __host_int(S_IRGRP) as! CreateMode /* group has read permission */
let S_IWGRP = __host_int(S_IWGRP) as! CreateMode /* group has write permission */
let S_IXGRP = __host_int(S_IXGRP) as! CreateMode /* group has execute permission */
let S_IRWXO = __host_int(S_IRWXO) as! CreateMode /* others have read, write, and execute permission */
let S_IROTH = __host_int(S_IROTH) as! CreateMode /* others have read permission */
let S_IWOTH = __host_int(S_IWOTH) as! CreateMode /* others have write permission */
let S_IXOTH = __host_int(S_IXOTH) as! CreateMode /* others have execute permission */

instance Bitwise OpenFlags {
    fn &(a, b) {
        OpenFlags(a_) := a
        OpenFlags(b_) := b
        return OpenFlags(__builtin_int_bitwise_and(a_, b_))
    }
    fn |(a, b) {
        OpenFlags(a) := a
        OpenFlags(b) := b
        return OpenFlags(__builtin_int_bitwise_or(a, b))
    }
    fn ^(a, b) {
        OpenFlags(a) := a
        OpenFlags(b) := b
        return OpenFlags(__builtin_int_bitwise_xor(a, b))
    }
}

instance Bitwise CreateMode {
    fn &(a, b) {
        CreateMode(a_) := a
        CreateMode(b_) := b
        return CreateMode(__builtin_int_bitwise_and(a_, b_))
    }
    fn |(a, b) {
        CreateMode(a) := a
        CreateMode(b) := b
        return CreateMode(__builtin_int_bitwise_or(a, b))
    }
    fn ^(a, b) {
        CreateMode(a) := a
        CreateMode(b) := b
        return CreateMode(__builtin_int_bitwise_xor(a, b))
    }
}

fn open(filename, flags OpenFlags, mode CreateMode) Int {
    String(filename, _) := filename
    OpenFlags(flags) := flags
    CreateMode(mode) := mode
    return __builtin_ffi_3("open", filename, flags, mode)
}

fn unlink(filename String) Int {
    String(filename, _) := filename
    return __builtin_ffi_1("unlink", filename)
}

fn close(fd Int) Int {
    return __builtin_ffi_1("close", fd)
}

fn creat(filename, mode CreateMode) Int {
    String(filename, _) := filename
    CreateMode(mode) := mode
    return __builtin_ffi_2("creat", filename, mode)
}

fn read(fd Int, buffer *Char, nbyte Int) Int {
    return __builtin_ffi_3("read", fd, buffer, nbyte)
}

fn write(fd Int, buffer *Char, nbyte Int) Int {
    return __builtin_ffi_3("write", fd, buffer, nbyte)
}
