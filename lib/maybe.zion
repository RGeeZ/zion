global

type Maybe T is {
    Just(t T)
    Empty
}

fn exists(m Maybe any) bool {
    match m {
        Empty {
            return false
        }
        Just(_) {
            return true
        }
    }
}

fn __eq__[U](lhs Maybe U, rhs Maybe U) bool {
    match rhs {
        Just(rhs_value) {
            match lhs {
                Just(lhs_value) {
                    return lhs_value == rhs_value
                }
                Empty {
                    return false
                }
            }
        }
        Empty {
            match lhs {
                Just(_) {
                    return false
                }
                Empty {
                    return true
                }
            }
        }
    }
}

fn __eq__[U, V where U === V](lhs U, rhs Maybe V) bool {
    match rhs {
        Just(rhs_value) {
            return lhs == rhs_value
        }
        Empty {
            return false
        }
    }
}

fn __ineq__[U, V where U === V](lhs U, rhs Maybe V) bool {
    match rhs {
        Just(rhs_value) {
            return lhs != rhs_value
        }
        Empty {
            return true
        }
    }
}

fn __eq__[U, V where U === V](lhs Maybe U, rhs V) bool {
    match lhs {
        Just(lhs_value) {
            return lhs_value == rhs
        }
        Empty {
            return false
        }
    }
}

fn __ineq__[U, V where U === V](lhs Maybe U, rhs V) bool {
    match lhs {
        Just(lhs_value) {
            return lhs_value != rhs
        }
        Empty {
            return true
        }
    }
}

fn join[A](a Maybe (Maybe A)) Maybe A {
    match a {
        Just(a) {
            return a
        }
        Empty {
            return Empty
        }
    }
}

fn fail[A](reason str) A? {
    return Empty
}

fn pure[A](v A) A? {
    return Just(v)
}

fn bind[A, B](a Maybe A, f fn (a A) Maybe B) Maybe B {
    match a {
        Empty {
            return Empty
        }
        Just(a) {
            return f(a)
        }
    }
}
    
fn fmap[A, B where not (B === void)](f fn (a A) B, a Maybe A) Maybe B {
    match a {
        Empty {
            return Empty
        }
        Just(x) {
            return Just(f(x))
        }
    }
}

fn fmap[A](f fn (a A) void, a Maybe A) void {
    match a {
        Empty {
            return
        }
        Just(x) {
            f(x)
            return
        }
    }
}
