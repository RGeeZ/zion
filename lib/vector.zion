module vector
get posix
get runtime

type vector_t struct
	var _var     var_t
	var reserved size_t
	var size     size_t
	var items    *?*var_t

type vector{T} link vector_t __vector_free__ __vector_mark__

[global]
def reserved(v vector{any}) int
	return (v as *vector_t).reserved

[global]
def len(v vector{any}) int
	return int((v as *vector_t).size)

[global]
def __init__() vector{any T}
	typeinfo := typeinfo(vector{any T})
	let v = runtime.create_var(typeinfo)
	return v as vector{any T}
		
def __init_vector__(size size_t) vector{any T}
	let v vector{any T}
	reserve(v as *vector_t, size)
	return v as vector{any T}
		
[global]
def __finalize__(v vector{any T})
	print("finalizing " + str(v))
	__vectorfree__(v as *var_t)

[global]
def str(v [any T]) str
	return "[" + join(v, ", ") + "]"

[global]
def join(v [any T], delim str) str
	let vec = v as *vector_t

	# allocate a vector in which we can store the converted strings
	let strs [str]
	reserve(strs as *vector_t, vec.size)

	let delim_len = posix.wcslen(delim.raw)
	let delims_len = delim_len * (vec.size - 1)
	total_len := delims_len
	i := 0
	while i < vec.size
		let s = str(vec.items[i] as any T)
		append(strs, s)
		total_len += len(s).raw
		i += 1

	# allocate our resultant string
	let buf *wchar = posix.malloc(sizeof(wchar) * (total_len + 1))! as *wchar

	# iterate over the elements and append them to our resultant string
	pos := 0
	i = 0
	while i < vec.size
		if i > 0
			# insert a delim if necessary
			posix.memcpy(&buf[pos], delim.raw, sizeof(wchar) * delim_len)
			pos += delim_len

		# insert a string
		let s_len = posix.wcslen(strs[i].raw)
		posix.memcpy(&buf[pos], strs[i].raw, sizeof(wchar) * s_len)

		pos += s_len
		i += 1

	buf[pos] = 0 as wchar
	return str(buf)

[global]
def __getitem__(vec [any T], index int) any T
	return __getvectoritem__((vec as *vector_t), index.raw) as any T

[global]
def __getitem__(vec [any T], index int) any T
	return __getvectoritem__(vec as *vector_t, index) as any T

[global]
def __setitem__(vec [any T], index int, t any T) void
	__setvectoritem__(vec as *vector_t, index.raw, t as *var_t)

[global]
def append(vec [any T], t any T) void
	# posix.puts("appending " + __str__(t.raw) + " to vector")
	__vectorappend__(vec as *vector_t, t as *var_t)

[global]
def resize(vec [any T], size int, default any T) void
	resize(vec as *vector_t, size.raw, default as *var_t)

def resize(vec *vector_t, size int, default *var_t) void
	if size < 0
		return

	if vec.size == size
		return
	elif vec.size < size
		# grow the vector
		reserve(vec, size)
		while vec.size < size
			__vector_unsafe_append__(vec, default)
	else
		# just shorten the vector in place
		vec.size = size


[global]
def __vector_mark__(vec *var_t)
	# posix.puts("marking vector at 0x" + __str__(vec as int, 16))
	let v = vec as *vector_t
	i := 0
	while i < v.size
		runtime.mark_allocation(v.items[i])
		i += 1

[global]
def __vector_free__(var_ *var_t)
	# assert(var_ != 0)
	let vector = var_ as *vector_t

	/* the gc will handle cleaning up everything that we pointed to, but we need to free up our
	 * extra allocated heap space. */
	posix.free(vector.items)

	/* zion will handle deleting the actual vector_t, since it will be attached to the managed
	 * object */


def __getvectoritem__(vector *vector_t, index int) *var_t
	if index >= 0 and index < vector.size
		return vector.items[index]

	print("zion: array index out of bounds (0x" + __box__(__str__(vector as int, 16)) + "[" + int(index) + "]) where array has length " + int(vector.size))
	assert(false)
	return null as *var_t

def __setvectoritem__(vector *vector_t, index uint, item *var_t)
	if index < 0
		return

	if index < vector.size
		vector.items[index] = item
	else
		print("zion: array index out of bounds (0x" + __box__(__str__(vector as int, 16)) + "[" + int(index) + "])")
		assert(false)

def __vector_unsafe_append__(vector *vector_t, item *var_t) void
	# To be called by compiler for vector literals
	assert(vector.reserved > vector.size)
	vector.items[vector.size] = item
	vector.size += 1

def __vectorappend__(vector *vector_t, item *var_t) void
	if vector.reserved > vector.size
		# print("we have space")
		let items = vector.items
		assert(items != null)
		items[vector.size] = item
		vector.size += 1
	else
		let existing_items = vector.items
		if existing_items != null
			# print("we need to re-allocate space because " + vector.reserved + " <= " + vector.size)
			assert(vector.reserved == vector.size)
			new_reserved := vector.reserved * 2
			if new_reserved < 16
				/* start at a level that we avoid a lot of extra calls to malloc */
				new_reserved = 16

			new_items := posix.calloc(sizeof(*var_t), new_reserved) as *?*var_t
			assert(new_items != null)
			posix.memcpy(new_items as *int8, existing_items as *int8, sizeof(*var_t) * vector.size)
			new_items[vector.size] = item
			vector.size += 1

			posix.free(vector.items)
			vector.items = new_items
			vector.reserved = new_reserved
		else
			# print("we need to go from zero space to newly allocated space")
			assert(vector.reserved == 0)
			vector.items = posix.calloc(sizeof(*var_t), 4)! as **var_t
			vector.reserved = 4
			vector.size = 1
			vector.items[0] = item

[global]
def reserve(vec [any T], n int)
	# Call the unmanaged version
	reserve(vec as *vector_t, n.raw)

def reserve(vec *vector_t, n size_t)
	# Make sure we've got n spaces available in our vector's allocated memory
	if vec.reserved < n
		let items = vec.items
		if items != null
			new_items := posix.calloc(sizeof(*var_t), n)! as **var_t
			posix.memcpy(new_items as *int8, items as *int8, sizeof(*var_t) * vec.size)
			posix.free(items)
			vec.items = new_items
			vec.reserved = n
		else
			vec.items = posix.calloc(sizeof(*var_t), n)! as **var_t
			vec.reserved = n
		

[global]
def copy(orig [any T]) [any T]
	var new [any T]
	reserve(new, len(orig))
	i := 0
	while i != len(orig)
		append(new, orig[i])
		i += 1
	return new

[global]
def copy(orig [any T], t any T) [any T]
	var new [any T]
	reserve(new, len(orig) + 1)
	i := 0
	while i != len(orig)
		append(new, orig[i])
		i += 1
	append(new, t)
	return new

[global]
def splice(vec [any T], index int, count int) void
	let v = vec as *vector_t
	let orig_count = v.size
	let i = index.raw
	let c = count.raw
	let skip_to = i + c
	if c < 0 or skip_to < 0 or skip_to > orig_count
		panic("invalid index (" + index + ") and count (" + count + ") passed to vector.splice\n")

	posix.memmove(&v.items[i], &v.items[skip_to], (orig_count - skip_to) * sizeof(*var_t))
	v.size = orig_count - c

type vector_iter{C} has
	var vec [C]
	var pos int

[global]
def __iter_begin__(c [any C]) vector_iter{any C}
	return vector_iter(c, 0)
	
[global]
def __iter_end__(c [any C]) vector_iter{any C}
	return vector_iter(c, (c as *vector.vector_t).size)

[global]
def __iter_valid__(i vector_iter{any C}, end vector_iter{any C}) bool
	assert(i.vec as *vector_t == end.vec as *vector_t)
	return i.pos < end.pos

[global]
def __iterate__(i vector_iter{any C})
	i.pos += 1

[global]
def __iter_item__(i vector_iter{any C}) any C
	v := i.vec as *vector_t
	assert(i.pos < v.size)
	return v.items[i.pos] as any C

