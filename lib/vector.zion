module vector
link module posix
link module runtime

type vector_t struct
	var _var     runtime.var_t
	var reserved __int__
	var size     __int__
	var items    **runtime.var_t

type vector{T} link vector_t __vector_free__ __vector_mark__

[module std]
def reserved(v vector{any}) __int__
	return (v as *vector_t).reserved

[module std]
def len(v vector{any}) __int__
	return (v as *vector_t).size

[module std]
def __init__() vector{any T}
	typeinfo := typeinfo(vector{any T})
	v := runtime.create_var(typeinfo) as vector{any T}
	print("new vector")
	print(reserved(v))
	print(len(v))
	return v
		
def __finalize__(v vector{any T})
	__vectorfree__(v as *runtime.var_t)

[module std]
def __getitem__(vec [any T], index int) any T
	posix.puts(__str__(vec as __int__))
	return __getvectoritem__((vec as *vector_t), index.raw) as any T

[module std]
def __getitem__(vec [any T], index __int__) any T
	return __getvectoritem__(vec as *vector_t, index) as any T

[module std]
def __setitem__(vec [any T], index int, t any T) void
	return __setvectoritem__(vec as *runtime.var_t, index.raw, t as *runtime.var_t)

def append(vec [any T], t any T) void
	__vectorappend__(vec as *vector_t, t as *runtime.var_t)

def resize(vec [any T], size int, default any T) void
	return __vectorresize__(vec as *runtime.var_t, size.raw, default) as! [any T]

# link def vec(TYPE, capacity int) TYPE[]

[module std]
def __vector_mark__(vec *runtime.var_t)
	v := vec as *vector_t
	i := 0r
	while i < v.size
		runtime.mark_allocation(v.items[i])
		i += 1r

[module std]
def __vector_free__(var_ *runtime.var_t)
	# assert(var_ != 0)
	vector := var_ as *vector_t

	/* the gc will handle cleaning up everything that we pointed to, but we need to free up our
	 * extra allocated heap space. */
	posix.free(vector.items as __bytes)

	/* zion will handle deleting the actual vector_t, since it will be attached to the managed
	 * object */


def __getvectoritem__(vector *vector_t, index __int__) *runtime.var_t
	if index >= 0r
		if index < vector.size
			print("accessing vector at " + int(index))
			print(vector as __int__)
			print(vector.items as __int__)
			return vector.items[index]

	print("zion: array index out of bounds (" + int(vector as __int__) + int(index) + ")")
	posix.exit(-1r)
	return nil as *runtime.var_t

def __setvectoritem__(vector *vector_t, index __int__, item *runtime.var_t)
	if index < 0r
		return

	if index < vector.size
		vector.items[index] = item
	else
		print("zion: array index out of bounds (" + int(vector as __int__) + str(index) + ")")
		posix.exit(-1r)

def __vectorappend__(vector *vector_t, item *runtime.var_t)
	print("appending to a vector")
	print("vector.reserved = " + int(vector.reserved))
	print("vector.size = " + int(vector.size))
	print(str(vector.items as __int__))
	assert(vector)
	if vector.reserved > vector.size
		print("we have space")
		assert(vector.items)
		vector.items[vector.size] = item
		vector.size += 1r
	elif vector.items
		print("we need to re-allocate space")
		assert(vector.reserved == vector.size)
		new_reserved := vector.reserved * 2r
		if new_reserved < 16r
			/* start at a level that we avoid a lot of extra calls to malloc */
			new_reserved = 16r

		new_items := posix.calloc(sizeof(*runtime.var_t), new_reserved) as **runtime.var_t
		posix.memcpy(new_items as __bytes, vector.items as __bytes, sizeof(*runtime.var_t) * vector.size)
		new_items[vector.size] = item
		vector.size += 1r

		posix.free(vector.items as __bytes)
		vector.items = new_items
	else
		print(int(vector.reserved))
		print("we need to go from zero space to newly allocated space")
		assert(vector.reserved == 0r)
		vector.items = posix.calloc(sizeof(*runtime.var_t), 4r) as **runtime.var_t
		vector.reserved = 4r
		vector.size = 1r
		vector.items[0r] = item
		print(vector.items[0r] as __int__)
