module vector
get posix
get runtime

type ManagedVector struct
	var _var     var_t
	var reserved size_t
	var size     size_t
	var items    *?*var_t

type NativeVector T struct
	var _var     var_t
	var reserved size_t
	var size     size_t
	var items    *?T

type VectorImpl T = if (gc T) ManagedVector (NativeVector T)

type Vector T link

[global]
def reserved[T](v [T]) int
	# NB: native and managed vectors share memory layout up to the `items`
	return (v as *(VectorImpl T)).reserved

[global]
def len(v [any]) int
	return (v as *(VectorImpl T)).size

[global]
def __init__[T where gc T]() [T]
	let ti = typeinfo(
		[T],
		ManagedVector,
		__managed_vector_free__,
		__managed_vector_mark__)

	return runtime.create_var(ti) as [T]
		
[global]
def __init__[T where not gc T]() [T]
	let ti = typeinfo(
		[T],
		native_vector T,
		__native_vector_free__,
		__native_vector_mark__)

	return runtime.create_var(ti) as [T]
		
def __init_vector__[T](size size_t) [T]
	# Used by the compiler to instantiate vector literals
	# see src/type_checker.cpp `create_bound_vector_literal`
	let v [T]
	reserve(v as *(VectorImpl T), size)
	return v

[global]
def str(v [any]) str
	return "[" + join(v, ", ") + "]"

[global]
def join[T](v [T], delim str) str
	let vec = v as *(VectorImpl T)

	# allocate a vector in which we can store the converted strings
	let strs [str]
	reserve(strs as *(VectorImpl T), vec.size)

	let delim_len = posix.wcslen(delim.raw)
	let delims_len = delim_len * (vec.size - 1)
	total_len := delims_len
	i := 0
	while i < vec.size
		let s = str(vec.items[i] as any T)
		append(strs, s)
		total_len += len(s)
		i += 1

	# allocate our resultant string
	let buf *wchar = posix.malloc(sizeof(wchar) * (total_len + 1))! as *wchar

	# iterate over the elements and append them to our resultant string
	pos := 0
	i = 0
	while i < vec.size
		if i > 0
			# insert a delim if necessary
			posix.memcpy(&buf[pos], delim.raw, sizeof(wchar) * delim_len)
			pos += delim_len

		# insert a string
		let s_len = posix.wcslen(strs[i].raw)
		posix.memcpy(&buf[pos], strs[i].raw, sizeof(wchar) * s_len)

		pos += s_len
		i += 1

	buf[pos] = 0 as wchar
	return str(buf)

[global]
def __getitem__[T](vec [T], index int) T
	return __get_managed_vector_item__((vec as *(VectorImpl T)), index) as T

[global]
def __setitem__[T where gc T](vec [T], index int, t T) void
	__set_vector_item__(vec as *ManagedVector, index, t as *var_t)

[global]
def __setitem__[T where not(gc T)](vec [T], index int, t T) void
	__set_vector_item__(vec as *(NativeVector T), index, t)

[global]
def append[T where gc T](vec [T], t T) void
	# posix.puts("appending " + __str__(t) + " to vector")
	__vectorappend__(vec as *ManagedVector, t as *var_t)

[global]
def append[T where not(gc T)](vec [T], t T) void
	# posix.puts("appending " + __str__(t) + " to vector")
	__vectorappend__(vec as *(NativeVector T), t)

[global]
def resize[T where gc T](vec [T], size int, default T) void
	resize(vec as *ManagedVector, size, default as *var_t)

def resize(vec *ManagedVector, size int, default *var_t) void
	if size < 0
		return

	if vec.size == size
		return
	elif vec.size < size
		# grow the vector
		reserve(vec, size)
		while vec.size < size
			__vector_unsafe_append__(vec, default)
	else
		# just shorten the vector in place
		vec.size = size


[global]
def __managed_vector_mark__(vec *var_t)
	# posix.puts("marking vector at 0x" + __str__(vec as int, 16))
	let v = vec as *ManagedVector
	i := 0
	while i < v.size
		runtime.mark_allocation(v.items[i])
		i += 1

[global]
def __managed_vector_free__(var *var_t)
	let vector = var as *ManagedVector

	/* the gc will handle cleaning up everything that we pointed to, but we need to free up our
	 * extra allocated heap space. */
	posix.free(vector.items)

	/* zion will handle deleting the actual vector_t, since it will be attached to the managed
	 * object */

[global]
def __native_vector_free__(var *var_t)
	let vector = var as *(NativeVector *void)

	/* the gc will handle cleaning up everything that we pointed to, but we need to free up our
	 * extra allocated heap space. */
	posix.free(vector.items)

	/* zion will handle deleting the actual vector_t, since it will be attached to the managed
	 * object */


def __get_managed_vector_item__(vector *ManagedVector, index int) *var_t
	assert(index >= 0 and index < vector.size)
	return vector.items[index]


def __get_native_vector_item__[T](vector *(NativeVector T), index int) T
	assert(index >= 0 and index < vector.size)
	return vector.items[index]


def __set_vector_item__(vector *ManagedVector, index uint, item *var_t)
	if index < 0
		return

	assert(index < vector.size)
	vector.items[index] = item


def __set_vector_item__[T](vector *(NativeVector T), index uint, item T)
	if index < 0
		return

	assert(index < vector.size)
	vector.items[index] = item


def __vector_unsafe_append__(vector *vector_t, item *var_t) void
	# To be called by compiler for vector literals
	assert(vector.reserved > vector.size)
	vector.items[vector.size] = item
	vector.size += 1

# This is mildly unsafe against future changes...
def __vectorappend__[V, I](vector *V, item I) void
	if vector.reserved > vector.size
		# we have space
		let items = vector.items
		assert(items != null)
		items[vector.size] = item
		vector.size += 1
	else
		let existing_items = vector.items
		if existing_items != null
			# we need to re-allocate space because vector.reserved <= vector.size
			assert(vector.reserved == vector.size)
			new_reserved := vector.reserved * 2
			if new_reserved < 16
				/* start at a level that we avoid a lot of extra calls to malloc */
				new_reserved = 16

			new_items := posix.calloc(sizeof(I), new_reserved) as *?I
			assert(new_items != null)
			posix.memcpy(new_items as *int8, existing_items as *int8, sizeof(I) * vector.size)
			new_items[vector.size] = item
			vector.size += 1

			posix.free(vector.items)
			vector.items = new_items
			vector.reserved = new_reserved
		else
			# we need to go from zero space to newly allocated space
			assert(vector.reserved == 0)
			vector.items = posix.calloc(sizeof(I), 4)! as *I
			vector.reserved = 4
			vector.size = 1
			vector.items[0] = item

[global]
def reserve(vec [any T], n int)
	# Call the unmanaged version
	assert(n >= 0)
	reserve(vec as *vector_t, n)

def reserve(vec *ManagedVector, n size_t)
	# Make sure we've got n spaces available in our vector's allocated memory
	if vec.reserved < n
		let items = vec.items
		if items != null
			new_items := posix.calloc(sizeof(*var_t), n)! as **var_t
			posix.memcpy(new_items as *int8, items as *int8, sizeof(*var_t) * vec.size)
			posix.free(items)
			vec.items = new_items
			vec.reserved = n
		else
			vec.items = posix.calloc(sizeof(*var_t), n)! as **var_t
			vec.reserved = n
		

[global]
def copy(orig [any T]) [any T]
	var new [any T]
	reserve(new, len(orig))
	i := 0
	while i != len(orig)
		append(new, orig[i])
		i += 1
	return new

[global]
def copy(orig [any T], t any T) [any T]
	var new [any T]
	reserve(new, len(orig) + 1)
	i := 0
	while i != len(orig)
		append(new, orig[i])
		i += 1
	append(new, t)
	return new

[global]
def splice(vec [any T], index int, count int) void
	let v = vec as *vector_t
	let orig_count = v.size
	let i = index.raw
	let c = count.raw
	let skip_to = i + c
	if c < 0 or skip_to < 0 or skip_to > orig_count
		panic("invalid index (" + index + ") and count (" + count + ") passed to vector.splice\n")

	posix.memmove(&v.items[i], &v.items[skip_to], (orig_count - skip_to) * sizeof(*var_t))
	v.size = orig_count - c

type VectorIter C has
	var vec [C]
	var pos int

[global]
def __iter_begin__(c [any C]) VectorIter any C
	return VectorIter(c, 0)
	
[global]
def __iter_end__(c [any C]) VectorIter any C
	return VectorIter(c, len(c))

[global]
def __iter_valid__(i VectorIter any C, end VectorIter any C) bool
	return i.pos < end.pos

[global]
def __iterate__(i VectorIter any C)
	i.pos += 1

[global]
def __iter_item__(i VectorIter any C) any C
	assert(i.pos < len(v))
	return v[i.pos]
