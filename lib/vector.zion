module vector
get posix
get runtime

type vector_t struct
	var _var     var_t
	var reserved size_t
	var size     size_t
	var items    **var_t

type vector{T} link vector_t __vector_free__ __vector_mark__

[global]
def reserved(v vector{any}) int_t
	return (v as *vector_t).reserved

[global]
def len(v vector{any}) int
	return int((v as *vector_t).size)

[global]
def __init__() vector{any T}
	typeinfo := typeinfo(vector{any T})
	let v = runtime.create_var(typeinfo)
	return v as vector{any T}
		
def __init_vector__(size size_t) vector{any T}
	let v vector{any T}
	reserve(v as *vector_t, size)
	return v as vector{any T}
		
[global]
def __finalize__(v vector{any T})
	print("finalizing " + str(v))
	__vectorfree__(v as *var_t)

[global]
def str(v [any T]) str
	return "[" + join(v, ", ") + "]"

[global]
def join(v [any T], delim str) str
	let vec = v as *vector_t
	s := ""
	sep := ""
	i := 0r
	while i < vec.size
		s += sep
		s += str(vec.items[i] as any T)
		sep = delim
		i += 1r
	return s

[global]
def __getitem__(vec [any T], index int) any T
	return __getvectoritem__((vec as *vector_t), index.raw) as any T

[global]
def __getitem__(vec [any T], index int_t) any T
	return __getvectoritem__(vec as *vector_t, index) as any T

[global]
def __setitem__(vec [any T], index int, t any T) void
	__setvectoritem__(vec as *vector_t, index.raw, t as *var_t)

[global]
def append(vec [any T], t any T) void
	# posix.puts("appending "r + __str__(t.raw) + " to vector"r)
	__vectorappend__(vec as *vector_t, t as *var_t)

[global]
def resize(vec [any T], size int, default any T) void
	return __vectorresize__(vec as *var_t, size.raw, default) as! [any T]

# link def vec(TYPE, capacity int) TYPE[]

[global]
def __vector_mark__(vec *var_t)
	# posix.puts("marking vector at 0x"r + __str__(vec as int_t, 16r))
	let v = vec as *vector_t
	i := 0r
	while i < v.size
		runtime.mark_allocation(v.items[i])
		i += 1r

[global]
def __vector_free__(var_ *var_t)
	# assert(var_ != 0)
	let vector = var_ as *vector_t

	/* the gc will handle cleaning up everything that we pointed to, but we need to free up our
	 * extra allocated heap space. */
	posix.free(vector.items)

	/* zion will handle deleting the actual vector_t, since it will be attached to the managed
	 * object */


def __getvectoritem__(vector *vector_t, index int_t) *var_t
	if index >= 0r and index < vector.size
		return vector.items[index]

	print("zion: array index out of bounds (0x" + __box__(__str__(vector as int_t, 16r)) + "[" + int(index) + "]) where array has length " + int(vector.size))
	assert(false)
	return null as *var_t

def __setvectoritem__(vector *vector_t, index uint_t, item *var_t)
	if index < 0r
		return

	if index < vector.size
		vector.items[index] = item
	else
		print("zion: array index out of bounds (0x" + __box__(__str__(vector as int_t, 16r)) + "[" + int(index) + "])")
		assert(false)

def __vector_unsafe_append__(vector *vector_t, item *var_t) void
	# To be called by compiler for vector literals
	assert(vector.reserved > vector.size)
	vector.items[vector.size] = item
	vector.size += 1r

def __vectorappend__(vector *vector_t, item *var_t) void
	assert(vector)
	if vector.reserved > vector.size
		# print("we have space")
		assert(vector.items)
		vector.items[vector.size] = item
		vector.size += 1r
	elif vector.items
		# print("we need to re-allocate space because " + vector.reserved + " <= " + vector.size)
		assert(vector.reserved == vector.size)
		new_reserved := vector.reserved * 2r
		if new_reserved < 16r
			/* start at a level that we avoid a lot of extra calls to malloc */
			new_reserved = 16r

		new_items := posix.calloc(sizeof(*var_t), new_reserved) as **var_t
		posix.memcpy(new_items as *int8_t, vector.items as *int8_t, sizeof(*var_t) * vector.size)
		new_items[vector.size] = item
		vector.size += 1r

		posix.free(vector.items)
		vector.items = new_items
		vector.reserved = new_reserved
	else
		# print("we need to go from zero space to newly allocated space")
		assert(vector.reserved == 0r)
		vector.items = posix.calloc(sizeof(*var_t), 4r) as **var_t
		vector.reserved = 4r
		vector.size = 1r
		vector.items[0r] = item

[global]
def reserve(vec [any T], n int)
	# Call the unmanaged version
	reserve(vec as *vector_t, n.raw)

def reserve(vec *vector_t, n size_t)
	# Make sure we've got n spaces available in our vector's allocated memory
	if vec.reserved < n
		if vec.items
			new_items := posix.calloc(sizeof(*var_t), n) as **var_t
			posix.memcpy(new_items as *int8_t, vec.items as *int8_t, sizeof(*var_t) * vec.size)
			posix.free(vec.items)
			vec.items = new_items
			vec.reserved = n
		else
			vec.items = posix.calloc(sizeof(*var_t), n) as **var_t
			vec.reserved = n
		

[global]
def copy(orig [any T]) [any T]
	var new [any T]
	reserve(new, len(orig))
	i := 0
	while i != len(orig)
		append(new, orig[i])
		i += 1
	return new

[global]
def copy(orig [any T], t any T) [any T]
	var new [any T]
	reserve(new, len(orig) + 1)
	i := 0
	while i != len(orig)
		append(new, orig[i])
		i += 1
	append(new, t)
	return new

[global]
def splice(vec [any T], index int, count int) void
	let v = vec as *vector_t
	let orig_count = v.size
	let i = index.raw
	let c = count.raw
	let skip_to = i + c
	if c < 0r or skip_to < 0r or skip_to > orig_count
		panic("invalid index (" + index + ") and count (" + count + ") passed to vector.splice\n")

	posix.memmove(&v.items[i], &v.items[skip_to], (orig_count - skip_to) * sizeof(*var_t))
	v.size = orig_count - c

type vector_iter{C} has
	var vec [C]
	var pos int_t

[global]
def __iter_begin__(c [any C]) vector_iter{any C}
	return vector_iter(c, 0r)
	
[global]
def __iter_end__(c [any C]) vector_iter{any C}
	return vector_iter(c, (c as *vector.vector_t).size)

[global]
def __iter_valid__(i vector_iter{any C}, end vector_iter{any C}) bool_t
	assert(i.vec as *vector_t == end.vec as *vector_t)
	return i.pos < end.pos

[global]
def __iterate__(i vector_iter{any C})
	i.pos += 1r

[global]
def __iter_item__(i vector_iter{any C}) any C
	v := i.vec as *vector_t
	assert(i.pos < v.size)
	return v.items[i.pos] as any C

