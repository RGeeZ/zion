module vector
link module posix
link module runtime

type vector_t struct
	var _var     runtime.var_t
	var reserved __int__
	var size     __int__
	var items    **runtime.var_t

type vector{T} link vector_t __vector_free__ __vector_mark__

[module std]
def reserved(v vector{any}) __int__
	return (v as *vector_t).reserved

[module std]
def len(v vector{any}) int
	return int((v as *vector_t).size)

[module std]
def __init__() vector{any T}
	typeinfo := typeinfo(vector{any T})
	v := runtime.create_var(typeinfo)
	return v as vector{any T}
		
def __finalize__(v vector{any T})
	__vectorfree__(v as *runtime.var_t)

[module std]
def __bool__(l [any]) __bool__
	return (l as *vector_t).size != 0r

[module std]
def str(v [any T]) str
	return "[" + join(v, ", ") + "]"

[module std]
def join(v [any T], delim str) str
	vec := v as *vector_t
	s := ""
	sep := ""
	i := 0r
	while i < vec.size
		s += sep
		s += str(vec.items[i] as any T)
		sep = delim
		i += 1r
	return s

[module std]
def __getitem__(vec [any T], index int) any T
	return __getvectoritem__((vec as *vector_t), index.raw) as any T

[module std]
def __getitem__(vec [any T], index __int__) any T
	return __getvectoritem__(vec as *vector_t, index) as any T

[module std]
def __setitem__(vec [any T], index int, t any T) void
	return __setvectoritem__(vec as *runtime.var_t, index.raw, t as *runtime.var_t)

[module std]
def append(vec [any T], t any T) void
	# posix.puts("appending "r + __str__(t.raw) + " to vector"r)
	__vectorappend__(vec as *vector_t, t as *runtime.var_t)

[module std]
def resize(vec [any T], size int, default any T) void
	return __vectorresize__(vec as *runtime.var_t, size.raw, default) as! [any T]

# link def vec(TYPE, capacity int) TYPE[]

[module std]
def __vector_mark__(vec *runtime.var_t)
	# posix.puts("marking vector at 0x"r + __str__(vec as __int__, 16r))
	v := vec as *vector_t
	i := 0r
	while i < v.size
		runtime.mark_allocation(v.items[i])
		i += 1r

[module std]
def __vector_free__(var_ *runtime.var_t)
	# assert(var_ != 0)
	vector := var_ as *vector_t

	/* the gc will handle cleaning up everything that we pointed to, but we need to free up our
	 * extra allocated heap space. */
	posix.free(vector.items)

	/* zion will handle deleting the actual vector_t, since it will be attached to the managed
	 * object */


def __getvectoritem__(vector *vector_t, index __int__) *runtime.var_t
	if index >= 0r and index < vector.size
		return vector.items[index]

	print("zion: array index out of bounds (0x" + __box__(__str__(vector as __int__, 16r)) + "[" + int(index) + "])")
	assert(false)
	return nil as *runtime.var_t

def __setvectoritem__(vector *vector_t, index __int__, item *runtime.var_t)
	if index < 0r
		return

	if index < vector.size
		vector.items[index] = item
	else
		print("zion: array index out of bounds (0x" + __box__(__str__(vector as __int__, 16r)) + "[" + int(index) + "])")
		assert(false)

def __vectorappend__(vector *vector_t, item *runtime.var_t)
	assert(vector)
	if vector.reserved > vector.size
		# print("we have space")
		assert(vector.items)
		vector.items[vector.size] = item
		vector.size += 1r
	elif vector.items
		# print("we need to re-allocate space because " + vector.reserved + " <= " + vector.size)
		assert(vector.reserved == vector.size)
		new_reserved := vector.reserved * 2r
		if new_reserved < 16r
			/* start at a level that we avoid a lot of extra calls to malloc */
			new_reserved = 16r

		new_items := posix.calloc(sizeof(*runtime.var_t), new_reserved) as **runtime.var_t
		posix.memcpy(new_items as *__int8__, vector.items as *__int8__, sizeof(*runtime.var_t) * vector.size)
		new_items[vector.size] = item
		vector.size += 1r

		posix.free(vector.items)
		vector.items = new_items
		vector.reserved = new_reserved
	else
		# print("we need to go from zero space to newly allocated space")
		assert(vector.reserved == 0r)
		vector.items = posix.calloc(sizeof(*runtime.var_t), 4r) as **runtime.var_t
		vector.reserved = 4r
		vector.size = 1r
		vector.items[0r] = item

[module std]
def reserve(vec [any T], n int)
	# Call the unmanaged version
	reserve(vec as *vector_t, n.raw)

def reserve(vec *vector_t, n __int__)
	# Make sure we've got n spaces available in our vector's allocated memory
	if vec.reserved < n
		if vec.items
			new_items := posix.calloc(sizeof(*runtime.var_t), n) as **runtime.var_t
			posix.memcpy(new_items as *__int8__, vec.items as *__int8__, sizeof(*runtime.var_t) * vec.size)
			posix.free(vec.items)
			vec.items = new_items
			vec.reserved = n
		else
			vec.items = posix.calloc(sizeof(*runtime.var_t), n) as **runtime.var_t
			vec.reserved = n
		

[module std]
def copy(orig [any T]) [any T]
	var new [any T]
	reserve(new, len(orig))
	i := 0
	while i != len(orig)
		append(new, orig[i])
		i += 1
	return new

[module std]
def copy(orig [any T], t any T) [any T]
	var new [any T]
	reserve(new, len(orig) + 1)
	i := 0
	while i != len(orig)
		append(new, orig[i])
		i += 1
	append(new, t)
	return new
