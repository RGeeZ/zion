module vector
link module posix
link module runtime

type vector_t struct
	var reserved __int__
	var size     __int__
	var items    **runtime.var_t

type vector{T} link vector_t __vector_free__ __vector_mark__

[module std]
def __init__() vector{any T}
	typeinfo := typeinfo(vector{any T})
	v := runtime.create_var(typeinfo)
	vec := v as vector{any T}
	return vec
		
def __finalize__(v vector{any T})
	__vectorfree__(v as *runtime.var_t)

[module std]
def __getitem__(vec [any T], index int) any T
	return __getvectoritem__(vec as *runtime.var_t, index.raw) as any T

[module std]
def __getitem__(vec [any T], index __int__) any T
	return __getvectoritem__(vec as *runtime.var_t, index) as any T

[module std]
def __setitem__(vec [any T], index int, t any T) void
	return __setvectoritem__(vec as *runtime.var_t, index.raw, t as *runtime.var_t)

def append(vec [any T], t any T) void
	__vectorappend__(vec as *vector_t, t as *runtime.var_t)

def resize(vec [any T], size int, default any T) void
	return __vectorresize__(vec as *runtime.var_t, size.raw, default) as! [any T]

# link def vec(TYPE, capacity int) TYPE[]

[module std]
def __vector_mark__(var_ *runtime.var_t)
	v := var_ as *vector_t
	i := 0r
	while i < v.size
		runtime.mark_allocation(v.items[i])
		i += 1r

[module std]
def __vector_free__(var_ *runtime.var_t)
	# assert(var_ != 0)
	vector := var_ as *vector_t

	/* the gc will handle cleaning up everything that we pointed to, but we need to free up our
	 * extra allocated heap space. */
	posix.free(vector.items as __bytes)

	/* zion will handle deleting the actual vector_t, since it will be attached to the managed
	 * object */


def __getvectoritem__(vector *vector_t, index __int__) *runtime.var_t
	if index >= 0r
		if index < vector.size
			return vector.items[index]

	print("zion: array index out of bounds (" + int(vector as __int__) + index + ")")
	posix.exit(-1)
	return 0r

def __setvectoritem__(vector *vector_t, index __int__, item *runtime.var_t)
	if index < 0r
		return

	if index < vector.size
		vector.items[index] = item
	else
		print("zion: array index out of bounds (" + (vector as __int__) + str(index) + ")")
		posix.exit(-1)

def __vectorappend__(vector *vector_t, item *runtime.var_t)
	if vector.reserved > vector.size
		vector.items[vector.size] = item
		vector.size += 1r
	elif vector.items != nil
		# assert(vector->reserved == vector->size)
		new_reserved := vector.reserved * 2r
		if new_reserved < 16r
			/* start at a level that we avoid a lot of extra calls to malloc */
			new_reserved = 16r

		new_items := posix.calloc(sizeof(*runtime.var_t), new_reserved) as **runtime.var_t
		posix.memcpy(new_items as __bytes, vector.items as __bytes, sizeof(*runtime.var_t) * vector.size)
		new_items[vector.size] = item
		vector.size += 1r

		posix.free(vector.items as __bytes)
		vector.items = new_items
