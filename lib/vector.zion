module vector
get posix
get runtime

type ManagedVector struct
	var _var     var_t
	var reserved size_t
	var size     size_t
	var items    *?*var_t

type NativeVector T struct
	var _var     var_t
	var reserved size_t
	var size     size_t
	var items    *?T

type Vector T link

[global]
def reserved(v [any]) int
	# NB: native and managed vectors share memory layout up to the `items`
	return (v as *ManagedVector).reserved

[global]
def len(v [any]) int
	# NB: native and managed vectors share memory layout up to the `items`
	return (v as *ManagedVector).size

[global]
def __init__{T where gc T}() [T]
	let ti = typeinfo(
		[T],
		ManagedVector,
		__managed_vector_free__,
		__managed_vector_mark__)

	return runtime.create_var(ti) as [T]
		
[global]
def __init__{T where not gc T}() [T]
	let ti = typeinfo(
		[T],
		native_vector T,
		__native_vector_free__,
		__native_vector_mark__)

	return runtime.create_var(ti) as [T]
		
[global]
def str(v [any]) str
	return "[" + join(v, ", ") + "]"

[global]
def join(v [any T], delim str) str
	let vec = v as *vector_t

	# allocate a vector in which we can store the converted strings
	let strs [str]
	reserve(strs as *vector_t, vec.size)

	let delim_len = posix.wcslen(delim.raw)
	let delims_len = delim_len * (vec.size - 1)
	total_len := delims_len
	i := 0
	while i < vec.size
		let s = str(vec.items[i] as any T)
		append(strs, s)
		total_len += len(s)
		i += 1

	# allocate our resultant string
	let buf *wchar = posix.malloc(sizeof(wchar) * (total_len + 1))! as *wchar

	# iterate over the elements and append them to our resultant string
	pos := 0
	i = 0
	while i < vec.size
		if i > 0
			# insert a delim if necessary
			posix.memcpy(&buf[pos], delim.raw, sizeof(wchar) * delim_len)
			pos += delim_len

		# insert a string
		let s_len = posix.wcslen(strs[i].raw)
		posix.memcpy(&buf[pos], strs[i].raw, sizeof(wchar) * s_len)

		pos += s_len
		i += 1

	buf[pos] = 0 as wchar
	return str(buf)

[global]
def __getitem__{T where gc T}(vec [T], index int) T
	return __get_managed_vector_item__((vec as *ManagedVector), index) as T

[global]
def __getitem__{T where not(gc T)}(vec [T], index int) T
	return __get_native_vector_item__(vec as *NativeVector T, index) as T

[global]
def __setitem__{T where gc T}(vec [T], index int, t T) void
	__set_vector_item__(vec as *ManagedVector, index, t as *var_t)

[global]
def __setitem__{T where not(gc T)}(vec [T], index int, t T) void
	__set_vector_item__(vec as *NativeVector T, index, t)

[global]
def append{T where gc T}(vec [T], t T) void
	# posix.puts("appending " + __str__(t) + " to vector")
	__vectorappend__(vec as *ManagedVector, t as *var_t)

[global]
def append{T where not(gc T)}(vec [T], t T) void
	# posix.puts("appending " + __str__(t) + " to vector")
	__vectorappend__(vec as *NativeVector T, t)

[global]
def resize{T where gc T}(vec [T], size int, default T) void
	resize(vec as *ManagedVector, size, default as *var_t)

def resize(vec *ManagedVector, size int, default *var_t) void
	if size < 0
		return

	if vec.size == size
		return
	elif vec.size < size
		# grow the vector
		reserve(vec, size)
		while vec.size < size
			__vector_unsafe_append__(vec, default)
	else
		# just shorten the vector in place
		vec.size = size


[global]
def __vector_mark__(vec *var_t)
	# posix.puts("marking vector at 0x" + __str__(vec as int, 16))
	let v = vec as *vector_t
	i := 0
	while i < v.size
		runtime.mark_allocation(v.items[i])
		i += 1

[global]
def __vector_free__(var *var_t)
	let vector = var as *vector_t

	/* the gc will handle cleaning up everything that we pointed to, but we need to free up our
	 * extra allocated heap space. */
	posix.free(vector.items)

	/* zion will handle deleting the actual vector_t, since it will be attached to the managed
	 * object */


def __get_managed_vector_item__(vector *ManagedVector, index int) *var_t
	assert(index >= 0 and index < vector.size)
	return vector.items[index]


def __get_native_vector_item__[T](vector *NativeVector{T}, index int) T
	assert(index >= 0 and index < vector.size)
	return vector.items[index]


def __set_vector_item__(vector *ManagedVector, index uint, item *var_t)
	if index < 0
		return

	assert(index < vector.size)
	vector.items[index] = item


def __set_vector_item__{T}(vector *NativeVector{T}, index uint, item T)
	if index < 0
		return

	assert(index < vector.size)
	vector.items[index] = item


def __vector_unsafe_append__(vector *vector_t, item *var_t) void
	# To be called by compiler for vector literals
	assert(vector.reserved > vector.size)
	vector.items[vector.size] = item
	vector.size += 1

# This is mildly unsafe against future changes...
def __vectorappend__{V, I}(vector *V, item I) void
	if vector.reserved > vector.size
		# we have space
		let items = vector.items
		assert(items != null)
		items[vector.size] = item
		vector.size += 1
	else
		let existing_items = vector.items
		if existing_items != null
			# we need to re-allocate space because vector.reserved <= vector.size
			assert(vector.reserved == vector.size)
			new_reserved := vector.reserved * 2
			if new_reserved < 16
				/* start at a level that we avoid a lot of extra calls to malloc */
				new_reserved = 16

			new_items := posix.calloc(sizeof(I), new_reserved) as *?I
			assert(new_items != null)
			posix.memcpy(new_items as *int8, existing_items as *int8, sizeof(I) * vector.size)
			new_items[vector.size] = item
			vector.size += 1

			posix.free(vector.items)
			vector.items = new_items
			vector.reserved = new_reserved
		else
			# we need to go from zero space to newly allocated space
			assert(vector.reserved == 0)
			vector.items = posix.calloc(sizeof(I), 4)! as *I
			vector.reserved = 4
			vector.size = 1
			vector.items[0] = item

[global]
def reserve(vec [any T], n int)
	# Call the unmanaged version
	assert(n >= 0)
	reserve(vec as *vector_t, n)

def reserve(vec *vector_t, n size_t)
	# Make sure we've got n spaces available in our vector's allocated memory
	if vec.reserved < n
		let items = vec.items
		if items != null
			new_items := posix.calloc(sizeof(*var_t), n)! as **var_t
			posix.memcpy(new_items as *int8, items as *int8, sizeof(*var_t) * vec.size)
			posix.free(items)
			vec.items = new_items
			vec.reserved = n
		else
			vec.items = posix.calloc(sizeof(*var_t), n)! as **var_t
			vec.reserved = n
		

[global]
def copy(orig [any T]) [any T]
	var new [any T]
	reserve(new, len(orig))
	i := 0
	while i != len(orig)
		append(new, orig[i])
		i += 1
	return new

[global]
def copy(orig [any T], t any T) [any T]
	var new [any T]
	reserve(new, len(orig) + 1)
	i := 0
	while i != len(orig)
		append(new, orig[i])
		i += 1
	append(new, t)
	return new

[global]
def splice(vec [any T], index int, count int) void
	let v = vec as *vector_t
	let orig_count = v.size
	let i = index.raw
	let c = count.raw
	let skip_to = i + c
	if c < 0 or skip_to < 0 or skip_to > orig_count
		panic("invalid index (" + index + ") and count (" + count + ") passed to vector.splice\n")

	posix.memmove(&v.items[i], &v.items[skip_to], (orig_count - skip_to) * sizeof(*var_t))
	v.size = orig_count - c

type vector_iter{C} has
	var vec [C]
	var pos int

[global]
def __iter_begin__(c [any C]) vector_iter{any C}
	return vector_iter(c, 0)
	
[global]
def __iter_end__(c [any C]) vector_iter{any C}
	return vector_iter(c, (c as *vector.vector_t).size)

[global]
def __iter_valid__(i vector_iter{any C}, end vector_iter{any C}) bool
	assert(i.vec as *vector_t == end.vec as *vector_t)
	return i.pos < end.pos

[global]
def __iterate__(i vector_iter{any C})
	i.pos += 1

[global]
def __iter_item__(i vector_iter{any C}) any C
	v := i.vec as *vector_t
	assert(i.pos < v.size)
	return v.items[i.pos] as any C

