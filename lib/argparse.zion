module argparse

get resource {MaybeResource, Failed, Acquired}

type Arity is {
    # None means no positional parameters are allowed
    None
    # Some means that some range of positional parameters are allowed. Use 0 to indicate no
    # constraint on either the min or max.
    Some(min uint, max uint)
}

type Parser has {
    description   str
    options       [str: Option]
    positionals   Arity
}

type Option has {
    name     str
    has_arg  bool
    required bool
}

type ParseError has {
    reason      str
    usage fn () str
}

type Arguments has {
    options     [str: str]
    positionals [str]
}

fn parse(parser Parser, args [str]) MaybeResource Arguments ParseError {
    var iarg = 0
    let results [str: str]
    let arguments = Arguments(results, [] as [str])

    while iarg < len(args) {
        arg := args[iarg]
        match parser.options[arg] {
            Just(option) {
                if option.has_arg {
                    if iarg + 1 >= len(args) {
                        return Failed(ParseError("Option " + arg + " expects an arg but none was provided", make_usage(parser)))
                    } else {
                        arguments.options[option.name] = args[iarg + 1]
                        iarg += 2
                        continue
                    }
                } else {
                    print("found argument " + arg)
                    arguments.options[arg] = "1"
                }
            }
            Nothing {
                match parser.positionals {
                    None {
                        return Failed(ParseError("Unexpected parameter " + arg + " encountered", make_usage(parser)))
                    }
                    Some(_, max) {
                        if max != 0 and len(arguments.positionals) == max {
                            return Failed(ParseError("Too many positional arguments given: " + arg, make_usage(parser)))
                        } else {
                            append(arguments.positionals, arg)
                        }
                    }
                }
            }
        }

        iarg += 1
    }

    for pair in parser.options {
        option := pair[1]
        if option.required and option.name not in results {
            return Failed(ParseError("Missing option " + option.name + " in command line parameters", make_usage(parser)))
        }
    }

    min := match parser.positionals {
        None => 0
        Some(min, _) => min
    }

    if min != 0 and len(arguments.positionals) < min {
        return Failed(ParseError("Not enough positional parameters", make_usage(parser)))
    }

    return Acquired(arguments, fn () {})
}

fn make_usage(parser Parser) fn () str {
    return fn () => "TODO: impl make_usage in " + __filename__
}
