global

#
# utf8
#
# the utf8 type represents utf8 strings.
#

link def __str__(x int) *char to __str_int
link def __str__(x int, y int) *char to __str_int_radix
link def __str__(x float) *char to __str_float
link def __str__(x *char) *char to __str_str
link def concat(x *char, y *char) *char to __mbs_concat

type utf8 has
	let buffer OwningBuffer char
	let start uint
	let length uint

var _empty_owning_utf8_buffer OwningBuffer char = OwningBuffer(posix.strdup("")!, 0)
var _empty_utf8 utf8 = utf8(_empty_owning_utf8_buffer, 0, 0)

def __init__() utf8
	return _empty_utf8

def unsafe_access(u utf8) *char
	return &u.buffer.raw[u.start]

def utf8(buffer OwningBuffer char) utf8
	return utf8(buffer, 0, buffer.length)

def utf8(s utf8) utf8
 	return s

def utf8(s str) utf8
	return utf8(wcstombs(&s.buffer.raw[s.start], s.length))

def utf8(x int) utf8
	return utf8(__str__(x))

def utf8(x float) utf8
	return utf8(__str__(x))

def len(u utf8) uint
	return u.length

def utf8(b *int8, length size_t, encoding str) utf8
	assert(encoding == "utf8")
	dest_len := length + 1
	dest := posix.calloc(1, dest_len)!
	posix.memcpy(dest, b, length)
	return utf8(dest as *char)

def c_str(u utf8) OwningBuffer char
	# ensures a null-terminated string 
	if u.start != 0 or u.length != u.buffer.length
		let pch = posix.malloc(sizeof(char) * (u.length + 1))! as *char
		posix.memcpy(pch, unsafe_access(u), sizeof(char) * u.length)
		pch[u.length] = 0 as char
		return OwningBuffer(pch, u.length)
	else
		return u.buffer

