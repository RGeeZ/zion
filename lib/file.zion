module file

get posix

type Open has
	var fp *?posix.FILE
tag Closed
type Error has
	let errno int

type File has
	let filename str
	var state Open or Closed or Error

tag EOF

[global]
def open(name str, mode str) File
	fp := posix.fopen(utf8(name).raw, utf8(mode).raw)
	if fp != null
		return File(name, Open(fp))
	else
		return File(name, Error(int(posix.errno())))

[global]
def close(f File)
	state := f.state
	when state
		is Open
			let fp = state.fp
			if fp != null
				posix.fclose(fp)
			state.fp = null
			f.state = Closed
		is Closed
			print("Error: attempt to close a file that is already closed.")
		is Error
			print("Error: attempt to close a file " + f.filename + " that has already seen error " + state.errno)

[global]
def __finalize__(of Open)
	let fp = of.fp
	if fp != null
		ret := posix.fclose(fp)
		if ret != 0r
			print("Error: failed to close file")
		of.fp = null

type Lines{LineReader} has
	var file LineReader
	var cur_line str?

[global]
def readlines() Lines{*posix.FILE}
	return readlines(stdin)

def readlines(f any LineReader) Lines{any LineReader}
	assert(f != null)
	return Lines(f, null)

[global]
def __iter_begin__(fl Lines{any LineReader}) Lines{any LineReader}
	assert(fl != null)
	__iterate__(fl)
	return fl

[global]
def __iter_end__(fl Lines{any LineReader}) null
	assert(fl != null)
	return null

[global]
def __iter_valid__(fl Lines{any LineReader}, _ null) bool
	assert(fl != null)
	return fl.cur_line != null

[global]
def __iter_item__(fl Lines{any LineReader}) str
	assert(fl != null)
	let cur_line = fl.cur_line
	r := cur_line != null ? cur_line : ""
	return r

[global]
def __iterate__(fl Lines{any LineReader})
	s := readline(fl.file)
	when s
		is str
			fl.cur_line = s
		is Error
			print("Error: encountered error " + s.errno + " while reading file")
			fl.cur_line = null
		is EOF
			fl.cur_line = null

def readline(fp *posix.FILE) str or EOF or Error
	if fp == null
		print("encountered null FILE pointer")
		return Error(-1)

	linecap := 0r
	line := null as *char_t
	linelen := posix.getline(&line, &linecap, fp)
	if linelen == -1r
		return EOF

	# make sure we strip the LF char
	if linelen > 0r
		if line[linelen - 1r] as int_t == 10r
			line[linelen - 1r] = 0r as char_t
	str_line := str(mbstowcs(line))
	posix.free(line)
	return str_line

def readline(f File) str or Error or EOF
	state := f.state
	when state
		is Open
			let fp = state.fp
			assert(fp != null)
			return readline(fp)
		is Closed
			return Error(-1)
		is Error
			return state

[global]
def write(fp *posix.FILE, s str)
	utf8_val := utf8(s)
	posix.fwrite(utf8_val.raw, posix.strlen(utf8_val.raw), 1r, fp)
	
[global]
def write(f File, s str)
	state := f.state
	when state
		is Open
			let fp = state.fp
			assert(fp != null)
			write(fp, s)
		is Closed
			posix.fprintf(stderr, "writing to closed file %s", utf8(f.filename).raw)
			return
		is Error
			posix.fprintf(stderr, "writing to errored file %s", utf8(f.filename).raw)
			return
