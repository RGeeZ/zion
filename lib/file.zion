module file

get posix
get readline
get filesize

type State is
	Closed
	Error(errno int)
	Open(fp *posix.FILE)

type File has
	filename str
	var state State

type EOF is EOF

[global]
def open(name str, mode str) File
	fp := posix.fopen(c_str(name).raw, c_str(mode).raw)
	if fp != null
		return File(name, Open(fp))
	else
		return File(name, Error(posix.errno()))

[global]
def close(f File)
	state := f.state
	when state is
		Open(fp)
			posix.fclose(fp)
			f.state = Closed
		Closed
			print("Error: attempt to close a file that is already closed.")
		Error(errno)
			print("Error: attempt to close a file " + f.filename + " that has already seen error " + errno)

[global]
def __finalize__(of File)
	when of.state is
		Open(fp)
			posix.fclose(fp)

[global]
def readbytes(f File) bytes?
	let state = f.state
	when state is
		Open(fp)
			return readbytes(fp)
		else
			return Empty

def readbytes(fp *?posix.FILE) bytes?
	if fp == null
		return Empty

	let size = size(fp)
	when size is
		Size(cb)
			let pb = posix.malloc(cb) as! *?int8
			assert(pb != null)

			let bytes_read = posix.fread(
				pb,
				1,
				cb,
				fp)

			if posix.ferror(fp)
				return Empty
			return Just(bytes(pb, bytes_read))
		else
			return Empty

[global]
def write(fp *posix.FILE, s str)
	posix.fwrite(unsafe_access(s), s.length, 1, fp)
	
[global]
def write(f File, s str)
	when f.state is
		Open(fp)
			write(fp, s)
		Closed
			posix.fprintf(stderr, "writing to closed file %s", f.filename)
		Error(_)
			posix.fprintf(stderr, "writing to errored file %s", f.filename)
