module file

get posix

type Open has
	var fp *posix.FILE
tag Closed
type Error has
	var errno int

type File has
	var filename str
	var state Open or Closed or Error

tag EOF

def open(name str, mode str) File
	fp := posix.fopen(utf8(name).raw, utf8(mode).raw)
	if fp != null
		return File(name, Open(fp))
	else
		return File(name, Error(int(posix.errno())))

def close(f File)
	state := f.state
	when state
		is Open
			ret := posix.fclose(state.fp)
			state.fp = null
			f.state = Closed
		is Closed
			print("Error: attempt to close a file that is already closed.")
		is Error
			print("Error: attempt to close a file " + f.filename + " that has already seen error " + state.errno)

[global]
def __finalize__(of Open)
	print("closing file")
	if of.fp
		ret := posix.fclose(of.fp)
		if ret != 0r
			print("Error: failed to close file")
		of.fp = null

type FileLines has
	var file File
	var cur_line str?

def readlines(f File) FileLines
	return FileLines(f, null)

[global]
def __iter_begin__(fl FileLines) FileLines
	__iterate__(fl)
	return fl

[global]
def __iter_end__(fl FileLines) null
	return null

[global]
def __iter_valid__(fl FileLines, _ null) bool_t
	return fl.cur_line != null

[global]
def __iter_item__(fl FileLines) str
	return fl.cur_line or ""

[global]
def __iterate__(fl FileLines)
	s := readline(fl.file)
	when s
		is str
			fl.cur_line = s
			return
		is Error
			print("Error: encountered error " + s.errno + " while reading " + fl.file.filename)
			fl.cur_line = null
		is EOF
			fl.cur_line = null

def readline(f File) str or Error or EOF
	state := f.state
	when state
		is Open
			linecap := 0r
			line := null as *char_t
			linelen := posix.getline(&line, &linecap, state.fp)
			if linelen == -1r
				return EOF

			# make sure we strip the LF char
			if linelen > 0r
				if line[linelen - 1r] as int_t == 10r
					line[linelen - 1r] = 0r as char_t
			str_line := str(mbstowcs(line))
			posix.free(line)
			return str_line

		is Closed
			return Error(-1)
		is Error
			return state
	assert(false and "strange state for file!")
	return Error(-1)

def write(f File, s str)
	state := f.state
	when state
		is Open
			utf8_val := utf8(s)
			posix.fwrite(utf8_val.raw, posix.strlen(utf8_val.raw), 1r, state.fp)

		is Closed
			posix.fprintf(stderr, "writing to closed file %s"r, utf8(f.filename).raw)
			return
		is Error
			posix.fprintf(stderr, "writing to errored file %s"r, utf8(f.filename).raw)
			return
