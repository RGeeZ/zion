module map
link module posix

type Map{K, V} has
	var left Map{K, V}?
	var key K
	var value V
	var right Map{K, V}?

def upsert(map Map{any K, any V}?, key any K, value any V) Map{any K, any V}
	if map
		if key > map.key
			inserted_right := upsert(map.right, key, value)
			if inserted_right is map.right
				# this key already exists, just return the existing map
				return map
			else
				return Map(map.left, map.key, map.value, inserted_right)

		elif map.key > key
			inserted_left := upsert(map.left, key, value)
			if inserted_left is map.left
				# this key already exists, just return the existing map
				return map
			else
				return Map(inserted_left, map.key, map.value, map.right)

		else
			# this key already exists, just return the existing map
			if value is value
				if key is key
					# we have this exact 
					return map
			return Map(map.left, key, value, map.right)

	else
		return Map(nil, key, value, nil)

[module any]
def str(map Map{any K, any V}) str
	return "{" + _str(map) + "}"

def _str(map Map{any K, any V}) str
	s := ""
	sep := ""
	comma := ", "
	if map
		if left := map.left
			s += _str(left)
			sep = comma
		s += sep
		s += str(map.key)
		s += ": "
		s += str(map.value)
		sep = comma
		if right := map.right
			s += sep
			s += _str(right)
	return s

type MapIter{K, V} has
	var stack [Map{K,V}]
	var status MapNextMove

tag InOrder
tag Stop

type MapNextMove is InOrder or Stop

def iter(map Map{any K, any V}?) MapIter{any K, any V}
	if map
		if map.left
			# Place the root node on the stack
			var stack [Map{any K, any V}]

			while true
				if left := map.left
					stack = list(map, stack)
					map = left
				else
					stack = list(map, stack)
					break
			return MapIter(stack, InOrder)

		else
			return MapIter(list(map, nil), InOrder)

	else
		return MapIter(nil as [Map{any K, any V}], Stop)

type MapStep{K, V} has
	var key K
	var value V
	var next_iter MapIter{any K, any V}

def next(map_iter MapIter{any K, any V}) MapStep{any K, any V}?
	# store the map node that this call will return
	status := map_iter.status
	if status is Stop
		return nil as MapStep{any K, any V}?
	elif status is InOrder
		if stack := map_iter.stack
			if map_node := stack.value
				# traverse down to the right
				if map := map_node.right
					stack = list(map, stack)
					while true
						if left := map.left
							stack = list(left, stack)
							map = left
						else
							break
					return MapStep(map_node.key, map_node.value, MapIter(stack, InOrder))
				else
					sav_node := map_node
					while true
						if next := stack.next
							stack = next
							if parent := stack.value
								if parent.right is map_node
									# we have already visited this node
									map_node = parent
									continue
								else
									return MapStep(sav_node.key, sav_node.value,
											MapIter(stack, InOrder))
						return MapStep(sav_node.key, sav_node.value, MapIter(nil, Stop))

					assert(false)
			else
				assert(false)

		else
			assert(false)

	assert(false)
	return nil

[module any]
def str(status MapNextMove) str
	if status is Stop
		return "Stop"
	elif status is InOrder
		return "InOrder"
	else
		print("wat is this MapNextMove?")
		posix.exit((-1).raw)
		return "Fail"

[module any]
def str(map_iter MapIter{any K, any V}) str
	return "MapIter(" + str(map_iter.stack) + ", " + str(map_iter.status) + ")"

[module any]
def str(map_step MapStep{any K, any V}?) str
	if map_step
		return "MapStep(" + str(map_step.key) + ", " + str(map_step.value) + ", " + str(map_step.next_iter) + ")"
	else
		return "nil"
