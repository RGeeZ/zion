module map
link module posix
link module iter
link module sys

type Map{K, V} has
	var left Map{K, V}?
	var key K
	var value V
	var right Map{K, V}?

def upsert(map Map{any K, any V}?, key any K, value any V) Map{any K, any V}
	if map
		if key > map.key
			inserted_right := upsert(map.right, key, value)
			if inserted_right is map.right
				# this key already exists, just return the existing map
				return map
			else
				return Map(map.left, map.key, map.value, inserted_right)

		elif map.key > key
			inserted_left := upsert(map.left, key, value)
			if inserted_left is map.left
				# this key already exists, just return the existing map
				return map
			else
				return Map(inserted_left, map.key, map.value, map.right)

		else
			# this key already exists, just return the existing map
			if value is value
				if key is key
					# we have this exact 
					return map
			return Map(map.left, key, value, map.right)

	else
		return Map(nil, key, value, nil)

[module std]
def str(map Map{any K, any V}) str
	return "{" + _str(map) + "}"

def _str(map Map{any K, any V}) str
	s := ""
	sep := ""
	comma := ", "
	if map
		if left := map.left
			s += _str(left)
			sep = comma
		s += sep
		s += str(map.key)
		s += ": "
		s += str(map.value)
		sep = comma
		if right := map.right
			s += sep
			s += _str(right)
	return s

type Iter{K, V} has
	var stack [Map{K,V}]
	var status MapNextMove

tag InOrder
tag Stop

type MapNextMove is InOrder or Stop

type KeyValue{K, V} has
	var key K
	var value V

[module std]
def iter(map Map{any K, any V}?) Iter{any K, any V}
	if map
		if map.left
			# Place the root node on the stack
			var stack [Map{any K, any V}]

			while true
				if left := map.left
					stack = list(map, stack)
					map = left
				else
					stack = list(map, stack)
					break
			return Iter(stack, InOrder)

		else
			return Iter(list(map, nil), InOrder)

	else
		return Iter(nil as [Map{any K, any V}], Stop)

[module std]
def next(map_iter Iter{any K, any V}) iter.Step{KeyValue{any K, any V}, Iter{any K, any V}}?
	# store the map node that this call will return
	status := map_iter.status
	if status is Stop
		return nil as iter.Step{KeyValue{any K, any V}, Iter{any K, any V}}?
	elif status is InOrder
		if stack := map_iter.stack
			if map_node := stack.value
				# traverse down to the right
				if map := map_node.right
					stack = list(map, stack)
					while true
						if left := map.left
							stack = list(left, stack)
							map = left
						else
							break
					return iter.Step(
							KeyValue(map_node.key, map_node.value),
							Iter(stack, InOrder))
				else
					sav_node := map_node
					while true
						if next := stack.next
							stack = next
							if parent := stack.value
								if parent.right is map_node
									# we have already visited this node
									map_node = parent
									continue
								else
									return iter.Step(
											KeyValue(
												sav_node.key,
												sav_node.value),
											Iter(stack, InOrder))
						return iter.Step(KeyValue(sav_node.key, sav_node.value), Iter(nil, Stop))

					assert(false)
			else
				assert(false)

		else
			assert(false)

	assert(false)
	return nil as iter.Step{KeyValue{any K, any V}, Iter{any K, any V}}?

[module std]
def str(status MapNextMove) str
	if status is Stop
		return "Stop"
	elif status is InOrder
		return "InOrder"
	else
		print("wat is this MapNextMove?")
		sys.exit(-1)
		return "Fail"

[module std]
def str(map_iter Iter{any K, any V}) str
	return "map/Iter(" + str(map_iter.stack) + ", " + str(map_iter.status) + ")"

[module std]
def str(map_step MapStep{any K, any V}?) str
	if map_step
		return "MapStep(" + str(map_step.key) + ", " + str(map_step.value) + ", " + str(map_step.next_state) + ")"
	else
		return "nil"
