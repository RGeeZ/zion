# Implement a map type (like a dict in Python) in Zion

import list {List, Cons, Nil, remove_if}
import hash {hash}
export {Map, get}

newtype MapKeyValueCell key value = MapKeyValueCell(Int, key, var value)
newtype MapStorage key value = MapStorage([List (MapKeyValueCell key value)])
newtype Map key value = Map(MapStorage key value, var Int)

instance Show (MapKeyValueCell key value) {
    fn str(key_value_cell) String {
        let MapKeyValueCell(hash_value, key, var value) = key_value_cell
        static_print(key)
        return "MapKeyValueCell(${hash_value}, ${key}, ${value})"
    }
}

instance HasDefault (Map key value) {
    fn new() => Map(MapStorage([]), Ref(0))
}

instance HasLength (Map key value) {
    fn len(map) Int {
        let Map(_, var size) = map
        return size
    }
}

instance HasIndexableItems (Map key value) key (Maybe value) {
    fn get_indexed_item(map, key) {
        let Map(map_storage, var size) = map
        return match find_key_value(map_storage, size, hash(key), key) {
            Just(MapKeyValueCell(_, _, var value)) => Just(value)
            Nothing => Nothing
        }
    }
}

instance HasIndexableItems (MapStorage key value) Int (List (MapKeyValueCell key value)) {
    fn get_indexed_item(map_storage, index) {
        let MapStorage(map_storage) = map_storage
        assert(len(map_storage) > index)
        return map_storage[index]
    }
}

instance HasRemovableItems (Map key value) key {
    fn remove(map, key) {
        let Map(map_storage, var size) = map
        if size == 0 {
            return
        }
        let hash_key = hash(key)
        let index = hash_key % size
        let (new_list, removed_count) = remove_if(map_storage[index], fn (key_value_cell MapKeyValueCell key value) Bool {
            let MapKeyValueCell(existing_key_hash, existing_key, _) = key_value_cell
            return existing_key_hash == hash_key and existing_key == key
        })
        map_storage[index] = new_list
        assert(size >= removed_count)
        size -= removed_count
    }
}

fn get(map Map key value, key key, default value) value => match map[key] {
    Just(a) => a
    Nothing => default
}

fn find_key_value(map_storage MapStorage key value, size Int, map_key_hash Int, key key) Maybe (MapKeyValueCell key value) {
    let MapStorage(storage) = map_storage
    if size <= 0 {
        assert(size == 0)
        return Nothing
    }

    let index = map_key_hash % size
    let storage_foo = storage
    for key_value_cell in storage_foo[index] {
        # TODO: add destructuring to the above line so that this next
        # line is inline.
        let MapKeyValueCell(existing_key_hash, existing_key, var existing_value) = key_value_cell

        if existing_key_hash == map_key_hash and existing_key == key {
            return Just(key_value_cell)
        }
    }
    return Nothing
}

fn needs_to_grow(map) {
    let Map(MapStorage(storage), var size) = map
    return size + 1 > len(storage)
}

fn grow_storage(map_storage MapStorage key value, new_size) {
    let MapStorage(storage) = map_storage
    assert(len(storage) < new_size)
    let new_storage = []
    reserve(new_storage, new_size)
    for i in [0..new_size-1] {
        append(new_storage, Nil)
    }
    assert(len(new_storage) == new_size)
    for key_value_cell_list in storage {
        for key_value_cell in key_value_cell_list {
            let MapKeyValueCell(key_hash, key, var value) = key_value_cell
            let index = key_hash % new_size
            new_storage[index] = Cons(key_value_cell, Ref(new_storage[index]))
        }
    }

    /* replace the existing storage with the newly allocated storage */
    let Vector(var array, var size, var capacity) = storage
    let Vector(var new_array, var new_size, var new_capacity) = new_storage
    array = new_array
    size = new_size
    capacity = new_capacity
}

instance HasAssignableIndexableItems (MapStorage key value) Int (List (MapKeyValueCell key value)) {
    fn set_indexed_item(map_storage, index, bucket) {
        let MapStorage(map_storage) = map_storage
        map_storage[index] = bucket
    }
}

instance HasAssignableIndexableItems (Map key value) key value {
    # NB: instance predicates (aka requirements) are discovered during
    # specialization. So, "has Hashable key" is not necessary (or even
    # parsed correctly.)
    fn set_indexed_item(map Map key value, key, value) {
        # get access to the inside of the map
        let Map(map_storage, var size) = map
        # compute the given key's hash
        let map_key_hash = hash(key)

        # See if this key already exists
        # otherwise, we'll need to deal with growing the storage.
        match find_key_value(map_storage, size, map_key_hash, key) {
            Just(MapKeyValueCell(_, _, var old_value)) {
                # It exists, so just update the value
                old_value = value
                return
            }
        } else {
            if needs_to_grow(map) {
                # We need to grow to efficently hold another element.
                grow_storage(map_storage, size == 0 ? 4 : size * 2)
            }
            let MapStorage(storage) = map_storage
            assert(len(storage) > 0)
            let index = map_key_hash % len(storage)
            let key_value_cell = MapKeyValueCell(map_key_hash, key, Ref(value))
            storage[index] = Cons(key_value_cell, Ref(storage[index]))
            size += 1
        }
    }
}
