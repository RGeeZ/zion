module map

# map is an associative array. it is currently implemented using O(n) searches for all operations.
# this is obviously not good, but it's just a placeholder to work with the language syntax and
# grammar as it evolves.

# FUTURE: we'll get ourselves a shiny fast implementation of an (un)ordered map.

type KeyValue K V has
	let key K
	var value V

# aka {KeyType: ValueType}
type Map KeyType ValueType has
	# HACKHACK: O(n) BAD BAD
	var storage [KeyValue KeyType ValueType]

[global]
def __init__[K, V]() {K: V}
	let storage [KeyValue K V]
	return map(storage)

[global]
def get[K, V](m {K: V}, key K, default V) V
	# HACKHACK: O(n) BAD BAD
	for kv in m.storage
		if kv.key == key
			return kv.value
	return default

[global]
def __getitem__[K, V](m {K: V}, key K) V?
	# HACKHACK: O(n) BAD BAD
	for kv in m.storage
		if kv.key == key
			return kv.value
	return null

[global]
def __setitem__[K, V](m {K: V}, key K, val V)
	# HACKHACK: O(n) BAD BAD
	for kv in m.storage
		if kv.key == key
			kv.value = val
			return
	append(m.storage, KeyValue(key, val))

[global]
def del[K, V](m {K: V}, key K) bool
	# HACKHACK: O(n) BAD BAD - also vector.ManagedVector coupling BAD BAD
	i := 0
	let storage = m.storage
	let size = (storage as *vector.ManagedVector).size
	while i < size
		let item = storage[i]
		if item.key == key
			splice(storage, int(i), 1)
			return true
		i += 1
	return false
