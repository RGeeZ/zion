module mutable_set

# map is an associative array

type HashType = uint32

type ChainEntry K has {
    hash_value HashType
    key K
    var next (ChainEntry K)?
}

type MutableSet K has {
    var count int
    var storage [(ChainEntry K)?]
}

[global]
fn __init__[K]() MutableSet K {
    storage := new [(ChainEntry K)?]
    return MutableSet(0, storage)
}

[global]
fn len[K](m MutableSet K) int {
    return m.count
}

fn realloc[K](m MutableSet K) {
    storage := new [(ChainEntry K)?]
    new_size := (len(m.storage) + 1) * 2
    resize(storage, new_size, Nothing)

    old_storage := m.storage
    m.storage = storage

    ls := len(m.storage)
    for chain in old_storage {
        while match chain {
            Just(entry) {
                next_chain := entry.next

                # Figure out the new index
                index := entry.hash_value % ls

                # Have this entry point to the existing entry in the new allocation
                entry.next = m.storage[index]

                # Insert this entry into the chain
                m.storage[index] = chain

                # Advance to the next item that was in this chain
                chain = next_chain
            }
        } else => break
    }
}

fn insert[K](m MutableSet K, n MutableSet K) {
    g := new MutableSet K
    for q in n {
        insert(g, q)
    }
    for q in m {
        insert(g, q)
    }
    return g
}

fn insert[K](m MutableSet K, key K) {
    hash_value := __map_hash__(key)
    ls := len(m.storage)
    if ls == 0 {
        realloc(m)
    }
    var index = hash_value % len(m.storage)

    var chain = m.storage[index]
    while match chain {
        Just(entry) {
            if entry.hash_value == hash_value and entry.key == key {
                return
            }
            chain = entry.next
        }
    } else => break

    # We didn't find the key in our map
    if m.count + 1 > ls * 3 / 4 {
        realloc(m)
        index = hash_value % len(m.storage)
    }
    entry := ChainEntry(hash_value, key, m.storage[index])
    m.storage[index] = Just(entry)
    m.count += 1
}

[global]
fn __in__[K](key K, m MutableSet K) bool {
    ls := len(m.storage)
    if ls == 0 {
        return false
    }

    let hash_value HashType = __map_hash__(key)
    index := hash_value % ls
    var chain = m.storage[index]
    while match chain {
        Just(entry) {
            if entry.hash_value == hash_value and entry.key == key {
                return true
            }
            chain = entry.next
        }
    } else => break
    return false
}

[global]
fn __not_in__[K](key K, m MutableSet K) bool {
    return not __in__(key, m)
}

fn remove[K](m MutableSet K, key K) bool {
    hash_value := __map_hash__(key)
    ls := len(m.storage)
    if ls == 0 {
        return Nothing
    }
    var index = hash_value % ls

    var chain = m.storage[index]
    var prior = Nothing as (ChainEntry K)?
    while match chain {
        Just(entry) {
            if entry.hash_value == hash_value and entry.key == key {
                match prior {
                    Just(prior_entry) {
                        prior_entry.next = entry.next
                    }
                    Nothing {
                        m.storage[index] = entry.next
                    }
                }
                m.count -= 1
                assert(key not in m)
                return true
            }
            prior = chain
            chain = entry.next
        }
    } else => break

    return false
}

[global]
fn iter[K](m MutableSet K) Iter K {
    items := new [K]
    reserve(items, len(m))

    for index in range(len(m.storage)) {
        var chain = m.storage[index]
        while match chain {
            Just(entry) {
                append(items, entry.key)
                chain = entry.next
            }
            Nothing => break
        }
    }

    # By default we iterate over a copy of the data in the map, stored as
    # tuples of key value pairs
    return iter(items)
}

fn difference[K](a MutableSet K, b MutableSet K) MutableSet K {
    n := new MutableSet K
    for x in a {
        if x not in b {
            insert(n, x)
        }
    }
    return n
}

fn difference[K](a MutableSet K, b Iter K) MutableSet K {
    c := new MutableSet K
    for x in b {
        insert(c, x)
    }
    return difference(a, c)
}

fn union[K](a MutableSet K, b MutableSet K) MutableSet K {
    n := new MutableSet K
    for x in a {
        insert(n, x)
    }
    for x in b {
        insert(n, x)
    }
    return n
}

fn intersect[K](a MutableSet K, b MutableSet K) MutableSet K {
    n := new MutableSet K

    if len(a) < len(b) {
        for x in a {
            if x in b {
                insert(n, x)
            }
        }
    } else {
        for x in b {
            if x in a {
                insert(n, x)
            }
        }
    }

    return n
}

fn __test_compilation() void {
    m := new MutableSet str
    insert(m, "hey")
    print("hey" in m)
}
