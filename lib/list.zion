module list

type List T is {
    Cons(t T, next List T)
    Nil
}

fn nth[T](l List T, index int) T? {
    while index >= 0 {
        match l {
            Cons(t, next) {
                if index == 0 {
                    return Just(t)
                } else {
                    l = next
                    index -= 1
                }
            }
            Nil {
                return Empty
            }
        }
    }
    return Empty
}

[global]
fn len(l List any) int {
    match l {
        Cons(_, next) {
            return len(next) + 1
        }
        Nil {
            return 0
        }
    }
}

[global]
fn str(l List any) str {
    return "[...list...]"
}

[global]
fn bind[A, B](ma [A], f fn (a A) [B]) [B] {
    # (>>=) :: m a -> (a -> m b) -> m b
    let mb [B]
    for a in ma {
        mb_new := f(a)
        for b in mb_new {
            append(mb, b)
        }
    }
    return mb
}
        
[global]
fn fail[A](reason str) [A] {
    return []
}
