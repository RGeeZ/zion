module RedBlackSet

type Color is { 
    R  # red
    B  # black
    BB # double black
    NB # negative black
}

type RBSet V is {
    E  # black leaf
    EE # double black leaf
    T(color Color, l (RBSet V), x V, r (RBSet V))
}
# Private auxiliary functions #

fn redden[V](a RBSet V) RBSet V => match a {
    E => panic("cannot redden empty tree")
    EE => panic("cannot redden empty tree")
    T(_, a, x, b) => T(R, a, x, b)
}

fn blacken[V](a RBSet V) RBSet V => match a {
    E => E
    EE => E
    T(_, a, x, b) => T(B, a, x, b)
}

fn isBB[V](s RBSet V) bool => match s {
    EE => true
    T(BB, _, _, _) => true
    _ => false
}

fn blacker(s Color) Color => match s {
    NB => R
    R => B
    B => BB
    BB => panic("too black")
}

fn redder(s Color) Color => match s {
    NB => panic("not black enough")
    R => NB
    B => R
    BB => B
}

fn blacker[V](a RBSet V) RBSet V => match a {
    E => EE
    T(c, l, x, r) => T(blacker(c), l, x, r)
}

fn redder[V](a RBSet V) RBSet V => match a {
    EE => E
    T(c, l, x, r) => T(redder(c), l, x, r)
}

# `balance` rotates away coloring conflicts:
fn balance[V](color Color, l RBSet V, a V, r RBSet V) RBSet V {
    return match (color, l, a, r) {
        # Okasaki's original cases:
        (B, T(R, T(R, a, x, b), y, c), z, d) => T(R, T(B, a, x, b), y, T(B, c, z, d))
        (B, T(R, a, x, T(R, b, y, c)), z, d) => T(R, T(B, a, x, b), y, T(B, c, z, d))
        (B, a, x, T(R, T(R, b, y, c), z, d)) => T(R, T(B, a, x, b), y, T(B, c, z, d))
        (B, a, x, T(R, b, y, T(R, c, z, d))) => T(R, T(B, a, x, b), y, T(B, c, z, d))

        # Six cases for deletion:
        (BB, T(R, T(R, a, x, b), y, c), z, d) => T(B, T(B, a, x, b), y, T(B, c, z, d))
        (BB, T(R, a, x, T(R, b, y, c)), z, d) => T(B, T(B, a, x, b), y, T(B, c, z, d))
        (BB, a, x, T(R, T(R, b, y, c), z, d)) => T(B, T(B, a, x, b), y, T(B, c, z, d))
        (BB, a, x, T(R, b, y, T(R, c, z, d))) => T(B, T(B, a, x, b), y, T(B, c, z, d))

        (BB, a, x, T(NB, T(B, b, y, c), z, T(B, _, _, _))) => T(B, T(B, a, x, b), y, balance(B, c, z, redden(r)))
        (BB, T(NB, a@T(B, _, _, _), x, T(B, b, y, c)), z, d) => T(B, balance(B, redden(a), x, b), y, T(B, c, z, d))
    } else => T(color, l, a, r)
}

# `bubble` "bubbles" double-blackness upward:
fn bubble[V](color Color, l RBSet V, a V, r RBSet V) RBSet a {
    if isBB(l) or isBB(r) {
        return balance(blacker(color), redder(l), x, redder(r))
    } else {
        return balance(color, l, a, r)
    }
}

 # Public operations #

fn empty[V](a RBSet V) RBSet V => E


fn member[V](a V, coll RBSet V) bool {
    match coll {
        E => return false
        T(_, l, y, r) {
            if x < y {
                return member(x, l)
            } else if x > y {
                return member(x, r)
            } else {
                return true
            }
        }
    }
}

fn max[V](coll RBSet V) V => match coll {
    E => panic("no largest element")
    T(_, _, x, E) => x
    T(_, _, x, r) => max(r)
}


# Insertion:

fn insert[V](x V, s RBSet V) RBSet V {
    fn ins(c RBSet V) RBSet V {
        match c {
            E => return T(R, E, x, E)
            EE => return T(R, E, x, E)
            s@T(color, a, y, b) {
                if x < y {
                    return balance(color, ins(a), y, b)
                } else if x > y {
                    return balance(color, a, y, ins(b))
                } else {
                    return s
                }
            }
        }
    }
    return blacken(ins(s))
}

# Deletion:

fn delete[V](x V, s RBSet V) RBSet a {
    fn del(s RBSet V) RBSet V => match s {
        E => E
        T(color, a, y, b) {
            if x < y {
                return bubble(color, del(a), y, b)
            } else if x > y {
                return bubble(color, a, y, del(b))
            } else {
                return remove(s)
            }
        }
    }
    return blacken(del(s))
}

fn remove[V](coll RBSet V) RBSet V => match coll {
    E => E
    T(R, E, _, E) => E
    T(B, E, _, E) => EE
    T(B, E, _, T(R, a, x, b)) => T(B, a, x, b)
    T(B, T(R, a, x, b), _, E) => T(B, a, x, b)
    T(color, l, y, r) {
        return bubble(color, removeMax(l), max(l), r)
    }
}

fn removeMax[V](s RBSet V) RBSet V => match s {
    E => panic("no maximum to remove")
    T(_, _, _, E) => remove(s)
    T(color, l, x, r) => bubble(color, l, x, removeMax(r))
}

fn test() {
    var s = insert(3, E)
}
