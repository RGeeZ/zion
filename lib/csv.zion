import itertools {zip}
import parser {ParseState, Span, Step, char, any_of, until_one_of, sequence,
               kleene_star, lift}

export {read_csv_dicts, HasHeaderRow, UseFieldNames}

fn split_csv_line(parse fn (ParseState) Maybe (Step [String]), line String) [String] {
  if parse(ParseState(line, 0)) is Just(Step(fields, _)) {
    for s in fields {
      print(s)
    }
    return [strip(str(s)) for s in fields]
  }
  return []
}

data ReadCSVDicts {
  HasHeaderRow
  UseFieldNames([String])
}

data Term {
  QuotedString([Span])
  UnquotedString(Span)
  Comma
}

fn parse_csv_line(ps ParseState) Maybe (Step [String]) {
  let term_parser = any_of([
    lift(QuotedString, sequence([
      char('"'),
      until_one_of(id, "\""),
      char('"'),
      char(','),
    ])),
    until_one_of(UnquotedString, ","),
  ]) as fn (ParseState) Maybe (Step Term)
  let comma = lift(fn(_)=>Comma, char(',')) as fn (ParseState) Maybe (Step Term)

  let parse_terms = sequence([
    kleene_star(
      sequence([
        term_parser,
        comma,
      ])),
    lift(vector, term_parser)
  ]) as fn (ParseState) Maybe (Step [[Term]])
  if parse_terms(ps) is Just(Step(xs, ps_)) {

    for ys in xs {
      static_print(ys)
      for zs in ys {
        static_print(zs)
      }
    }
    let _ = "let ret = [((match z {
      QuotedString(spans) => join(\"\", span for span in spans)
      UnquotedString(span) => str(span)
      Comma => \",\"
    } for z in zs) for zs in ys) for ys in xs]"
    return Just(Step([], ps_))
  } else {
    return Nothing
  }
}

fn read_csv_dicts(stream, read_csv_dicts ReadCSVDicts) fn () Maybe (Map String String) {
  let linereader = iter(readlines(stream))

  var headers = []
  match read_csv_dicts {
    HasHeaderRow {
      if linereader() is Just(line) {
        let g = line as String
        headers = split_csv_line(parse_csv_line, line)
      } else {
        return fn () => Nothing
      }
    }
    UseFieldNames(given_headers) {
      headers = vector(given_headers) as [String]
    }
  }

  return fn () {
    if linereader() is Just(line) {
      return Just({key: value
                   for (key, value) in zip(headers,
                                           split_csv_line(parse_csv_line,
                                                          line))})
    } else {
      return Nothing
    }
  }
}
