import itertools {zip}
import parser {ParseState, Span, Step, char, not_char, any_of, until_one_of, sequence,
               kleene_star, lift, span_concat}

export {read_csv_dicts, HasHeaderRow, UseFieldNames}

fn split_csv_line(parse fn (ParseState) Maybe (Step [String]), line String) [String] {
  if parse(ParseState(line, 0)) is Just(Step(fields, _)) {
    for s in fields {
      print(s)
    }
    return [strip(str(s)) for s in fields]
  }
  return []
}

data ReadCSVDicts {
  HasHeaderRow
  UseFieldNames([String])
}

data Term {
  QuotedString([Span])
  UnquotedString(Span)
  Comma
}

instance Str Term {
  fn str(term) => match term {
    QuotedString(spans) => "QuotedString(${spans})"
    UnquotedString(span) => "UnquotedString(${span})"
    Comma => "Comma"
  }
}

fn parse_csv_line(ps ParseState) Maybe (Step [String]) {
  let term_parser = any_of([
    lift(QuotedString, sequence([
      char('"'),
      until_one_of("\""),
      char('"'),
    ])),
    lift(compose(UnquotedString, strip), until_one_of(","))
  ])

  let comma = lift(fn(_)=>Comma, char(','))
  let parse_terms = lift(flatten, sequence([
    kleene_star(
      sequence([
        term_parser,
        comma,
      ])),
    lift(fn (x) => [[x]], term_parser),
  ]))
  if parse_terms(ps) is Just(Step(xs, ps_)) {
    for ys in xs {
      print("${join(" ", ys)}")
    }
    return Just(Step([], ps_))
  } else {
    return Nothing
  }
}

fn read_csv_dicts(stream, read_csv_dicts ReadCSVDicts) fn () Maybe (Map String String) {
  let linereader = iter(readlines(stream))
  var headers = []
  var have_headers = False

  return fn () {
    if not have_headers {
      have_headers = True
      match read_csv_dicts {
        HasHeaderRow {
          if linereader() is Just(line) {
            headers = split_csv_line(parse_csv_line, line)
          } else {
            return Nothing
          }
        }
        UseFieldNames(given_headers) {
          headers = vector(given_headers) as [String]
        }
      }
    }

    if linereader() is Just(line) {
      return Just({key: value
                   for (key, value) in zip(headers,
                                           split_csv_line(parse_csv_line,
                                                          line))})
    } else {
      return Nothing
    }
  }
}
