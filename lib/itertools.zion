export {count_up_by_from, count_up_from, count_up_by, count, take, repeat,
        chain, chain2, cycle, dropwhile, takewhile}

fn count_up_by_from(inc Int, x Int) {
    return [x, inc..]
}

fn count_up_from(x Int) {
    return [x..]
}

fn count_up_by(inc Int) {
    return [0..]
}

fn repeat(x) fn () Maybe a {
    let jx = Just(x)
    return fn () => jx
}

fn take(n, iterable) {
    let iterator = iter(iterable)
    var i = n
    return fn() {
        if i <= 0 {
            return Nothing
        }
        let val = iterator()
        match val {
            Just(x) {
                i = i - 1
                return val
            }
            Nothing {
                return Nothing
            }
        }
    }
}

fn takewhile(predicate, iterable) {
    let iterator = iter(iterable)
    return fn() {
        let val = iterator()
        match val {
            Just(x) {
                if predicate(x) {
                    return val
                } else {
                    return Nothing
                }
            }
            Nothing {
                return Nothing
            }
        }
    }
}

fn dropwhile(predicate, iterable) {
    let iterator = iter(iterable)
    var dropping = True
    return fn () {
        while dropping {
            match iterator() {
                val@Just(x) {
                    if predicate(x) {
                        continue
                    } else {
                        dropping = False
                        return val
                    }
                }
                Nothing {
                    return Nothing
                }
            }
        }
        return iterator()
    }
}



fn cycle(xs_input) {
    var xs = Just(iter(xs_input))
    let recording = []
    var index = 0
    return fn () {
        match! xs {
            Just(iterator) {
                match iterator() {
                    step@Just(x) {
                        append(recording, step)
                        return step
                    }
                    Nothing {
                        xs = Nothing
                    }
                }
            }
        }
        let num_recordings = len(recording)
        if index < num_recordings {
            let ret = recording[index]
            index = index + 1
            return ret
        } else if num_recordings == 0 {
            return Nothing
        } else {
            assert(index == num_recordings)
            index = 1
            return recording[0]
        }
    }
}

fn chain2(a, b) {
    var outer_iter = iter([iter(a), iter(b)])
    var cur_iterable = outer_iter()
    return fn () {
        while match cur_iterable {
            Just(iterable_nested) {
                let value = iterable_nested()
                match value {
                    j@Just(_) {
                        return j
                    }
                    Nothing {
                        cur_iterable = outer_iter()
                    }
                }
            }
            Nothing {
                return Nothing
            }
        }
        return Nothing
    }
}
