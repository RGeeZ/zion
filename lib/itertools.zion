module itertools

get mutable_set {MutableSet, insert}

fn fmap[A, B](f fn (a A) B, a Iter A) Iter B {
    return fn () B? {
        return fmap(f, a())
    }
}

fn uniq[A](i Iter A) Iter A {
    seen := new MutableSet A
    return fn () {
        while true {
            match i() {
                Nothing => break
                Just(t) {
                    if t in seen {
                        continue
                    } else {
                        insert(seen, t)
                        return Just(t)
                    }
                }
            }
        }
        return Nothing
    }
}

fn take(n uint, f) {
    let iterator = iter(f)
    i := Ref(0)
    return fn () {
        if i.value >= n {
            return Nothing
        } else {
            i.value += 1
            return iterator()
        }
    }
}

fn count(start int) {
    return count(start, 1)
}

fn count(start int, step int) {
    i := Ref(start - step)
    return fn () {
        i.value += step 
        return Just(i.value)
    }
}

type CycleState T is {
    Building(_ [T?], _ Iter T)
    Cycling(_ [T?], cur Ref int)
}

fn cycle(f) {
    iterator_ := iter(f)
    cycle_state := Ref(Building(new [typeof(iterator_())], iterator_))
    return fn () {
        match! cycle_state.value {
            Building(v, iterator) {
                match! iterator() {
                    jt@Just(t) {
                        append(v, jt)
                        return jt
                    }
                }
                cycle_state.value = Cycling(v, Ref(0))
            }
        }

        match! cycle_state.value {
            Cycling(v, cur) {
                lv := len(v)
                if lv == 0 {
                    return Nothing
                } else {
                    val := v[cur.value]
                    cur.value = (cur.value + 1) % lv
                    return val
                }
            }
        }

        return Nothing
    }
}

fn repeat(x, n uint) {
    i := Ref(0)
    return fn () {
        if i.value >= n {
            return Nothing
        }
        i.value += 1
        return Just(x)
    }
}

fn repeat(x) {
    jx := Just(x)
    return fn () => jx
}

fn chain[T where not (T <: Iter any)](collections [T]) Iter any {
    iterables := new [typeof(iter(collections[0]))]
    for collection in collections {
        append(iterables, iter(collection))
    }
    return chain(iterables)
}

fn chain[T](iterators [Iter T]) Iter T {
    iter_index_ref := Ref(0)
    return fn () {
        while len(iterators) > iter_index_ref.value {
            match iterators[iter_index_ref.value]() {
                jt@Just(t) => return jt
                Nothing    => iter_index_ref.value += 1
            }
        }
        return Nothing
    }
}

fn get_iterables[G, H](iterables [G]) Iter H {
    var vec [typeof(iter(iterables))]
    for i in iterables {
        append(vec, iter(i))
    }
    return iter(vec)
}

fn izip[T](iterators [Iter T]) Iter T {
    return fn () {
        var zipped [T]
        reserve(zipped, len(iterators))
        for i in iterators {
            match i() {
                Just(t) => append(zipped, t)
                Nothing => return Nothing
            }
        }
        return zipped
    }
}

fn izip[A, B](a Iter A, b Iter B) Iter (A, B) {
    return fn () {
        return match a() {
            Just(t) => match b() {
                Just(q) => Just((t, q))
                Nothing => Nothing
            }
            Nothing => Nothing
        }
    }
}

fn izip[A, B, C](a Iter A, b Iter B, c Iter C) Iter (A, B, C) {
    return fn () {
        return match a() {
            Just(t) => match b() {
                Just(q) => match c() {
                    Just(r) => Just((t, q, r))
                    Nothing => Nothing
                }
                Nothing => Nothing
            }
            Nothing => Nothing
        }
    }
}

fn map[T, U](iterator Iter T, f fn (t T) U) Iter U {
    return fn () => match iterator() {
        Just(t) => Just(f(t))
        Nothing => Nothing
    }
}

fn join(delim str, coll) str {
    var result = ""
    var d = ""
    for item in coll {
        result += d
        result += str(item)
    }
    return result
}
