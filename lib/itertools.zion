module itertools


fn take(n uint, f) {
    let iterator = iter(f)
    i := Ref(0)
    return fn () {
        if i.value >= n {
            return Nothing
        } else {
            i.value += 1
            return iterator()
        }
    }
}

fn count(start int) {
    return count(start, 1)
}

fn count(start int, step int) {
    i := Ref(start - step)
    return fn () {
        i.value += step 
        return Just(i.value)
    }
}

fn make_maybe_vector[T](_ Iter T) => [] as [T?]

type CycleState T is {
    Building(_ [T?], _ Iter T)
    Cycling(_ [T?], cur Ref int)
}

fn cycle(f) {
    iterator_ := iter(f)
    cycle_state := Ref(Building(make_maybe_vector(iterator_), iterator_))
    return fn () {
        match! cycle_state.value {
            Building(v, iterator) {
                match! iterator() {
                    jt@Just(t) {
                        append(v, jt)
                        return jt
                    }
                }
                cycle_state.value = Cycling(v, Ref(0))
            }
        }

        match! cycle_state.value {
            Cycling(v, cur) {
                lv := len(v)
                if lv == 0 {
                    return Nothing
                } else {
                    val := v[cur.value]
                    cur.value = (cur.value + 1) % lv
                    return val
                }
            }
        }

        return Nothing
    }
}

fn repeat(x, n uint) {
    i := Ref(0)
    return fn () {
        if i.value >= n {
            return Nothing
        }
        i.value += 1
        return Just(x)
    }
}

fn repeat(x) {
    jx := Just(x)
    return fn () => jx
}

fn chain[T](iterators [Iter T]) Iter T {
    iter_index_ref := Ref(0)
    return fn () {
        while len(iterators) > iter_index_ref.value {
            match iterators[iter_index_ref.value]() {
                jt@Just(t) => return jt
                Nothing    => iter_index_ref.value += 1
            }
        }
        return Nothing
    }
}

fn izip[T](iterators [Iter T]) Iter T {
    return fn () {
        var zipped [T]
        reserve(zipped, len(iterators))
        for i in iterators {
            match i() {
                Just(t) => append(zipped, t)
                Nothing => return Nothing
            }
        }
        return zipped
    }
}

fn izip[A, B](a Iter A, b Iter B) Iter (A, B) {
    return fn () {
        return match a() {
            Just(t) => match b() {
                Just(q) => Just((t, q))
                Nothing => Nothing
            }
            Nothing => Nothing
        }
    }
}

fn izip[A, B, C](a Iter A, b Iter B, c Iter C) Iter (A, B, C) {
    return fn () {
        return match a() {
            Just(t) => match b() {
                Just(q) => match c() {
                    Just(r) => Just((t, q, r))
                    Nothing => Nothing
                }
                Nothing => Nothing
            }
            Nothing => Nothing
        }
    }
}

fn loop_words() Iter str {
    words := ["hey", "you", "are", "programming", "hello"]
    i := Ref(-1)
    return fn () {
        i.value += 1
        return Just(words[i.value % len(words)])
    }
}

