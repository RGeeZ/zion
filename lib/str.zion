global

link in "rt_str.o"

link def __wcs__(x int) *wchar to __wcs_int
link def __wcs__(x int, y int) *wchar to __wcs_int_radix
link def __wcs__(x float) *wchar to __wcs_float
link def __wcs__(x *char) *wchar to __wcs_str

#
# str
#
# the str type represents unicode strings.
#

type str has
	let raw *wchar

def __getitem__(x str, i int) wchar
	return x.raw[i]

var __empty_str str = str(mbstowcs(""))

def __init__() str
	return __empty_str

def __finalize__(s str)
	posix.free(s.raw)

def __box__(s *char) str
	return str(mbstowcs(s))

def len(s str) size_t
	return posix.wcslen(s.raw)

def str(s str) str
	return str(posix.wcsdup(s.raw)!)

def str(s utf8) str
	return str(mbstowcs(s.raw))

def str(x int) str
	return str(__wcs__(x))

def str(x float) str
	return str(__wcs__(x))

def __plus__(x str, y str) str
	return str(concat(x.raw, y.raw))

def __plus__(x str, y int) str
	let y_expanded = __wcs__(y)
	let result = str(concat(x.raw, y_expanded))
	posix.free(y_expanded)
	return result

def __plus__(x str, y float) str
	let sy = __wcs__(y)
	let ret = str(concat(x.raw, sy))
	posix.free(sy)
	return ret

def __eq__(x str, y str) bool
	return posix.wcscmp(x.raw, y.raw) == 0

def __ineq__(x str, y str) bool
	return posix.wcscmp(x.raw, y.raw) != 0

def str(buffer *char, length size_t) str
	# Create a managed string from a direct memory access
	# TODO: optimize this to avoid the malloc
	let retstr = posix.malloc(length + 1 as size_t)! as *char
	posix.memcpy(retstr as *int8, buffer as *int8, length)
	retstr[length] = 0 as char
	let s = str(mbstowcs(retstr))
	posix.free(retstr);
	return s

def str(src *wchar, char_count int) str
	assert(char_count >= 0)
	if char_count <= 0
		return __empty_str
	let cb = sizeof(wchar) * (char_count + 1)
	let dst = posix.malloc(cb)! as *wchar
	posix.memcpy(dst, src, cb - sizeof(wchar))
	dst[char_count] = 0
	return str(dst)

def strip(s str) str
	var start int = 0
	let max int = posix.wcslen(s.raw)
	var lim int = max - 1
	while start <= lim
		if not posix.iswspace(s.raw[start])
			break
		start += 1
	
	while lim > start and posix.iswspace(s.raw[lim])
		lim -= 1
	
	if start == 0 and lim == max - 1
		return s
	
	# TODO: PERF: maybe allow slicing strings
	return str(&s.raw[start], lim - start + 1)

def concat(x *wchar, y *wchar) str
	let x_len = posix.wcslen(x)
	let x_cb = sizeof(wchar) * x_len
	let y_cb = sizeof(wchar) * (posix.wcslen(y) + 1)
	let res = posix.malloc(x_cb + y_cb)! as *wchar
	posix.memcpy(res, x, x_cb)
	posix.memcpy(&res[x_len], y, y_cb)
	return str(res)
