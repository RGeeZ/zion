module readline

get file

type Readline is
	EOF
	Error(errno int)
	Line(line str)

[global]
def readline() Readline
	var buf *?char
	var linecap posix.int = 0

	if posix.getline(&buf, &linecap, stdin) == -1 or buf == null
		return EOF

	var lim = posix.strlen(buf) - 1
	while lim >= 0 and posix.isspace(buf[lim])
		lim -= 1
	length := lim + 1
	buf[length] = 0

	ret := str(OwningBuffer(buf, length), 0, length)
	# runtime.gc()
	return Line(ret)

def readline(fp *posix.FILE) Readline
	var linecap posix.int = 0
	var line *?char = null
	linelen := posix.getline(&line, &linecap, fp)
	if linelen == -1
		return EOF

	assert(line != null)

	# make sure we strip the LF char
	if linelen > 0
		if line[linelen - 1] == 10
			line[linelen - 1] = 0
	return Line(str(OwningBuffer(line)))

[global]
def readline(f file.File) Readline
	match f.state
		Open(fp)
			return readline(fp)
		Closed
			return Error(-1)
		Error(errno)
			return Error(errno)

type Lines LineReader has
	var file LineReader
	var cur_line str?

[global]
def readlines() Lines *posix.FILE
	return readlines(stdin)

[global]
def readlines[LineReader](f LineReader) Lines LineReader
	return Lines(f, Empty)

[global]
def __iter_begin__[LineReader](fl Lines LineReader) Lines LineReader
	__iterate__(fl)
	return fl

[global]
def __iter_end__(fl Lines any) null
	return null

[global]
def __iter_valid__(fl Lines any, _ null) bool
	return exists(fl.cur_line)

[global]
def __iter_item__(fl Lines any) str
	match fl.cur_line
		Just(line)
			return line
		Empty
			return ""

[global]
def __iterate__(fl Lines any)
	match readline(fl.file)
		Line(line)
			fl.cur_line = Just(line)
		Error(errno)
			print("Error: encountered error " + errno + " while reading file")
			fl.cur_line = Empty
		EOF
			fl.cur_line = Empty

